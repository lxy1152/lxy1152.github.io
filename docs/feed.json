{
  "version": "https://jsonfeed.org/version/1.1",
  "title": "Xiangyu's Blog",
  "home_page_url": "https://blog.lixiangyu.xyz/",
  "feed_url": "https://blog.lixiangyu.xyz/feed.json",
  "author": {
    "name": "Xiangyu Li"
  },
  "items": [
    {
      "title": "LeetCode 1-100题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1-100/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1-100/",
      "summary": "1-100题题解",
      "content_html": "<h2 id=\"_26-删除有序数组中的重复项\"> <a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" target=\"_blank\" rel=\"noopener noreferrer\">26. 删除有序数组中的重复项</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给你一个有序数组 <code>nums</code>，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。</p>\n<p>{% note warning flat %}\n不要使用额外的数组空间，你必须在原地修改输入数组并在使用 <code>O(1)</code> 额外空间的条件下完成。\n{% endnote %}</p>\n<p>{% note info flat %}</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span>3</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><code>nums</code> 已按升序排列\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>nums = [1, 1, 2]</code>\n输出： <code>2</code>\n</p>\n\n<p>输入： <code>nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]</code>\n输出： <code>5</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>使用双指针，一个用于循环数组，一个用于指示要修改的位置。</p>\n<p>{% note info flat %}\n需要考虑数组长度为 <code>0</code> 或 <code>1</code> 的情况。\n{% endnote %}</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>\n        <span>return</span> n<span>;</span>\n    <span>}</span>\n    <span>int</span> cur <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>\n            nums<span>[</span>cur<span>++</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    nums<span>[</span>cur<span>++</span><span>]</span> <span>=</span> nums<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>\n    <span>return</span> cur<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>{% note success flat %}\n执行用时：1 ms, 在所有 Java 提交中击败了81.40%的用户\n内存消耗：40.1 MB, 在所有 Java 提交中击败了90.45%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_27-移除元素\"> <a href=\"https://leetcode-cn.com/problems/remove-element/\" target=\"_blank\" rel=\"noopener noreferrer\">27. 移除元素</a></h2>\n<h3 id=\"题目描述-2\"> 题目描述</h3>\n<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要原地移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>\n<p>{% note warning flat %}\n不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 的额外空间并原地修改输入数组，但是元素的顺序可以改变，你不需要考虑数组中超出新长度后面的元素。\n{% endnote %}</p>\n<p>{% note info flat %}</p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 50</code></li>\n<li><code>0 &lt;= val &lt;= 100</code>\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-2\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>nums = [3, 2, 2, 3], val = 3</code>\n输出： <code>2</code>\n</p>\n\n<p>输入： <code>nums = [0, 1, 2, 2, 3, 0, 4, 2], val = 2</code>\n输出： <code>5</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-2\"> 解题思路</h3>\n<p>使用双指针，一个用于循环数组，一个用于指示要修改的位置。</p>\n<h3 id=\"代码实现-2\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>removeElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n    <span>int</span> cur <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> val<span>)</span> <span>{</span>\n            nums<span>[</span>cur<span>++</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> cur<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：37 MB, 在所有 Java 提交中击败了63.55%的用户\n{% endnote %}</p>\n<hr>\n",
      "date_published": "2021-04-19T17:13:29.000Z",
      "date_modified": "2021-04-19T09:52:43.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 201-300题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/201-300/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/201-300/",
      "summary": "201-300题题解",
      "content_html": "<h2 id=\"_232-用栈实现队列\"> <a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\" target=\"_blank\" rel=\"noopener noreferrer\">232.用栈实现队列</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>请你仅使用两个栈实现先入先出队列，队列应当支持一般队列的支持的所有操作（<code>push</code>，<code>pop</code>，<code>peek</code>，<code>empty</code>）：\n实现 <code>MyQueue</code> 类，它应该包含如下的方法：</p>\n<ul>\n<li><code>void push(int x)</code>：将元素 <code>x</code> 添加到队尾</li>\n<li><code>int pop()</code>：移除队首元素并返回</li>\n<li><code>int peek()</code>：查看队首元素</li>\n<li><code>boolean empty()</code>：判断队列是否为空</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span>x</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>9</span></span></span></span></li>\n<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code> 方法</li>\n<li>假设所有操作都是有效的（例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>\n</ul>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>输入：</p>\n<p><code>[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</code>\n<code>[[], [1], [2], [], [], []]</code></p>\n<p>输出：</p>\n<p><code>[null, null, null, 1, 1, false]</code></p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>使用两个栈分别保存输入和输出的元素，在调用 <code>peek</code> 和 <code>pop</code> 操作之前将输入栈中的元素搬到输出栈即可。</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>/**\n * 本题使用的数据结构\n */</span>\n<span>class</span> <span>MyQueue</span> <span>{</span>\n    <span>/**\n     * 保存入栈元素\n     */</span>\n    <span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> inStack<span>;</span>\n\n    <span>/**\n     * 保存出栈元素\n     */</span>\n    <span>private</span> <span>Stack</span><span><span>&lt;</span><span>Integer</span><span>></span></span> outStack<span>;</span>\n\n    <span>/**\n     * 默认构造器, 初始化栈\n     */</span>\n    <span>public</span> <span>MyQueue</span><span>(</span><span>)</span> <span>{</span>\n        inStack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n        outStack <span>=</span> <span>new</span> <span>Stack</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 将元素放入队尾\n     *\n     * @param x 要放入队列的元素\n     */</span>\n    <span>public</span> <span>void</span> <span>push</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n        inStack<span>.</span><span>push</span><span>(</span>x<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 从队列中移除队首元素并返回该值\n     *\n     * @return 队首元素的值\n     */</span>\n    <span>public</span> <span>int</span> <span>pop</span><span>(</span><span>)</span> <span>{</span>\n        <span>moveDataFromInStackToOutStack</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> outStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 查看队首元素\n     *\n     * @return 队首元素\n     */</span>\n    <span>public</span> <span>int</span> <span>peek</span><span>(</span><span>)</span> <span>{</span>\n        <span>moveDataFromInStackToOutStack</span><span>(</span><span>)</span><span>;</span>\n        <span>return</span> outStack<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 判断队列是否为空\n     *\n     * @return 队列是否为空\n     */</span>\n    <span>public</span> <span>boolean</span> <span>empty</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> inStack<span>.</span><span>empty</span><span>(</span><span>)</span> <span>&amp;&amp;</span> outStack<span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 将保存在入栈中的元素搬到出栈中, 只在出栈为空时才搬运\n     */</span>\n    <span>private</span> <span>void</span> <span>moveDataFromInStackToOutStack</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>outStack<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n            <span>while</span> <span>(</span><span>!</span>inStack<span>.</span><span>empty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                outStack<span>.</span><span>push</span><span>(</span>inStack<span>.</span><span>pop</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><hr>\n<h2 id=\"_263-丑数\"> <a href=\"https://leetcode-cn.com/problems/ugly-number/\" target=\"_blank\" rel=\"noopener noreferrer\">263.丑数</a></h2>\n<h3 id=\"题目描述-2\"> 题目描述</h3>\n<p>给你一个整数 <code>n</code>，请你判断 <code>n</code> 是否为丑数，如果是则返回 <code>true</code>， 否则返回 <code>false</code>。\n丑数就是只包含质因数 <code>2，3，5</code> 的<strong>正整数</strong>。</p>\n<p>{% note info flat %}\n<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span>−</span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span>n</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span>\n{% endnote %}</p>\n<h3 id=\"示例输出-2\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>n = 6</code>\n输出： <code>true</code>\n</p>\n\n<p>输入： <code>n = 8</code>\n输出： <code>true</code>\n</p>\n\n<p>输入： <code>n = 14</code>\n输出： <code>false</code>\n</p>\n\n<p>输入： <code>n = 1</code>\n输出： <code>true</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-2\"> 解题思路</h3>\n<p>根据题意，<code>0</code> 和负数一定不是丑数。对于正整数中的 <code>1</code>，认为它是丑数。</p>\n<p>对于其他的正整数，由于因数只有 <code>2，3，5</code>，如果这个数能够将这三个因数除完，那么它就是丑数。</p>\n<h3 id=\"代码实现-2\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>boolean</span> <span>isUgly</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>false</span><span>;</span>\n    <span>}</span>\n    <span>int</span><span>[</span><span>]</span> factors <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>2</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>}</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> factor <span>:</span> factors<span>)</span> <span>{</span>\n        <span>while</span> <span>(</span>n <span>%</span> factor <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            n <span>/=</span> factor<span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> n <span>==</span> <span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><hr>\n<h2 id=\"_264-丑数-ii\"> <a href=\"https://leetcode-cn.com/problems/ugly-number-ii/\" target=\"_blank\" rel=\"noopener noreferrer\">264.丑数 II</a></h2>\n<h3 id=\"题目描述-3\"> 题目描述</h3>\n<p>给你一个整数 <code>n</code>，请你找出并返回第 <code>n</code> 个丑数。\n丑数就是只包含质因数 <code>2，3，5</code> 的<strong>正整数</strong>。</p>\n<p>{% note info flat %}\n<code>1 &lt;= n &lt;= 1690</code>\n{% endnote %}</p>\n<h3 id=\"示例输出-3\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>n = 10</code>\n输出： <code>12</code>\n</p>\n\n<p>输入： <code>n = 1</code>\n输出： <code>1</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-3\"> 解题思路</h3>\n<p>像263题一样一个一个数枚举判断是一种可行的方案，但肯定是不可取的。</p>\n<p>根据丑数的定义，<code>1</code> 一定是丑数，那么 <code>1</code> 的 <code>2</code> 倍，<code>3</code> 倍，<code>5</code> 倍所对应的数一定还是丑数，同理 <code>2</code> 的 <code>2</code> 倍，<code>3</code> 倍，<code>5</code> 倍所对应的数一定也是丑数。也就是说用 <code>1</code> 乘以 <code>x</code> 倍就可以得到任意的一个丑数。</p>\n<p>将这些丑数整合起来就可以得到一个丑数列，题目要求的就是这个丑数列的第 <code>n</code> 项。</p>\n<p>{% note warning flat %}\n在往 <code>dp</code> 数组中存的时候需要注意大小顺序。\n{% endnote %}</p>\n<h3 id=\"代码实现-3\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>nthUglyNumber</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>\n    dp<span>[</span><span>1</span><span>]</span> <span>=</span> <span>1</span><span>;</span>\n    <span>int</span> p2 <span>=</span> <span>1</span><span>;</span>\n    <span>int</span> p3 <span>=</span> <span>1</span><span>;</span>\n    <span>int</span> p5 <span>=</span> <span>1</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>int</span> num2 <span>=</span> dp<span>[</span>p2<span>]</span> <span>*</span> <span>2</span><span>;</span>\n        <span>int</span> num3 <span>=</span> dp<span>[</span>p3<span>]</span> <span>*</span> <span>3</span><span>;</span>\n        <span>int</span> num5 <span>=</span> dp<span>[</span>p5<span>]</span> <span>*</span> <span>5</span><span>;</span>\n        dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span><span>Math</span><span>.</span><span>min</span><span>(</span>num2<span>,</span> num3<span>)</span><span>,</span> num5<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> num2<span>)</span> <span>{</span>\n            p2<span>++</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> num3<span>)</span> <span>{</span>\n            p3<span>++</span><span>;</span>\n        <span>}</span>\n        <span>if</span> <span>(</span>dp<span>[</span>i<span>]</span> <span>==</span> num5<span>)</span> <span>{</span>\n            p5<span>++</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>{% note success flat %}\n执行用时：2 ms, 在所有 Java 提交中击败了97.4%的用户\n内存消耗：37.5 MB, 在所有 Java 提交中击败了69.5%的用户\n{% endnote %}</p>\n<hr>\n",
      "date_published": "2021-04-13T14:29:15.000Z",
      "date_modified": "2021-04-13T08:29:26.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 101-200题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/101-200/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/101-200/",
      "summary": "101-200题题解",
      "content_html": "<h2 id=\"_179-最大数\"> <a href=\"https://leetcode-cn.com/problems/largest-number/\" target=\"_blank\" rel=\"noopener noreferrer\">179.最大数</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数，输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>nums = [10, 2]</code>\n输出： <code>&quot;210&quot;</code>\n</p>\n\n<p>输入： <code>nums = [3, 30, 34, 5, 9]</code>\n输出： <code>&quot;9534330&quot;</code>\n</p>\n\n<p>输入： <code>nums = [1]</code>\n输出： <code>&quot;1&quot;</code>\n</p>\n\n<p>输入： <code>nums = [10]</code>\n输出： <code>&quot;10&quot;</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>为了避免数字溢出，先将所有的数字都转为字符串。</p>\n<p>同时为了使组成的数字尽可能的大，需要将数值较大的数放在高位，所以这与普通的排序方式不太相同。为了实现这种排序，需要用到 <code>(a, b) -&gt; (b + a).compareTo(a + b)</code>。</p>\n<p>{% note warning flat %}\n测试用例中有 <code>nums = [0, 0]</code>的情况，需要输出 <code>0</code>，而不是 <code>00</code>。\n{% endnote %}</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>String</span> <span>largestNumber</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n    <span>// 把数字转为字符串</span>\n    <span>String</span><span>[</span><span>]</span> numsToWord <span>=</span> <span>new</span> <span>String</span><span>[</span>n<span>]</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        numsToWord<span>[</span>i<span>]</span> <span>=</span> <span>String</span><span>.</span><span>valueOf</span><span>(</span>nums<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>// [\"120\", \"110\", \"300\", \"1\"]排序后变为[\"300\", \"120\", \"1\", \"110\"]</span>\n    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>numsToWord<span>,</span> <span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>(</span>b <span>+</span> a<span>)</span><span>.</span><span>compareTo</span><span>(</span>a <span>+</span> b<span>)</span><span>)</span><span>;</span>\n    <span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        stringBuilder<span>.</span><span>append</span><span>(</span>numsToWord<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>String</span> result <span>=</span> stringBuilder<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n    <span>// 有\"00\"的情况</span>\n    <span>return</span> result<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>==</span> <span>'0'</span> <span>?</span> <span>\"0\"</span> <span>:</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>{% note success flat %}\n执行用时：6 ms, 在所有 Java 提交中击败了90.3%的用户\n内存消耗：37.8 MB, 在所有 Java 提交中击败了79.7%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_191-位1的个数\"> <a href=\"https://leetcode-cn.com/problems/number-of-1-bits/\" target=\"_blank\" rel=\"noopener noreferrer\">191.位1的个数</a></h2>\n<h3 id=\"题目描述-2\"> 题目描述</h3>\n<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字 <code>1</code> 的个数（也被称为汉明重量）。</p>\n<p>{% note warning flat %}</p>\n<ul>\n<li>在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，但结果是相同的，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的</li>\n<li>在 <code>Java</code> 中，编译器使用二进制补码记法来表示有符号整数，因此在下面的<strong>示例3</strong>中，输入的二进制串表示有符号整数 <code>-3</code></li>\n<li>输入的二进制串的长度一定是 <code>32</code> 位的\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-2\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>00000000000000000000000000001011</code>\n输出： <code>3</code>\n</p>\n\n<p>输入： <code>00000000000000000000000010000000</code>\n输出： <code>1</code>\n</p>\n\n<p>输入： <code>11111111111111111111111111111101</code>\n输出： <code>31</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-2\"> 解题思路</h3>\n<p>{% tabs solution %}\n\n对一个二进制串 <code>n</code>，如果对它使用位运算 <code>n &amp; (n - 1)</code> 那么将去掉这个二进制串最低位的 <code>1</code>，因为对于 <code>n - 1</code> 而言：</p>\n<ul>\n<li>如果需要借位，比如 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span>10</span><span><span>0</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，借位后将去掉一个最低位的 <code>1</code>，得到 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span>01</span><span><span>1</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，在做与运算时就会将最低位的 <code>1</code> 删掉</li>\n<li>如果不需要借位，比如 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span>01</span><span><span>1</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，减一是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.79444em;vertical-align:-0.15em;\"></span><span>01</span><span><span>0</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，在做与运算时就会将最低位的 <code>1</code> 删掉</li>\n</ul>\n<p>统计一下执行 <code>n &amp; (n - 1)</code> 的次数就是最后的结果\n</p>\n\n<p>除了使用 <code>n &amp; (n - 1)</code> 来计算结果以外，还可以直接调用 <code>Integer.bitCount</code> 获取答案。\n\n{% endtabs %}</p>\n<h3 id=\"代码实现-2\"> 代码实现</h3>\n<p>{% tabs code %}\n</p>\n<div><pre><code><span>/**\n * 计算一个二进制数字中1的个数\n *\n * &lt;p>\n * 思路:&lt;br>\n * {@code n &amp; (n - 1)}表示去掉{@code n}的最低位的{@code 1}, 统计一下这个操作的次数就是二进制数中{@code 1}的个数\n * &lt;/p>\n *\n * @param n 一个32位的二进制数字\n * @return 这个二进制数字中1的个数\n */</span>\n<span>public</span> <span>int</span> <span>hammingWeight</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>while</span> <span>(</span>n <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        n <span>&amp;=</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>\n        result<span>++</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>{% note success flat %}\n执行用时：1 ms, 在所有 Java 提交中击败了95.76%的用户\n内存消耗：35.5 MB, 在所有 Java 提交中击败了25.10%的用户\n{% endnote %}\n</p>\n\n<div><pre><code><span>public</span> <span>int</span> <span>hammingWeight</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>return</span> <span>Integer</span><span>.</span><span>bitCount</span><span>(</span>n<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>{% note success flat %}\n执行用时：1 ms, 在所有 Java 提交中击败了95.76%的用户\n内存消耗：35.2 MB, 在所有 Java 提交中击败了88.83%的用户\n{% endnote %}\n\n{% endtabs %}</p>\n<hr>\n<h2 id=\"_198-打家劫舍\"> <a href=\"https://leetcode-cn.com/problems/house-robber/\" target=\"_blank\" rel=\"noopener noreferrer\">198. 打家劫舍</a></h2>\n<h3 id=\"题目描述-3\"> 题目描述</h3>\n<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统。如果两间相邻的房屋在同一晚上被小偷闯入, 系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算在不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。</p>\n<p>{% note info flat %}</p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 100</code></li>\n<li><code>0 &lt;= nums[i] &lt;= 400</code>\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-3\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>[1, 2, 3, 1]</code>\n输出： <code>4</code>\n</p>\n\n<p>输入： <code>[2, 7, 9, 3, 1]</code>\n输出： <code>12</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-3\"> 解题思路</h3>\n<p>如果只有一户人家，那直接偷就完事了。如果有两户人家，需要衡量一下哪家的钱多，再决定偷哪家。如果多于两户人家，那么对于之后的每户人家 <code>i</code>，偷与不偷取决于 <code>nums[i - 2] + nums[i]</code> 和 <code>nums[i - 1]</code> 之间的大小关系，从而得到递推式：</p>\n<p><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span>Math.max</span></span><span>(</span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>2</span><span>]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>])</span></span></span></span>， 其中：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>0</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>0</span><span>]</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>d</span><span>p</span><span>[</span><span>1</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span>Math.max</span></span><span>(</span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>0</span><span>]</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>1</span><span>])</span></span></span></span>。</p>\n<h3 id=\"代码实现-3\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>rob</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n    <span>if</span> <span>(</span>n <span>==</span> <span>1</span><span>)</span> <span>{</span>\n        <span>return</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>\n    dp<span>[</span><span>1</span><span>]</span> <span>=</span> nums<span>[</span><span>0</span><span>]</span><span>;</span>\n    dp<span>[</span><span>2</span><span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>nums<span>[</span><span>0</span><span>]</span><span>,</span> nums<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>\n\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        dp<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>dp<span>[</span>i <span>-</span> <span>2</span><span>]</span> <span>+</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> dp<span>[</span>n<span>]</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：35.7 MB, 在所有 Java 提交中击败了83.35%的用户\n{% endnote %}</p>\n<hr>\n",
      "date_published": "2021-04-13T14:15:00.000Z",
      "date_modified": "2021-04-19T09:52:43.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 1701-1800题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1701-1800/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1701-1800/",
      "summary": "1701-1800题题解",
      "content_html": "<h2 id=\"_1800-最大升序子数组和\"> <a href=\"https://leetcode-cn.com/problems/maximum-ascending-subarray-sum/\" target=\"_blank\" rel=\"noopener noreferrer\">1800.最大升序子数组和</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给你一个正整数组成的数组 <code>nums</code> ，返回 <code>nums</code> 中一个<strong>升序</strong>子数组的最大可能元素和（子数组是数组中的一个连续数字序列）。</p>\n<p>{% note info flat %}\n对于子数组 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>[</span><span>n</span><span>u</span><span>m</span><span><span>s</span><span><span><span><span style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.01968em;\">l</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span>u</span><span>m</span><span><span>s</span><span><span><span><span style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.01968em;\">l</span><span>+</span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>…</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span>u</span><span>m</span><span><span>s</span><span><span><span><span style=\"height:0.301108em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span style=\"margin-right:0.02778em;\">r</span><span>−</span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.208331em;\"><span></span></span></span></span></span></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span>u</span><span>m</span><span><span>s</span><span><span><span><span style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.02778em;\">r</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>]</span></span></span></span> ，若对所有的 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>i</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">r</span><span>)</span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.6891em;vertical-align:-0.15em;\"></span><span>n</span><span>u</span><span>m</span><span><span>s</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.638891em;vertical-align:-0.208331em;\"></span><span>n</span><span>u</span><span>m</span><span><span>s</span><span><span><span><span style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>i</span><span>+</span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span> 都成立，则称这一子数组为<strong>升序</strong>子数组。注意，大小为 <code>1</code> 的子数组也视作<strong>升序</strong>子数组。\n{% endnote %}</p>\n<p>{% note warning flat %}\n注意：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>100</span></span></span></span>， <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>100</span></span></span></span>\n{% endnote %}</p>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>nums = [10, 20, 30, 5, 10, 50]</code>\n输出： <code>65</code>\n</p>\n\n<p>输入： <code>nums = [10, 20, 30, 40, 50]</code>\n输出： <code>150</code>\n</p>\n\n<p>输入： <code>nums = [12, 17, 15, 13, 10, 11, 12]</code>\n输出： <code>33</code>\n</p>\n\n<p>输入： <code>nums = [100, 10, 1]</code>\n输出： <code>100</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>{% tabs solution %}\n\n首先想到的就是动态规划，不妨用一个二维 <code>dp</code> 数组来表示：从第 <code>i</code> 个位置到第 <code>j</code> 个位置的升序子数组的和。<code>dp</code> 数组中的最大值就是所求的结果。</p>\n<p>对于固定的 <code>i</code> 如果新加入的 <code>nums[j]</code> 比 <code>nums[j - 1]</code> 要大，那么这个子数组还是升序子数组，只需要在原有基础上加上 <code>nums[j]</code> 就是 <code>dp[i][j]</code> 的值了。如果这一条件不满足，则需要令 <code>dp[i][j] = nums[j]</code>（因为这个值可能是后面的升序子数组的第一个值，不能简单的直接给 <code>0</code>）。</p>\n<p>状态转移方程：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:4.32em;vertical-align:-1.9099999999999997em;\"></span><span><span><span><span><span><span style=\"height:2.3500199999999998em;\"><span style=\"top:-2.19999em;\"><span style=\"height:3.15em;\"></span><span><span>⎩</span></span></span><span style=\"top:-2.19199em;\"><span style=\"height:3.15em;\"></span><span style=\"height:0.31599999999999984em;width:0.889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.889em' height='0.31599999999999984em' style='width:0.889em' viewBox='0 0 889 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style=\"top:-3.15001em;\"><span style=\"height:3.15em;\"></span><span><span>⎨</span></span></span><span style=\"top:-4.292009999999999em;\"><span style=\"height:3.15em;\"></span><span style=\"height:0.31599999999999984em;width:0.889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.889em' height='0.31599999999999984em' style='width:0.889em' viewBox='0 0 889 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style=\"top:-4.600019999999999em;\"><span style=\"height:3.15em;\"></span><span><span>⎧</span></span></span></span><span>​</span></span><span><span style=\"height:1.8500199999999998em;\"><span></span></span></span></span></span></span><span><span><span><span><span><span style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span style=\"height:3.008em;\"></span><span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span><span style=\"top:-2.97em;\"><span style=\"height:3.008em;\"></span><span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span></span></span><span style=\"top:-1.5300000000000002em;\"><span style=\"height:3.008em;\"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style=\"height:1.9099999999999997em;\"><span></span></span></span></span></span><span style=\"width:1em;\"></span><span><span><span><span style=\"height:2.41em;\"><span style=\"top:-4.41em;\"><span style=\"height:3.008em;\"></span><span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&gt;</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span></span></span><span style=\"top:-2.97em;\"><span style=\"height:3.008em;\"></span><span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span></span></span><span style=\"top:-1.5300000000000002em;\"><span style=\"height:3.008em;\"></span><span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0</span><span style=\"margin-right:1em;\"></span><span><span>or</span></span><span style=\"margin-right:1em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0</span></span></span></span><span>​</span></span><span><span style=\"height:1.9099999999999997em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n<p>需要考虑以下特殊情况：</p>\n<ol>\n<li><strong>对角线元素 <code>dp[i][i]</code> 的值应该怎么取</strong>\n由题意，大小为 <code>1</code> 的子数组也视作<strong>升序</strong>子数组，所以它的值取 <code>nums[i]</code> 就可以了</li>\n<li><strong>如果 <code>dp[i][j]</code> 数组不是升序子数组，那么值应该怎么取</strong>\n如上面所分析的，值需要取 <code>nums[j]</code></li>\n<li><strong><code>dp[i][0]</code> 和 <code>dp[0][j]</code> 的值应该怎么取</strong>\n因为要求和，这些位置全部给 <code>0</code>\n</li>\n</ol>\n\n<p>对于 <code>dp</code> 数组而言，实际上与 <code>i</code> 是无关的，因为我们的前提是“<strong>对于固定的 <code>i</code></strong>”。那么可以把 <code>dp</code> 数组简化成一维的，通过在循环中不断求最值来实时更新最后的结果值。其中： <code>dp[i]</code> 表示某一个升序子数组的元素和。 <code>dp</code> 数组中的最大值就是所求的结果。</p>\n<p>状态转移方程：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>p</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span><span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span>d</span><span>p</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span><span style=\"width:1em;\"></span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>1</span><span style=\"margin-right:1em;\"></span><span><span>or</span></span><span style=\"margin-right:1em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>2</span><span>]</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span>else</span></span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n\n<p>{% endtabs %}</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<p>{% tabs code %}\n</p>\n<div><pre><code><span>public</span> <span>int</span> <span>maxAscendingSum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n    <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>int</span> j <span>=</span> i<span>;</span> j <span>&lt;=</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>i <span>==</span> j<span>)</span> <span>{</span>\n                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>></span> nums<span>[</span>j <span>-</span> <span>2</span><span>]</span> <span>?</span> dp<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>+</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>:</span> nums<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>\n            <span>}</span>\n            result <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>result<span>,</span> dp<span>[</span>i<span>]</span><span>[</span>j<span>]</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>{% note success flat %}\n执行用时：5 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：37.5 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}\n</p>\n\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>maxAscendingSum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n    <span>int</span><span>[</span><span>]</span> dp <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>i <span>==</span> <span>1</span> <span>||</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>&lt;=</span> nums<span>[</span>i <span>-</span> <span>2</span><span>]</span><span>)</span> <span>{</span>\n            dp<span>[</span>i<span>]</span> <span>=</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            dp<span>[</span>i<span>]</span> <span>=</span> dp<span>[</span>i <span>-</span> <span>1</span><span>]</span> <span>+</span> nums<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>;</span>\n        <span>}</span>\n        result <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>result<span>,</span> dp<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：36.1 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}\n\n{% endtabs %}</p>\n<hr>\n",
      "date_published": "2021-04-13T14:47:56.000Z",
      "date_modified": "2021-04-13T07:11:18.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 301-400题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/301-400/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/301-400/",
      "summary": "301-400题题解",
      "content_html": "<h2 id=\"_303-区域和检索-数组不可变\"> <a href=\"https://leetcode-cn.com/problems/range-sum-query-immutable/\" target=\"_blank\" rel=\"noopener noreferrer\">303.区域和检索-数组不可变</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给定一个整数数组 <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code> （  <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.05724em;\">j</span></span></span></span> ）范围内元素的总和，包含 <code>i, j</code> 两端点。\n你需要实现 <code>NumArray</code> 类中的构造器和 <code>sumRange</code> 方法：</p>\n<ol>\n<li>构造器 <code>NumArray(int[])</code> 使用数组 <code>nums</code> 初始化对象</li>\n<li><code>sumRange(int, int)</code> 方法返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code>( <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.05724em;\">j</span></span></span></span> )范围内元素的总和，包含 <code>i, j</code> 两点</li>\n</ol>\n<p>其中：</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>5</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span></span></span></span></li>\n<li>最多调用 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span> 次 <code>sumRange</code> 方法</li>\n</ul>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>假设数组 <code>nums = [-2, 0, 3, -5, 2, -1]</code>，并依次调用 <code>sumRange</code> 函数：</p>\n<ul>\n<li><code>sumRange(0, 2)</code></li>\n<li><code>sumRange(2, 5)</code></li>\n<li><code>sumRange(0, 5)</code></li>\n</ul>\n<p>输出：<code>[null, 1, -1, -3]</code></p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>可以在每次调用 <code>sumRange</code> 函数的时候计算一次对应范围内的元素，但是这样会导致时间复杂度变为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>(</span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>))</span></span></span></span> （调用 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>n</span></span></span></span> 次，每次需要遍历 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.05724em;\">j</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.74285em;vertical-align:-0.08333em;\"></span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span> 长度的子数组）。这种方案可以但并不好。</p>\n<p>所以有没有一种方案可以降低 <code>sumRange</code> 函数的时间复杂度呢？是有的，这需要在构造器中对对象做一些特殊处理。即使用一个数组来保存不同区间元素<a href=\"./../../概念梳理/算法思想/前缀和.html\">前缀和</a>。但是前缀和的递推公式 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>b</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>b</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>a</span><span>[</span><span>i</span><span>]</span></span></span></span> 在 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>0</span></span></span></span> 时会有 <code>-1</code> 的特殊情况，所以统一将前缀和数组的下标做加一处理。</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>/**\n * 本题使用的数据结构&lt;br>\n * 通过这个数据结构能够快速得到索引位置{@code i}和索引位置{@code j}之间的元素和\n *\n * @author lixiangyu\n */</span>\n<span>class</span> <span>NumArray</span> <span>{</span>\n    <span>/**\n     * 保存前缀和的数组\n     */</span>\n    <span>private</span> <span>int</span><span>[</span><span>]</span> preSum<span>;</span>\n\n    <span>/**\n     * 默认构造器, 在这里需要对数组做特殊处理, 尽量降低查找时的时间复杂度\n     *\n     * @param nums 一个数组\n     */</span>\n    <span>public</span> <span>NumArray</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n        <span>// 数组长度</span>\n        <span>int</span> n <span>=</span> nums<span>.</span>length<span>;</span>\n        <span>/*\n         * 如果最后返回的是: preSum[i, j] = preSum[j] - preSum[i - 1]\n         * 在索引0处需要做特殊判断, 为了避免这种情况, 整体向右移一位, 相应的长度需要加1\n         */</span>\n        preSum <span>=</span> <span>new</span> <span>int</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            preSum<span>[</span>i <span>+</span> <span>1</span><span>]</span> <span>=</span> preSum<span>[</span>i<span>]</span> <span>+</span> nums<span>[</span>i<span>]</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 得到索引位置{@code i}和索引位置{@code j}之间的元素和\n     *\n     * &lt;p>\n     * 思路:&lt;br>\n     * 最简单的思路是在每次查询的时候遍历数组, 时间复杂度是{@code O(∑)}(∑是两索引间的元素个数),\n     * 在反复查询的场景下, 可能会导致超时&lt;br>\n     * 所以使用前缀和对数组做预处理, 使计算元素和的时间复杂度将为{@code O(1)}&lt;br>\n     * &lt;b>注: 前缀和是指第一个元素到第{@code i}个元素之间的和&lt;/b>\n     * &lt;/p>\n     *\n     * @param i 一个索引位置\n     * @param j 一个索引位置\n     * @return 这两个索引之间的元素和\n     */</span>\n    <span>public</span> <span>int</span> <span>sumRange</span><span>(</span><span>int</span> i<span>,</span> <span>int</span> j<span>)</span> <span>{</span>\n        <span>return</span> preSum<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>-</span> preSum<span>[</span>i<span>]</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><hr>\n<h2 id=\"_304-二维区域和检索-矩阵不可变\"> <a href=\"https://leetcode-cn.com/problems/range-sum-query-2d-immutable/\" target=\"_blank\" rel=\"noopener noreferrer\">304.二维区域和检索-矩阵不可变</a></h2>\n<h3 id=\"题目描述-2\"> 题目描述</h3>\n<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，假设该子矩阵的左上角为 <code>row1</code>，<code>col1</code>，右下角为 <code>row2</code>，<code>col2</code>。</p>\n<h3 id=\"示例输出-2\"> 示例输出</h3>\n<p>假设输入矩阵为：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:9.040000000000003em;vertical-align:-4.250000000000002em;\"></span><span><span><span><span style=\"height:4.79em;\"><span style=\"top:-6.75em;\"><span style=\"height:6.75em;\"></span><span><span style=\"height:9em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-4.25em;\"></span><span style=\"width:0.5em;\"></span><span><span><span><span style=\"height:4.75em;\"><span style=\"top:-6.75em;\"><span style=\"height:3.26em;\"></span><span><span>3</span></span></span><span style=\"top:-4.949999999999999em;\"><span style=\"height:3.26em;\"></span><span><span>5</span></span></span><span style=\"top:-3.1499999999999986em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span><span style=\"top:-1.3499999999999988em;\"><span style=\"height:3.26em;\"></span><span><span>4</span></span></span><span style=\"top:0.45000000000000195em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style=\"height:4.250000000000002em;\"><span></span></span></span></span></span><span style=\"width:0.5em;\"></span><span style=\"height:9em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-4.25em;\"></span><span style=\"width:0.5em;\"></span><span><span><span><span style=\"height:4.75em;\"><span style=\"top:-6.75em;\"><span style=\"height:3.26em;\"></span><span><span>0</span></span></span><span style=\"top:-4.949999999999999em;\"><span style=\"height:3.26em;\"></span><span><span>6</span></span></span><span style=\"top:-3.1499999999999986em;\"><span style=\"height:3.26em;\"></span><span><span>2</span></span></span><span style=\"top:-1.3499999999999988em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span><span style=\"top:0.45000000000000195em;\"><span style=\"height:3.26em;\"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style=\"height:4.250000000000002em;\"><span></span></span></span></span></span><span style=\"width:0.5em;\"></span><span style=\"height:9em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-4.25em;\"></span><span style=\"width:0.5em;\"></span><span><span><span><span style=\"height:4.75em;\"><span style=\"top:-6.75em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span><span style=\"top:-4.949999999999999em;\"><span style=\"height:3.26em;\"></span><span><span>3</span></span></span><span style=\"top:-3.1499999999999986em;\"><span style=\"height:3.26em;\"></span><span><span>0</span></span></span><span style=\"top:-1.3499999999999988em;\"><span style=\"height:3.26em;\"></span><span><span>0</span></span></span><span style=\"top:0.45000000000000195em;\"><span style=\"height:3.26em;\"></span><span><span>3</span></span></span></span><span>​</span></span><span><span style=\"height:4.250000000000002em;\"><span></span></span></span></span></span><span style=\"width:0.5em;\"></span><span style=\"height:9em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-4.25em;\"></span><span style=\"width:0.5em;\"></span><span><span><span><span style=\"height:4.75em;\"><span style=\"top:-6.75em;\"><span style=\"height:3.26em;\"></span><span><span>4</span></span></span><span style=\"top:-4.949999999999999em;\"><span style=\"height:3.26em;\"></span><span><span>2</span></span></span><span style=\"top:-3.1499999999999986em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span><span style=\"top:-1.3499999999999988em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span><span style=\"top:0.45000000000000195em;\"><span style=\"height:3.26em;\"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style=\"height:4.250000000000002em;\"><span></span></span></span></span></span><span style=\"width:0.5em;\"></span><span style=\"height:9em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-4.25em;\"></span><span style=\"width:0.5em;\"></span><span><span><span><span style=\"height:4.75em;\"><span style=\"top:-6.75em;\"><span style=\"height:3.26em;\"></span><span><span>2</span></span></span><span style=\"top:-4.949999999999999em;\"><span style=\"height:3.26em;\"></span><span><span>1</span></span></span><span style=\"top:-3.1499999999999986em;\"><span style=\"height:3.26em;\"></span><span><span>5</span></span></span><span style=\"top:-1.3499999999999988em;\"><span style=\"height:3.26em;\"></span><span><span>7</span></span></span><span style=\"top:0.45000000000000195em;\"><span style=\"height:3.26em;\"></span><span><span>5</span></span></span></span><span>​</span></span><span><span style=\"height:4.250000000000002em;\"><span></span></span></span></span></span><span style=\"width:0.5em;\"></span><span style=\"height:9em;border-right-width:0.04em;border-right-style:solid;margin:0 -0.02em;vertical-align:-4.25em;\"></span></span></span><span style=\"top:-2.5em;\"><span style=\"height:6.75em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-4.3em;\"><span style=\"height:6.75em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-6.1em;\"><span style=\"height:6.75em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-7.9em;\"><span style=\"height:6.75em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-9.7em;\"><span style=\"height:6.75em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-11.5em;\"><span style=\"height:6.75em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span></span><span>​</span></span><span><span style=\"height:4.250000000000002em;\"><span></span></span></span></span></span></span></span></span></span></p>\n<p>依次调用 <code>sumRegion</code> 函数：</p>\n<ul>\n<li>sumRegion(2, 1, 4, 3)</li>\n<li>sumRegion(1, 1, 2, 2)</li>\n<li>sumRegion(1, 2, 2, 4)</li>\n</ul>\n<p>输出：<code>[null, 8, 11, 12]</code></p>\n<h3 id=\"解题思路-2\"> 解题思路</h3>\n<p>本题类似于 <a href=\"/cbb5d165\">303.区域和检索-数组不可变</a>，但是是前缀和在二维数组的应用。</p>\n<h3 id=\"代码实现-2\"> 代码实现</h3>\n<div><pre><code><span>/**\n * 本题使用的数据结构&lt;br>\n * 通过这个数据结构能够快速得到矩阵中某子矩阵的元素和\n *\n * @author lixiangyu\n */</span>\n<span>class</span> <span>NumMatrix</span> <span>{</span>\n    <span>/**\n     * 保存前缀和的数组\n     */</span>\n    <span>private</span> <span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> preSum<span>;</span>\n\n    <span>/**\n     * 默认构造器, 在这里需要对矩阵做特殊处理(计算前缀和), 尽量降低查找时的时间复杂度,\n     * 最好画图来理解(其实就是计算面积)\n     *\n     * @param matrix 一个矩阵\n     */</span>\n    <span>public</span> <span>NumMatrix</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> matrix<span>)</span> <span>{</span>\n        <span>// 注意题目在这里并没有保证行数一定大于0</span>\n        <span>int</span> m <span>=</span> matrix<span>.</span>length<span>;</span>\n        <span>if</span> <span>(</span>m <span>></span> <span>0</span><span>)</span> <span>{</span>\n            <span>int</span> n <span>=</span> matrix<span>[</span><span>0</span><span>]</span><span>.</span>length<span>;</span>\n            preSum <span>=</span> <span>new</span> <span>int</span><span>[</span>m <span>+</span> <span>1</span><span>]</span><span>[</span>n <span>+</span> <span>1</span><span>]</span><span>;</span>\n            <span>// 为了避免在索引0处的特殊处理, 将i, j统一做加1处理</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> m<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>for</span> <span>(</span><span>int</span> j <span>=</span> <span>1</span><span>;</span> j <span>&lt;=</span> n<span>;</span> j<span>++</span><span>)</span> <span>{</span>\n                    preSum<span>[</span>i<span>]</span><span>[</span>j<span>]</span> <span>=</span> preSum<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j<span>]</span> <span>+</span> preSum<span>[</span>i<span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>-</span> preSum<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>+</span> matrix<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>/**\n     * 得到某子矩阵的元素和\n     *\n     * &lt;p>\n     * 思路:&lt;br>\n     * 一维数组还可以暴力破解, 二维矩阵就不太可能了, 类似{@link SolutionQ303}的思路, 计算矩阵中每个子矩阵的前缀和\n     * &lt;/p>\n     *\n     * @param row1 第一个元素所在的行\n     * @param col1 第一个元素所在的列\n     * @param row2 第二个元素所在的行\n     * @param col2 第二个元素所在的列\n     * @return 这个子矩阵的元素和\n     */</span>\n    <span>public</span> <span>int</span> <span>sumRegion</span><span>(</span><span>int</span> row1<span>,</span> <span>int</span> col1<span>,</span> <span>int</span> row2<span>,</span> <span>int</span> col2<span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>preSum<span>[</span>row2 <span>+</span> <span>1</span><span>]</span><span>[</span>col2 <span>+</span> <span>1</span><span>]</span> <span>-</span> <span>this</span><span>.</span>preSum<span>[</span>row1<span>]</span><span>[</span>col2 <span>+</span> <span>1</span><span>]</span>\n                <span>-</span> <span>this</span><span>.</span>preSum<span>[</span>row2 <span>+</span> <span>1</span><span>]</span><span>[</span>col1<span>]</span> <span>+</span> <span>this</span><span>.</span>preSum<span>[</span>row1<span>]</span><span>[</span>col1<span>]</span><span>;</span>\n\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><hr>\n<h2 id=\"_338-比特位计数\"> <a href=\"https://leetcode-cn.com/problems/counting-bits/\" target=\"_blank\" rel=\"noopener noreferrer\">338.比特位计数</a></h2>\n<h3 id=\"题目描述-3\"> 题目描述</h3>\n<p>给定一个非负整数 <code>num</code>, 对于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.79549em;vertical-align:-0.13597em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>n</span><span>u</span><span>m</span></span></span></span>范围中的每个数字 <code>i</code>, 计算其二进制数中的 <code>1</code> 的数目并将它们作为数组返回。</p>\n<h3 id=\"示例输出-3\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>2</code>\n输出： <code>[0, 1, 1]</code>\n</p>\n\n<p>输入： <code>5</code>\n输出： <code>[0, 1, 1, 2, 1, 2]</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-3\"> 解题思路</h3>\n<p>{% tabs solution %}\n\n不妨先列举几个十进制数的二进制表示（下标表示进制）：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:12.000000000000002em;vertical-align:-5.750000000000001em;\"></span><span><span><span><span><span><span style=\"height:6.250000000000001em;\"><span style=\"top:-8.41em;\"><span style=\"height:3em;\"></span><span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-6.91em;\"><span style=\"height:3em;\"></span><span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-5.409999999999999em;\"><span style=\"height:3em;\"></span><span><span><span>2</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.9099999999999993em;\"><span style=\"height:3em;\"></span><span><span><span>3</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-2.4099999999999993em;\"><span style=\"height:3em;\"></span><span><span><span>4</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-0.9099999999999988em;\"><span style=\"height:3em;\"></span><span><span><span>5</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:0.5900000000000007em;\"><span style=\"height:3em;\"></span><span><span><span>6</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:2.0900000000000007em;\"><span style=\"height:3em;\"></span><span><span><span>7</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:5.750000000000001em;\"><span></span></span></span></span></span><span><span><span><span style=\"height:6.250000000000001em;\"><span style=\"top:-8.41em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-6.91em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-5.409999999999999em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.9099999999999993em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>1</span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-2.4099999999999993em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>10</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-0.9099999999999988em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>10</span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:0.5900000000000007em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>11</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:2.0900000000000007em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>11</span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:5.750000000000001em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>可以看到在移除一个二进制数（ <code>number</code> ）的最低位后，它将和 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.2251079999999999em;vertical-align:-0.345em;\"></span><span>⌊</span><span><span></span><span><span><span><span style=\"height:0.8801079999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span style=\"height:3em;\"></span><span><span><span>2</span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span style=\"height:3em;\"></span><span><span><span>n</span><span>u</span><span>mb</span><span style=\"margin-right:0.02778em;\">er</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.345em;\"><span></span></span></span></span></span><span></span></span><span>⌋</span></span></span></span> 的二进制表示相同。对于奇数，<code>1</code> 的个数需要加 <code>1</code>；对于偶数，<code>1</code> 的个数是相同的。</p>\n<p>根据这个结论，得到递推式：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span style=\"margin-right:0.10903em;\">tN</span><span>u</span><span>mb</span><span style=\"margin-right:0.02778em;\">er</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1.200664em;vertical-align:-0.345em;\"></span><span>bi</span><span style=\"margin-right:0.10903em;\">tN</span><span>u</span><span>mb</span><span style=\"margin-right:0.02778em;\">er</span><span>[⌊</span><span><span></span><span><span><span><span style=\"height:0.855664em;\"><span style=\"top:-2.6550000000000002em;\"><span style=\"height:3em;\"></span><span><span><span>2</span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span style=\"height:3em;\"></span><span><span><span>i</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.345em;\"><span></span></span></span></span></span><span></span></span><span>⌋]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span>i</span><span>%2</span><span>)</span></span></span></span>，其中 <code>bitNumber</code> 是一个保存二进制数的数组（除 <code>2</code> 和判断奇偶性均可通过位运算实现）。\n</p>\n\n<p>尝试移除一下二进制数的高位：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:4.500000000000002em;vertical-align:-2.000000000000001em;\"></span><span><span><span><span><span><span style=\"height:2.5000000000000004em;\"><span style=\"top:-4.66em;\"><span style=\"height:3em;\"></span><span><span><span>4</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.16em;\"><span style=\"height:3em;\"></span><span><span><span>5</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-1.6599999999999993em;\"><span style=\"height:3em;\"></span><span><span><span>6</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:2.000000000000001em;\"><span></span></span></span></span></span><span><span><span><span style=\"height:2.5000000000000004em;\"><span style=\"top:-4.66em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>10</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>→</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.16em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>10</span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>→</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0</span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span>1</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-1.6599999999999993em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>11</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>→</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>2</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.34480000000000005em;\"><span style=\"top:-2.5198em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>10</span><span>)</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.3551999999999999em;\"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:2.000000000000001em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>对于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span> 的数来说，移除最高位后一定是 <code>0</code>，因为这些数的二进制表示只有最高位是 <code>1</code>，其他位都是 <code>0</code>。对于其他的数，他们与转换后的数之间差了一个离他最近的 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span> 的举例，同时在 <code>1</code> 的个数上也差了 <code>1</code> 个。</p>\n<p>根据这个结论，可以得到递推式：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span style=\"margin-right:0.10903em;\">tN</span><span>u</span><span>mb</span><span style=\"margin-right:0.02778em;\">er</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>bi</span><span style=\"margin-right:0.10903em;\">tN</span><span>u</span><span>mb</span><span style=\"margin-right:0.02778em;\">er</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>d</span><span>i</span><span>s</span><span>t</span><span>an</span><span>ce</span><span>]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span>，其中 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span>d</span><span>i</span><span>s</span><span>t</span><span>an</span><span>ce</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>ma</span><span>x</span><span>(</span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span><span>)</span><span>,</span><span style=\"margin-right:0.5em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span></span></span></span>。\n\n{% endtabs %}</p>\n<h3 id=\"代码实现-3\"> 代码实现</h3>\n<p>{% tabs code %}\n</p>\n<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>countBits</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>\n    <span>int</span><span>[</span><span>]</span> result <span>=</span> <span>new</span> <span>int</span><span>[</span>num <span>+</span> <span>1</span><span>]</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        result<span>[</span>i<span>]</span> <span>=</span> result<span>[</span>i <span>>></span> <span>1</span><span>]</span> <span>+</span> <span>(</span>i <span>&amp;</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>\n\n<div><pre><code><span>public</span> <span>int</span><span>[</span><span>]</span> <span>countBits</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>\n    <span>int</span><span>[</span><span>]</span> result <span>=</span> <span>new</span> <span>int</span><span>[</span>num <span>+</span> <span>1</span><span>]</span><span>;</span>\n    <span>int</span> highBit <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>(</span>i <span>-</span> <span>1</span><span>)</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            highBit <span>=</span> i<span>;</span>\n        <span>}</span>\n        result<span>[</span>i<span>]</span> <span>=</span> result<span>[</span>i <span>-</span> highBit<span>]</span> <span>+</span> <span>1</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>\n<p>{% endtabs %}</p>\n<hr>\n<h2 id=\"_341-扁平化嵌套列表迭代器\"> <a href=\"https://leetcode-cn.com/problems/flatten-nested-list-iterator/\" target=\"_blank\" rel=\"noopener noreferrer\">341.扁平化嵌套列表迭代器</a></h2>\n<h3 id=\"题目描述-4\"> 题目描述</h3>\n<p>给你一个嵌套的整型列表，请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。\n列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>\n<h3 id=\"示例输出-4\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>[[1, 1], 2, [1, 1]]</code>\n输出： <code>[1, 1, 2, 1, 1]</code>\n</p>\n\n<p>输入： <code>[1, [4, [6]]]</code>\n输出： <code>[1, 4, 6]</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-4\"> 解题思路</h3>\n<p>可以先遍历一遍数组，将所有的数都保存到列表中，再通过这个列表实现 <code>next</code> 和 <code>hasNext</code> 方法。</p>\n<p>{% note info flat %}\n遍历数组需要使用 <code>dfs</code>。\n{% endnote %}</p>\n<h3 id=\"代码实现-4\"> 代码实现</h3>\n<div><pre><code><span>interface</span> <span>NestedInteger</span> <span>{</span>\n    <span>boolean</span> <span>isInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>Integer</span> <span>getInteger</span><span>(</span><span>)</span><span>;</span>\n\n    <span>List</span><span><span>&lt;</span><span>NestedInteger</span><span>></span></span> <span>getList</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>class</span> <span>NestedIterator</span> <span>implements</span> <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>Iterator</span><span><span>&lt;</span><span>Integer</span><span>></span></span> iterator<span>;</span>\n\n    <span>public</span> <span>NestedIterator</span><span>(</span><span>List</span><span><span>&lt;</span><span>NestedInteger</span><span>></span></span> nestedList<span>)</span> <span>{</span>\n        <span>dfs</span><span>(</span>nestedList<span>)</span><span>;</span>\n        iterator <span>=</span> list<span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Integer</span> <span>next</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>boolean</span> <span>hasNext</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>private</span> <span>void</span> <span>dfs</span><span>(</span><span>List</span><span><span>&lt;</span><span>NestedInteger</span><span>></span></span> nestedList<span>)</span> <span>{</span>\n        <span>for</span> <span>(</span><span>NestedInteger</span> nestedInteger <span>:</span> nestedList<span>)</span> <span>{</span>\n            <span>if</span> <span>(</span>nestedInteger<span>.</span><span>isInteger</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                list<span>.</span><span>add</span><span>(</span>nestedInteger<span>.</span><span>getInteger</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                <span>dfs</span><span>(</span>nestedInteger<span>.</span><span>getList</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>{% note success flat %}\n执行用时：3 ms, 在所有 Java 提交中击败了91.05%的用户\n内存消耗：41 MB, 在所有 Java 提交中击败了21.46%的用户\n{% endnote %}</p>\n<hr>\n",
      "date_published": "2021-04-13T14:32:36.000Z",
      "date_modified": "2021-04-13T07:11:18.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 1101-1100题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1001-1100/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1001-1100/",
      "summary": "1101-1100题题解",
      "content_html": "<h2 id=\"_1006-笨阶乘\"> <a href=\"https://leetcode-cn.com/problems/clumsy-factorial/\" target=\"_blank\" rel=\"noopener noreferrer\">1006.笨阶乘</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p>\n<p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(<code>*</code>)，除法(<code>/</code>)，加法(<code>+</code>)和减法(<code>-</code>)。</p>\n<p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>\n<p>另外，我们使用的除法是地板除法（floor division），所以 <code>10 * 9 / 8</code> 等于 <code>11</code>。这保证结果是一个整数。</p>\n<p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p>\n<p>{% note info flat %}\n<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span style=\"margin-right:0.10903em;\">N</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>10000</span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span>−</span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span>an</span><span>s</span><span style=\"margin-right:0.02691em;\">w</span><span style=\"margin-right:0.02778em;\">er</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span>\n{% endnote %}</p>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>4</code>\n输出： <code>7</code>\n</p>\n\n<p>输入： <code>10</code>\n输出： <code>12</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>使用栈模拟运算。</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>clumsy</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>Deque</span><span><span>&lt;</span><span>Integer</span><span>></span></span> stack <span>=</span> <span>new</span> <span>LinkedList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    stack<span>.</span><span>offer</span><span>(</span>n<span>)</span><span>;</span>\n\n    <span>char</span><span>[</span><span>]</span> op <span>=</span> <span>new</span> <span>char</span><span>[</span><span>]</span><span>{</span><span>'*'</span><span>,</span> <span>'/'</span><span>,</span> <span>'+'</span><span>,</span> <span>'-'</span><span>}</span><span>;</span>\n    <span>int</span> opIndex <span>=</span> <span>0</span><span>;</span>\n\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> n <span>-</span> <span>1</span><span>;</span> i <span>></span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>\n        <span>char</span> c <span>=</span> op<span>[</span>opIndex<span>]</span><span>;</span>\n        <span>switch</span> <span>(</span>c<span>)</span> <span>{</span>\n            <span>case</span> <span>'+'</span><span>:</span>\n                stack<span>.</span><span>push</span><span>(</span>i<span>)</span><span>;</span>\n                <span>break</span><span>;</span>\n            <span>case</span> <span>'-'</span><span>:</span>\n                stack<span>.</span><span>push</span><span>(</span><span>-</span>i<span>)</span><span>;</span>\n                <span>break</span><span>;</span>\n            <span>case</span> <span>'*'</span><span>:</span>\n                stack<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span> <span>*</span> i<span>)</span><span>;</span>\n                <span>break</span><span>;</span>\n            <span>case</span> <span>'/'</span><span>:</span>\n                stack<span>.</span><span>push</span><span>(</span>stack<span>.</span><span>pop</span><span>(</span><span>)</span> <span>/</span> i<span>)</span><span>;</span>\n                <span>break</span><span>;</span>\n        <span>}</span>\n        opIndex <span>=</span> <span>(</span>opIndex <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>4</span><span>;</span>\n    <span>}</span>\n\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>while</span> <span>(</span><span>!</span>stack<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n        result <span>+=</span> stack<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>{% note success flat %}\n执行用时：10 ms, 在所有 Java 提交中击败了14.84%的用户\n内存消耗：38.2 MB, 在所有 Java 提交中击败了7.74%的用户\n{% endnote %}</p>\n<hr>\n",
      "date_published": "2021-04-13T14:45:34.000Z",
      "date_modified": "2021-04-13T07:11:18.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 1801-1900题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1801-1900/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/1801-1900/",
      "summary": "1801-1900题题解",
      "content_html": "<h2 id=\"_1801-积压订单中的订单总数\"> <a href=\"https://leetcode-cn.com/problems/number-of-orders-in-the-backlog/\" target=\"_blank\" rel=\"noopener noreferrer\">1801.积压订单中的订单总数</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给你一个二维整数数组 <code>orders</code> ，其中每个 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span>ers</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>[</span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>c</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>am</span><span>o</span><span>u</span><span>n</span><span><span>t</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span style=\"margin-right:0.02778em;\">er</span><span style=\"margin-right:0.13889em;\">T</span><span style=\"margin-right:0.03588em;\">y</span><span>p</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>]</span></span></span></span> 表示有 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span>am</span><span>o</span><span>u</span><span>n</span><span><span>t</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 笔类型为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span style=\"margin-right:0.02778em;\">er</span><span style=\"margin-right:0.13889em;\">T</span><span style=\"margin-right:0.03588em;\">y</span><span>p</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，价格为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>c</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的订单。</p>\n<p>订单类型 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span style=\"margin-right:0.02778em;\">er</span><span style=\"margin-right:0.13889em;\">T</span><span style=\"margin-right:0.03588em;\">y</span><span>p</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 可以分为两种：</p>\n<ul>\n<li><code>0</code>：表示这是一批采购订单（ <code>buy</code> ）</li>\n<li><code>1</code>：表示这是一批销售订单（ <code>sell</code> ）</li>\n</ul>\n<p><code>orders[i]</code> 表示一批共计 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.76508em;vertical-align:-0.15em;\"></span><span>am</span><span>o</span><span>u</span><span>n</span><span><span>t</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 笔的独立订单，这些订单的价格和类型相同。对于所有有效的 <code>i</code>，由 <code>orders[i]</code> 表示的所有订单提交时间均早于 <code>orders[i+1]</code> 表示的所有订单。</p>\n<p>存在由未执行订单组成的<strong>积压订单</strong>。积压订单最初是空的，提交订单时，会发生以下情况：</p>\n<ul>\n<li>如果该订单是一笔采购订单 <code>buy</code> ，则可以查看积压订单中价格<strong>最低</strong>的销售订单 <code>sell</code>。如果该销售订单 <code>sell</code> 的价格<strong>低于或等于</strong>当前采购订单 <code>buy</code> 的价格，则匹配并执行这两笔订单，并将销售订单 <code>sell</code> 从积压订单中删除。否则，采购订单 <code>buy</code> 将会添加到积压订单中。</li>\n<li>如果该订单是一笔销售订单 <code>sell</code> ，则可以查看积压订单中价格<strong>最高</strong>的采购订单 <code>buy</code> 。如果该采购订单 <code>buy</code> 的价格<strong>高于或等于</strong>当前销售订单 <code>sell</code> 的价格，则匹配并执行这两笔订单，并将采购订单 <code>buy</code> 从积压订单中删除。否则，销售订单 <code>sell</code> 将会添加到积压订单中。</li>\n</ul>\n<p>在输入所有订单后，返回<strong>积压订单中的订单总数</strong> 。由于数字可能很大，所以需要返回对 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>7</span></span></span></span> 取余的结果。</p>\n<p>{% note warning flat %}\n注意：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span>ers</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span>ers</span><span>[</span><span>i</span><span>]</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>==</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>3</span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>i</span><span>c</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>am</span><span>o</span><span>u</span><span>n</span><span><span>t</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.02778em;\">or</span><span>d</span><span style=\"margin-right:0.02778em;\">er</span><span style=\"margin-right:0.13889em;\">T</span><span style=\"margin-right:0.03588em;\">y</span><span>p</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 为 0 或 1\n{% endnote %}</p>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n<img src=\"https://i.loli.net/2021/04/02/ky1pv4xsiUaCzYo.png\" alt=\"ex1.png\" />\n输入： <code>orders = [[10, 5, 0], [15, 2, 1], [25, 1, 1], [30, 4, 0]]</code>\n输出： <code>6</code>\n</p>\n\n<p><img src=\"https://i.loli.net/2021/04/02/Ch2eP8GMspHcoUT.png\" alt=\"ex2.png\" />\n输入： <code>orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]</code>\n输出： <code>999999984</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>根据题目的叙述中的：价格<strong>最低</strong>的销售订单和价格<strong>最高</strong>的采购订单不难想到使用大小顶堆。对于买单需要使用大订单，这样队首总是价格最高的单；对于卖单需要使用小顶堆，这样队首总是价格最低的单。</p>\n<p>对于买单和卖单地处理，其实逻辑都是一样的（如果是卖单，把买卖双方调换一下就可以了），下面以买单来举例：</p>\n<p>新来了一批买单，首先要看看卖单中价格最低的是不是比我这一批订单的预计买入价钱还要低：</p>\n<ol>\n<li>确实有价钱便宜的卖单，那么这些订单就成功成交了，成交订单的数量等于买卖双方订单数量的最小值\n<ul>\n<li>如果卖方已经卖完了，可是买方还没买完，那么买方需要继续看看还有没有其他可选择的订单了，如果有就继续成交</li>\n<li>如果买方已经买完了，可是卖方还没卖完，那么买方的工作就结束了，卖方需要继续挂单等待</li>\n</ul>\n</li>\n<li>对于买方而言如果没有可供选择的卖单了（可能是因为真的没有卖单也可能是因为价钱不合适），那么这些买单就需要挂单等待</li>\n<li>随着新订单的加入，不断重复上面的步骤，直到没有新的订单了</li>\n</ol>\n<p>如果所有订单都处理完了，剩余的买/卖单还没处理完，那么这些买单就叫做<strong>积压订单</strong>，最后需要返回这些订单的数量。</p>\n<p>{% note info flat %}\n如果对股票有一定了解，其实上面的过程跟盘口挂单是类似的，就是模拟买卖双方撮合成交的过程，在流程上可以类比一下。\n{% endnote %}</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>getNumberOfBacklogOrders</span><span>(</span><span>int</span><span>[</span><span>]</span><span>[</span><span>]</span> orders<span>)</span> <span>{</span>\n    <span>// 大顶堆</span>\n    <span>Queue</span><span>&lt;</span><span>int</span><span>[</span><span>]</span><span>></span> buy <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Comparator</span><span>.</span><span>comparingInt</span><span>(</span>o <span>-></span> <span>-</span>o<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span><span>;</span>\n    <span>// 小顶堆</span>\n    <span>Queue</span><span>&lt;</span><span>int</span><span>[</span><span>]</span><span>></span> sell <span>=</span> <span>new</span> <span>PriorityQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>Comparator</span><span>.</span><span>comparingInt</span><span>(</span>o <span>-></span> o<span>[</span><span>0</span><span>]</span><span>)</span><span>)</span><span>;</span>\n\n    <span>// 遍历所有的订单</span>\n    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> order <span>:</span> orders<span>)</span> <span>{</span>\n        <span>int</span> price <span>=</span> order<span>[</span><span>0</span><span>]</span><span>;</span>\n        <span>int</span> amount <span>=</span> order<span>[</span><span>1</span><span>]</span><span>;</span>\n        <span>int</span> orderType <span>=</span> order<span>[</span><span>2</span><span>]</span><span>;</span>\n\n        <span>// 处理买单</span>\n        <span>if</span> <span>(</span>orderType <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>// 先看看能不能撮合一部分的订单</span>\n            <span>while</span> <span>(</span>amount <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>!</span>sell<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>// 看看价格最便宜的卖单的价钱够不够便宜, 如果太贵了就不买了</span>\n                <span>int</span><span>[</span><span>]</span> sellOrder <span>=</span> sell<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>price <span>>=</span> sellOrder<span>[</span><span>0</span><span>]</span><span>)</span> <span>{</span>\n                    <span>// 如果价钱合适, 需要看看双方能成交多少</span>\n                    <span>int</span> selled <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>amount<span>,</span> sellOrder<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>\n                    <span>// 买卖双方将成交的部分减去</span>\n                    amount <span>-=</span> selled<span>;</span>\n                    sellOrder<span>[</span><span>1</span><span>]</span> <span>-=</span> selled<span>;</span>\n                    <span>// 如果成交过后, 卖方没有可卖的了, 那么把这个卖单删掉</span>\n                    <span>if</span> <span>(</span>sellOrder<span>[</span><span>1</span><span>]</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n                        sell<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n\n            <span>// 如果没有订单可以撮合或者撮合过后还有剩余订单, 那么这些买单需要挂单等待</span>\n            <span>if</span> <span>(</span>amount <span>></span> <span>0</span><span>)</span> <span>{</span>\n                buy<span>.</span><span>offer</span><span>(</span><span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>price<span>,</span> amount<span>,</span> orderType<span>}</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n        <span>// 处理卖单, 逻辑同买单</span>\n        <span>else</span> <span>{</span>\n            <span>while</span> <span>(</span>amount <span>></span> <span>0</span> <span>&amp;&amp;</span> <span>!</span>buy<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n                <span>int</span><span>[</span><span>]</span> buyOrder <span>=</span> buy<span>.</span><span>peek</span><span>(</span><span>)</span><span>;</span>\n                <span>if</span> <span>(</span>price <span>&lt;=</span> buyOrder<span>[</span><span>0</span><span>]</span><span>)</span> <span>{</span>\n                    <span>int</span> bought <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>amount<span>,</span> buyOrder<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>\n                    amount <span>-=</span> bought<span>;</span>\n                    buyOrder<span>[</span><span>1</span><span>]</span> <span>-=</span> bought<span>;</span>\n                    <span>if</span> <span>(</span>buyOrder<span>[</span><span>1</span><span>]</span> <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>\n                        buy<span>.</span><span>poll</span><span>(</span><span>)</span><span>;</span>\n                    <span>}</span>\n                <span>}</span> <span>else</span> <span>{</span>\n                    <span>break</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n            <span>if</span> <span>(</span>amount <span>></span> <span>0</span><span>)</span> <span>{</span>\n                sell<span>.</span><span>offer</span><span>(</span><span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span>price<span>,</span> amount<span>,</span> orderType<span>}</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// 订单都处理完成后, 看一下积压订单的数量</span>\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> order <span>:</span> buy<span>)</span> <span>{</span>\n        result <span>=</span> <span>(</span>result <span>+</span> order<span>[</span><span>1</span><span>]</span><span>)</span> <span>%</span> <span>10_0000_0007</span><span>;</span>\n    <span>}</span>\n    <span>for</span> <span>(</span><span>int</span><span>[</span><span>]</span> order <span>:</span> sell<span>)</span> <span>{</span>\n        result <span>=</span> <span>(</span>result <span>+</span> order<span>[</span><span>1</span><span>]</span><span>)</span> <span>%</span> <span>10_0000_0007</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br></div></div><p>{% note success flat %}\n执行用时：54 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：81.6 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1802-有界数组中指定下标处的最大值\"> <a href=\"https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/\" target=\"_blank\" rel=\"noopener noreferrer\">1802.有界数组中指定下标处的最大值</a></h2>\n<h3 id=\"题目描述-2\"> 题目描述</h3>\n<p>给你三个正整数 <code>n</code>，<code>index</code> 和 <code>maxSum</code> ，你需要构造一个同时满足下述所有条件的数组 <code>nums</code>（下标从 <code>0</code> 开始计数）：</p>\n<ul>\n<li><code>nums.length == n</code></li>\n<li><code>nums[i]</code> 是正整数，其中 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>n</span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span>abs</span></span><span>(</span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>])</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span>，其中：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span></li>\n<li><code>nums</code> 中所有元素之和不超过 <code>maxSum</code></li>\n<li><code>nums[index]</code> 的值被最大化</li>\n</ul>\n<p>返回你所构造的数组中的 <code>nums[index]</code> 。</p>\n<p>{% note warning flat %}\n注意：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span>n</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8193em;vertical-align:-0.13597em;\"></span><span>ma</span><span>x</span><span style=\"margin-right:0.05764em;\">S</span><span>u</span><span>m</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span>，$0 \\le index &lt; n $\n{% endnote %}</p>\n<h3 id=\"示例输出-2\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>n = 4, index = 2, maxSum = 6</code>\n输出： <code>2</code>\n</p>\n\n<p>输入： <code>n = 6, index = 1, maxSum = 10</code>\n输出： <code>3</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-2\"> 解题思路</h3>\n<p>由题意，最后得到的数组应该像一个山峰一样，<code>index</code> 位置是最高峰。同时由于相邻两个数的差的绝对值不超过 <code>1</code>，所以山的坡度还不能太大。</p>\n<p>不妨假设有一面墙，墙上的砖的高度初始都是1，我们需要从 <code>index</code> 位置开始不断的往上加砖，看看最高能加多少块。排除这些已经使用的砖，剩下的可用的砖的数量（<code>rest</code>）就是 <code>maxSum - n</code> 个。\n由于坡度的限制，不能只在 <code>index</code> 位置一直加砖，还需要在它两旁也码上砖。但多了两个位置加砖会导致下一次需要在 <code>5</code> 个位置上加砖（不考虑边界情况），再下次是 <code>7</code> 个位置，再再下次是...。\n这就导致我们需要维护一个区间，这个区间代表了需要加砖的所有位置，每一次的区间扩展至多是<strong>当前区间长度 + 2</strong>（因为有边界）。</p>\n<p><img src=\"https://i.loli.net/2021/03/22/GAPHifoBb1CZLm5.png\" alt=\"n=5,index=2的情况\" /></p>\n<p>因为每次扩展时在每个位置只加一块砖，所以：</p>\n<ol>\n<li>如果区间扩展前的剩余可用砖的数量大于等于扩展后的区间长度就直接在每个位置上分配一块砖，剩余数量等于 <code>rest - length</code>（<code>length</code> 代表区间长度），继续扩展区间</li>\n<li>如果砖块数量不够分了或者区间已经扩展到头了，那就没必要在扩展区间了，直接把剩余的砖块均分一下就完事了（比如下面的 <code>n=3，index=2，maxSum=18</code> 的情况中就需要把剩下的砖进行均分）</li>\n</ol>\n<p><img src=\"https://i.loli.net/2021/03/22/TGvkOp94rlBqozf.png\" alt=\"n=3,index=2,maxSum=18的情况\" /></p>\n<p>最后 <code>index</code> 位置的砖头数量就是答案。</p>\n<h3 id=\"代码实现-2\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>maxValue</span><span>(</span><span>int</span> n<span>,</span> <span>int</span> index<span>,</span> <span>int</span> maxSum<span>)</span> <span>{</span>\n    <span>int</span> left <span>=</span> index<span>;</span>\n    <span>int</span> right <span>=</span> index<span>;</span>\n    <span>int</span> result <span>=</span> <span>1</span><span>;</span>\n\n    <span>// 全部给1, 看一下剩下多少可以用来填充</span>\n    <span>int</span> rest <span>=</span> maxSum <span>-</span> n<span>;</span>\n\n    <span>// 左右边界不断扩展</span>\n    <span>while</span> <span>(</span>left <span>></span> <span>0</span> <span>||</span> right <span>&lt;</span> n <span>-</span> <span>1</span><span>)</span> <span>{</span>\n        <span>// 当前区间的长度</span>\n        <span>int</span> len <span>=</span> right <span>-</span> left <span>+</span> <span>1</span><span>;</span>\n        <span>// 对区间内的所有位置都加1</span>\n        <span>if</span> <span>(</span>rest <span>>=</span> len<span>)</span> <span>{</span>\n            rest <span>-=</span> len<span>;</span>\n            result<span>++</span><span>;</span>\n            <span>// 区间扩展</span>\n            left <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>left <span>-</span> <span>1</span><span>,</span> <span>0</span><span>)</span><span>;</span>\n            right <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>n <span>-</span> <span>1</span><span>,</span> right <span>+</span> <span>1</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>// 剩下的值均分</span>\n    result <span>+=</span> rest <span>/</span> n<span>;</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>{% note success flat %}\n执行用时：7 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：34.9 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1805-字符串中不同整数的数目\"> <a href=\"https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/\" target=\"_blank\" rel=\"noopener noreferrer\">1805.字符串中不同整数的数目</a></h2>\n<h3 id=\"题目描述-3\"> 题目描述</h3>\n<p>给你一个字符串 <code>word</code>，该字符串由数字和小写英文字母组成。</p>\n<p>请你用空格替换每个不是数字的字符。例如，<code>&quot;a123bc34d8ef34&quot;</code> 将会变成 <code>&quot; 123 34 8 34&quot;</code>。此时剩下的整数为（相邻彼此至少有一个空格隔开）：<code>123</code>、<code>34</code>、<code>8</code> 和 <code>34</code> 。</p>\n<p>返回对 <code>word</code> 完成替换后形成的<strong>不同</strong>整数的数目。</p>\n<p>{% note warning flat %}\n只有当两个整数的<strong>不含前导零</strong>的十进制表示不同时，才认为这两个整数不相同。比如：<code>001</code>，<code>01</code> 和 <code>1</code> 所代表的数字相同，都是 <code>1</code>。\n{% endnote %}</p>\n<h3 id=\"示例输出-3\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>word = &quot;a123bc34d8ef34&quot;</code>\n输出： <code>3</code>\n</p>\n\n<p>输入： <code>word = &quot;leet1234code234&quot;</code>\n输出： <code>2</code>\n</p>\n\n<p>输入： <code>word = &quot;a1b01c001&quot;</code>\n输出： <code>1</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-3\"> 解题思路</h3>\n<ol>\n<li>可以使用正则表达式分开字符串中的数字</li>\n<li>因为要统计不同数字的个数，所以可以使用 <code>HashSet</code> ，其大小就是最后的结果</li>\n<li>前导 <code>0</code> 可以通过字符串截取来消除</li>\n</ol>\n<p>{% note warning flat %}\n题目没有限制数字长度（真的有 <code>&quot;035985750011523523129774573439111590559325&quot;</code> 这种用例），所以不能直接使用 <code>int</code> 或 <code>long</code>。\n{% endnote %}</p>\n<h3 id=\"代码实现-3\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>numDifferentIntegers</span><span>(</span><span>String</span> word<span>)</span> <span>{</span>\n    <span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> set <span>=</span> <span>new</span> <span>HashSet</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n\n    <span>for</span> <span>(</span><span>String</span> num <span>:</span> word<span>.</span><span>split</span><span>(</span><span>\"[a-z]+\"</span><span>)</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>\"\"</span><span>.</span><span>equals</span><span>(</span>num<span>)</span><span>)</span> <span>{</span>\n            <span>continue</span><span>;</span>\n        <span>}</span>\n        <span>int</span> i <span>=</span> <span>0</span><span>;</span>\n        <span>while</span> <span>(</span>i <span>&lt;</span> num<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span> <span>&amp;&amp;</span> num<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> <span>'0'</span><span>)</span> <span>{</span>\n            i<span>++</span><span>;</span>\n        <span>}</span>\n        set<span>.</span><span>add</span><span>(</span>num<span>.</span><span>substring</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> set<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>{% note success flat %}\n执行用时：7 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：36.6 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1806-还原排列的最少操作步数\"> <a href=\"https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/\" target=\"_blank\" rel=\"noopener noreferrer\">1806.还原排列的最少操作步数</a></h2>\n<h3 id=\"题目描述-4\"> 题目描述</h3>\n<p>给你一个偶数 <code>n</code> ，已知存在一个长度为 <code>n</code> 的排列 <code>perm</code> ，其中 <code>perm[i] == i</code>（下标从 <code>0</code> 开始计数）。</p>\n<p>在一步操作中，你将创建一个新数组 <code>arr</code> ，对于每个 <code>i</code> ：</p>\n<p>如果 <code>i % 2 == 0</code> ，那么 <code>arr[i] = perm[i / 2]</code>\n如果 <code>i % 2 == 1</code> ，那么 <code>arr[i] = perm[n / 2 + (i - 1) / 2]</code>\n然后将 <code>arr</code> 赋值给 <code>perm</code> 。</p>\n<p>要想使 <code>perm</code> 回到排列初始值，至少需要执行多少次操作？ 返回最小的非零操作步数。</p>\n<p>{% note info flat %}\n<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span>2</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.5782em;vertical-align:-0.0391em;\"></span><span>n</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1000</span></span></span></span>， <code>n</code> 是一个偶数\n{% endnote %}</p>\n<h3 id=\"示例输出-4\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>n = 2</code>\n输出： <code>1</code>\n</p>\n\n<p>输入： <code>n = 4</code>\n输出： <code>2</code>\n</p>\n\n<p>输入： <code>n = 6</code>\n输出： <code>4</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-4\"> 解题思路</h3>\n<p>{% tabs solution %}\n\n如果不能一下发现其中的数学规律，那么直接模拟就是最好的思路。没啥说的，按照题意直接写代码就完事了。\n</p>\n\n<p>{% note info flat %}\n参考<a href=\"https://leetcode-cn.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/shu-xue-on-suan-fa-by-arsenal-591-xatz/\" target=\"_blank\" rel=\"noopener noreferrer\">数学 O(n) 算法</a>题解进行整理\n{% endnote %}</p>\n<p>将 <code>n = 2, 4, 6</code> 情况中的数组交换情况列举一下：</p>\n<p>{% tabs 数学推导-举例 %}\n</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">索引</th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">交换位置的索引</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n</tbody>\n</table>\n\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">索引</th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">交换位置的索引</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第1次操作</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第2次操作</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n</tbody>\n</table>\n\n\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">索引</th>\n<th style=\"text-align:center\">0</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">交换位置的索引</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第1次操作</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第2次操作</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第3次操作</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">第4次操作</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n</tbody>\n</table>\n\n<p>{% endtabs %}</p>\n<p>可以发现，对数组中的每个元素 <code>i</code>，假设使用 <code>f(i)</code> 来表示一次操作后的下标变换，那么（不需要考虑数组中索引为 <code>0</code> 和 <code>n - 1</code> 的位置，可以看到这两个位置的数是不会调换的）：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:4.552em;vertical-align:-2.026em;\"></span><span><span><span><span><span><span style=\"height:2.3500199999999998em;\"><span style=\"top:-2.19999em;\"><span style=\"height:3.15em;\"></span><span><span>⎩</span></span></span><span style=\"top:-2.19199em;\"><span style=\"height:3.15em;\"></span><span style=\"height:0.31599999999999984em;width:0.889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.889em' height='0.31599999999999984em' style='width:0.889em' viewBox='0 0 889 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style=\"top:-3.15001em;\"><span style=\"height:3.15em;\"></span><span><span>⎨</span></span></span><span style=\"top:-4.292009999999999em;\"><span style=\"height:3.15em;\"></span><span style=\"height:0.31599999999999984em;width:0.889em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='0.889em' height='0.31599999999999984em' style='width:0.889em' viewBox='0 0 889 316' preserveAspectRatio='xMinYMin'><path d='M384 0 H504 V316 H384z M384 0 H504 V316 H384z'/></svg></span></span><span style=\"top:-4.600019999999999em;\"><span style=\"height:3.15em;\"></span><span><span>⎧</span></span></span></span><span>​</span></span><span><span style=\"height:1.8500199999999998em;\"><span></span></span></span></span></span></span><span><span><span><span><span><span style=\"height:2.526em;\"><span style=\"top:-4.526em;\"><span style=\"height:3.59em;\"></span><span><span>2</span><span>i</span><span>,</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.59em;\"></span><span><span>2</span><span>i</span><span>−</span><span>(</span><span>n</span><span>−1</span><span>)</span><span>,</span></span></span></span><span>​</span></span><span><span style=\"height:2.026em;\"><span></span></span></span></span></span><span style=\"width:1em;\"></span><span><span><span><span style=\"height:2.526em;\"><span style=\"top:-4.526em;\"><span style=\"height:3.59em;\"></span><span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span></span><span><span><span><span style=\"height:1.5899999999999999em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span>2</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.74em;\"><span style=\"height:3em;\"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.59em;\"></span><span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≥</span><span style=\"margin-right:0.2777777777777778em;\"></span><span><span></span><span><span><span><span style=\"height:1.5899999999999999em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span>2</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.74em;\"><span style=\"height:3em;\"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span></span></span></span><span>​</span></span><span><span style=\"height:2.026em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n<p>即：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>2</span><span>i</span><span></span><span style=\"margin-right:0.6666666666666666em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>（<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>∈</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>[</span><span>1</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>）。</p>\n<p>假设：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span></span></span></span> 表示第 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span style=\"margin-right:0.03148em;\">k</span></span></span></span> 次操作后元素 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span></span></span></span> 的下标，那么： <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span>i</span><span>))</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>3</span></span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span style=\"margin-right:0.10764em;\">f</span><span>(</span><span>i</span><span>)))</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>…</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.849108em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>i</span><span></span><span style=\"margin-right:0.6666666666666666em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>。</p>\n<p>为了使所有元素都回到对应的位置上，需要有：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.849108em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span><span></span><span style=\"margin-right:0.6666666666666666em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>（<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>∈</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>[</span><span>1</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>）。</p>\n<p>当 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span> 时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>(</span><span>1</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.849108em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span><span></span><span style=\"margin-right:0.6666666666666666em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span>，如果存在 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span style=\"margin-right:0.03148em;\">k</span></span></span></span> 使得该式子恒成立，那么在同乘 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span></span></span></span> 后的式子 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span><span style=\"margin-right:0.10764em;\">f</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span>(</span><span>i</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.65952em;vertical-align:0em;\"></span><span>i</span><span></span><span style=\"margin-right:0.6666666666666666em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span> 也是恒成立的。因此问题最终可以简化为：找到一个最小的 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span style=\"margin-right:0.03148em;\">k</span></span></span></span>，使 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.849108em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span><span></span><span style=\"margin-right:0.6666666666666666em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span> 恒成立。</p>\n<p>根据<a href=\"https://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)\" target=\"_blank\" rel=\"noopener noreferrer\">欧拉定理</a>：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.938em;vertical-align:0em;\"></span><span><span style=\"margin-right:0.0037em;\">α</span><span><span><span><span style=\"height:0.938em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>(</span><span>φ</span><span>(</span><span>n</span><span>))</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≡</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span><span></span><span style=\"margin-right:1em;\"></span></span><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span><span><span>mod</span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.16666666666666666em;\"></span><span>n</span></span></span></span></span></p>\n<p>由于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span> 是奇数，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2</span></span></span></span> 是偶数，所以 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>φ</span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span></span></span></span> 一定是解，并且总时间复杂度 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.36687em;vertical-align:0em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>1</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>)</span></span></span></span>。</p>\n\n<p>{% endtabs %}</p>\n<h3 id=\"代码实现-4\"> 代码实现</h3>\n<p>{% tabs code %}\n</p>\n<div><pre><code><span>public</span> <span>int</span> <span>reinitializePermutation</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>// 初始化perm数组</span>\n    <span>int</span><span>[</span><span>]</span> perm <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        perm<span>[</span>i<span>]</span> <span>=</span> i<span>;</span>\n    <span>}</span>\n\n    <span>// 最终结果</span>\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n\n    <span>while</span> <span>(</span><span>true</span><span>)</span> <span>{</span>\n        <span>// 每次都新创建一个arr数组</span>\n        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>\n\n        <span>// 标志操作是否结束</span>\n        <span>boolean</span> flag <span>=</span> <span>true</span><span>;</span>\n\n        <span>// 对arr数组赋值</span>\n        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n            <span>if</span> <span>(</span><span>(</span>i <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>\n                arr<span>[</span>i<span>]</span> <span>=</span> perm<span>[</span>i <span>/</span> <span>2</span><span>]</span><span>;</span>\n            <span>}</span> <span>else</span> <span>{</span>\n                arr<span>[</span>i<span>]</span> <span>=</span> perm<span>[</span>n <span>/</span> <span>2</span> <span>+</span> <span>(</span>i <span>-</span> <span>1</span><span>)</span> <span>/</span> <span>2</span><span>]</span><span>;</span>\n            <span>}</span>\n            <span>// 如果存在与原数据不一样的数据就继续操作, 否则则终止操作</span>\n            <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>!=</span> i<span>)</span> <span>{</span>\n                flag <span>=</span> <span>false</span><span>;</span>\n            <span>}</span>\n        <span>}</span>\n\n        <span>// 统计操作次数</span>\n        result<span>++</span><span>;</span>\n        <span>// 更新perm数组</span>\n        perm <span>=</span> arr<span>;</span>\n\n        <span>// 如果操作结束就退出</span>\n        <span>if</span> <span>(</span>flag<span>)</span> <span>{</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>{% note success flat %}\n执行用时：29 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：37.9 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}\n</p>\n\n<div><pre><code><span>public</span> <span>int</span> <span>reinitializePermutation</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>n <span>==</span> <span>2</span><span>)</span> <span>{</span>\n        <span>return</span> <span>1</span><span>;</span>\n    <span>}</span>\n\n    <span>int</span> result <span>=</span> <span>2</span><span>;</span>\n    <span>int</span> count <span>=</span> <span>1</span><span>;</span>\n\n    <span>while</span> <span>(</span>result <span>!=</span> <span>1</span><span>)</span> <span>{</span>\n        count<span>++</span><span>;</span>\n        result <span>=</span> result <span>*</span> <span>2</span> <span>%</span> <span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> count<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：35.5 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}\n\n{% endtabs %}</p>\n<hr>\n<h2 id=\"_1807-替换字符串中的括号内容\"> <a href=\"https://leetcode-cn.com/problems/evaluate-the-bracket-pairs-of-a-string/\" target=\"_blank\" rel=\"noopener noreferrer\">1807.替换字符串中的括号内容</a></h2>\n<h3 id=\"题目描述-5\"> 题目描述</h3>\n<p>给你一个字符串 <code>s</code>，它包含一些括号对，每个括号中包含一个非空的键。</p>\n<p>比如在字符串 <code>&quot;(name)is(age)yearsold&quot;</code> 中，有两个括号对，分别包含键 <code>&quot;name&quot;</code> 和 <code>&quot;age&quot;</code>。\n你知道许多键对应的值，这些关系由二维字符串数组 <code>knowledge</code> 表示，其中 <code>knowledge[i] = [key_i, value_i]</code>，表示键 <code>key_i</code> 对应的值为 <code>value_i</code>。</p>\n<p>你需要替换<strong>所有的括号对</strong>。当你替换一个括号对，且它包含的键为 <code>key_i</code> 时，你需要将 <code>key_i</code> 和括号用对应的值 <code>value_i</code> 替换。</p>\n<p>如果从 <code>knowledge</code> 中无法得知某个键对应的值，你需要将 <code>key_i</code> 和括号用问号 <code>&quot;?&quot;</code> 替换（不需要引号）。</p>\n<p>请你返回替换<strong>所有括号对</strong>后的结果字符串。</p>\n<p>{% note info flat %}\n<code>knowledge</code> 中每个键最多只会出现一次，<code>s</code> 中不会有嵌套的括号。\n{% endnote %}</p>\n<p>{% note warning flat %}</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>kn</span><span>o</span><span style=\"margin-right:0.01968em;\">wl</span><span>e</span><span>d</span><span style=\"margin-right:0.03588em;\">g</span><span>e</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><code>knowledge[i].length == 2</code></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span>e</span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.03588em;\">v</span><span>a</span><span style=\"margin-right:0.01968em;\">l</span><span>u</span><span><span>e</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>&lt;=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>10</span></span></span></span></li>\n<li><code>s</code> 只包含小写英文字母和圆括号 <code>'('</code> 和 <code>')'</code></li>\n<li><code>s</code> 中每一个左圆括号 <code>'('</code> 都有对应的右圆括号 <code>')'</code></li>\n<li><code>s</code> 中每对括号内的键都不会为空</li>\n<li><code>s</code> 中不会有嵌套括号对</li>\n<li><code>key_i</code> 和 <code>value_i</code> 只包含小写英文字母</li>\n<li><code>knowledge</code> 中的 <code>key_i</code> 不会重复\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-5\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>s = &quot;(name)is(age)yearsold&quot;, knowledge = [[&quot;name&quot;, &quot;bob&quot;], [&quot;age&quot;, &quot;two&quot;]]</code>\n输出： <code>&quot;bobistwoyearsold&quot;</code>\n</p>\n\n<p>输入： <code>s = &quot;hi(name)&quot;, knowledge = [[&quot;a&quot;, &quot;b&quot;]]</code>\n输出： <code>&quot;hi?&quot;</code>\n</p>\n\n<p>输入： <code>s = &quot;(a)(a)(a)aaa&quot;, knowledge = [[&quot;a&quot;, &quot;yes&quot;]]</code>\n输出： <code>&quot;yesyesyesaaa&quot;</code>\n</p>\n\n<p>输入： <code>s = &quot;(a)(b)&quot;, knowledge = [[&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;a&quot;]]</code>\n输出： <code>&quot;ba&quot;</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-5\"> 解题思路</h3>\n<p>没啥说的，先将键值保存到 <code>HashMap</code> 中，再逐个替换键。</p>\n<h3 id=\"代码实现-5\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>String</span> <span>evaluate</span><span>(</span><span>String</span> s<span>,</span> <span>List</span><span><span>&lt;</span><span>List</span><span>&lt;</span><span>String</span><span>></span><span>></span></span> knowledge<span>)</span> <span>{</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list <span>:</span> knowledge<span>)</span> <span>{</span>\n        map<span>.</span><span>put</span><span>(</span>list<span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>,</span> list<span>.</span><span>get</span><span>(</span><span>1</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>StringBuilder</span> stringBuilder <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>;</span>\n    <span>boolean</span> flag <span>=</span> <span>true</span><span>;</span>\n    <span>int</span> left <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>char</span> c <span>=</span> s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>\n        <span>if</span> <span>(</span>c <span>==</span> <span>'('</span><span>)</span> <span>{</span>\n            flag <span>=</span> <span>false</span><span>;</span>\n            left <span>=</span> i<span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>c <span>==</span> <span>')'</span><span>)</span> <span>{</span>\n            flag <span>=</span> <span>true</span><span>;</span>\n            stringBuilder<span>.</span><span>append</span><span>(</span>map<span>.</span><span>getOrDefault</span><span>(</span>s<span>.</span><span>substring</span><span>(</span>left <span>+</span> <span>1</span><span>,</span> i<span>)</span><span>,</span> <span>\"?\"</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>else</span> <span>if</span> <span>(</span>flag<span>)</span> <span>{</span>\n            stringBuilder<span>.</span><span>append</span><span>(</span>c<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> stringBuilder<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>{% note success flat %}\n执行用时：50 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：77.6 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1808-好因子的最大数目\"> <a href=\"https://leetcode-cn.com/problems/maximize-number-of-nice-divisors/\" target=\"_blank\" rel=\"noopener noreferrer\">1808.好因子的最大数目</a></h2>\n<h3 id=\"题目描述-6\"> 题目描述</h3>\n<p>给你一个正整数 <code>primeFactors</code> 。你需要构造一个正整数 <code>n</code>，它满足以下条件：</p>\n<ol>\n<li><code>n</code> 质因数（质因数需要考虑重复的情况）的数目不超过 <code>primeFactors</code> 个</li>\n<li><code>n</code> 好因子的数目最大化： 如果 <code>n</code> 的一个因子可以被 <code>n</code> 的每一个质因数整除，我们称这个因子是<strong>好因子</strong>。比方说，如果 <code>n = 12</code>，那么它的质因数为 <code>[2,2,3]</code>，那么 <code>6</code> 和 <code>12</code> 是好因子，但 <code>3</code> 和 <code>4</code> 不是。</li>\n</ol>\n<p>请你返回 <code>n</code> 的好因子的最大数目。由于答案可能会很大，请返回答案对 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>7</span></span></span></span> 取余的结果。</p>\n<p>{% note info flat %}\n请注意，质数的定义是大于 <code>1</code>，且不能被分解为两个小于该数的自然数相乘的数。一个数 <code>n</code> 的质因子是将 <code>n</code> 分解为若干个质因子，且它们的乘积为 <code>n</code>。\n{% endnote %}</p>\n<p>{% note warning flat %}\n<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span>p</span><span style=\"margin-right:0.02778em;\">r</span><span>im</span><span>e</span><span style=\"margin-right:0.13889em;\">F</span><span>a</span><span>c</span><span>t</span><span>ors</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span>\n{% endnote %}</p>\n<h3 id=\"示例输出-6\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>primeFactors = 5</code>\n输出： <code>6</code>\n</p>\n\n<p>输入： <code>primeFactors = 8</code>\n输出： <code>18</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-6\"> 解题思路</h3>\n<p>{% note info flat %}\n纯数学题，本题和<a href=\"https://leetcode-cn.com/problems/integer-break/\" target=\"_blank\" rel=\"noopener noreferrer\">343. 整数拆分</a>的数学逻辑是相同的。\n代码实现中幂运算的部分参考<a href=\"https://leetcode-cn.com/problems/powx-n/\" target=\"_blank\" rel=\"noopener noreferrer\">50. Pow(x, n)</a>。\n{% endnote %}</p>\n<p>假设对于某正整数 <code>n</code>，其质因子为：<code>b1</code>，<code>b2</code>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.12em;vertical-align:0em;\"></span><span>…</span></span></span></span>，<code>bm</code>。每个质因子的个数为：<code>a1</code>，<code>a2</code>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.12em;vertical-align:0em;\"></span><span>…</span></span></span></span>，<code>am</code>个。那么最终的好因子的个数等于：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span>⋯</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>m</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>。根据题意这个值的最大值就是最终的答案，与这个正整数的值，其因子的值实际上是无关的。</p>\n<p>由算术-几何平均不等式：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.9463300000000001em;vertical-align:-0.686em;\"></span><span><span></span><span><span><span><span style=\"height:1.2603300000000002em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span>n</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span><span>x</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>⋯</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≥</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1.04em;vertical-align:-0.23833499999999996em;\"></span><span><span><span><span><span style=\"height:0.553278em;\"><span style=\"top:-2.8379980000000002em;\"><span style=\"height:2.5em;\"></span><span><span><span>n</span></span></span></span></span></span></span></span><span><span><span style=\"height:0.8016650000000001em;\"><span style=\"top:-3em;\"><span style=\"height:3em;\"></span><span style=\"padding-left:0.833em;\"><span><span>x</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>⋯</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-2.761665em;\"><span style=\"height:3em;\"></span><span style=\"min-width:0.853em;height:1.08em;\"><svg xmlns=\"http://www.w3.org/2000/svg\" width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span>​</span></span><span><span style=\"height:0.23833499999999996em;\"><span></span></span></span></span></span></span></span></span>（当且仅当每个值都相等时等号成立），可得：当且仅当<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.36687em;vertical-align:0em;\"></span><span>⋯</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>时，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.73333em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span>⋯</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.58056em;vertical-align:-0.15em;\"></span><span><span>a</span><span><span><span><span style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>m</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 取得最大值。</p>\n<p>假设将数字 <code>n</code> 以因子 <code>x</code> 等分为 <code>a</code> 份，那么 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>n</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>a</span><span>x</span></span></span></span>，其乘积为：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>a</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1.258312em;vertical-align:-0.25em;\"></span><span><span><span>(</span><span><span>x</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>x</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span><span>)</span></span><span><span><span><span style=\"height:1.008312em;\"><span style=\"top:-3.4069200000000004em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>，得到 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.9540200000000001em;vertical-align:0em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>x</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span> 需要取到最大值。</p>\n<p>令：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.9540200000000001em;vertical-align:0em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>x</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span>，对 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03588em;\">y</span></span></span></span> 两边同时取对数并求导得到：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.946332em;vertical-align:-0.19444em;\"></span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.751892em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:2.05744em;vertical-align:-0.686em;\"></span><span><span></span><span><span><span><span style=\"height:1.37144em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span><span>x</span><span><span><span><span style=\"height:0.740108em;\"><span style=\"top:-2.9890000000000003em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>1</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>ln</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>x</span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span><span><span>x</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>x</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span>。</p>\n<p>令 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>0</span></span></span></span>，得到：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span>1</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.69444em;vertical-align:0em;\"></span><span>ln</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>x</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>0</span></span></span></span>，所以<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>x</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>e</span></span></span></span>。由于：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:3.0000299999999998em;vertical-align:-1.25003em;\"></span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>′</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span><span style=\"top:0em;\"><span>{</span></span><span><span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span>&gt;</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0</span><span>,</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span>&lt;</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0</span><span>,</span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span><span style=\"width:1em;\"></span><span><span><span><span style=\"height:1.69em;\"><span style=\"top:-3.69em;\"><span style=\"height:3.008em;\"></span><span><span>x</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>∈</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>[</span><span>−</span><span>∞</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>e</span><span>)</span></span></span><span style=\"top:-2.25em;\"><span style=\"height:3.008em;\"></span><span><span>x</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>∈</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>(</span><span>e</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>∞</span><span>]</span></span></span></span><span>​</span></span><span><span style=\"height:1.19em;\"><span></span></span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n<p>所以 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>x</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>e</span></span></span></span> 是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.9540200000000001em;vertical-align:0em;\"></span><span><span>x</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>x</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span></span></span></span> 的极大值点。</p>\n<p>但题目中需要取整数，与 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>e</span></span></span></span> 临近的整数是 <code>3</code> 和 <code>4</code>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span>(</span><span>3</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.9540200000000001em;vertical-align:0em;\"></span><span><span>3</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>3</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≈</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1.44</span></span></span></span>，<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.03588em;\">y</span><span>(</span><span>4</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.9540200000000001em;vertical-align:0em;\"></span><span><span>4</span><span><span><span><span style=\"height:0.9540200000000001em;\"><span style=\"top:-3.363em;margin-right:0.05em;\"><span style=\"height:3em;\"></span><span><span><span><span></span><span><span><span><span style=\"height:0.8443142857142858em;\"><span style=\"top:-2.656em;\"><span style=\"height:3em;\"></span><span><span><span>4</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.344em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≈</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1.41</span></span></span></span>。因此在三等分时会使最后的结果达到最大值。</p>\n<p>考虑有余数的情况：</p>\n<ol>\n<li>余数 <code>2</code>：保留余数就好了，最后的结果是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.747722em;vertical-align:-0.08333em;\"></span><span><span>3</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>a</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2</span></span></span></span></li>\n<li>余数 <code>1</code>：需要拆出一个 <code>3</code>，构成 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span>2</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2</span></span></span></span>，最后的结果是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>3</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>a</span><span>−</span><span>1</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>4</span></span></span></span></li>\n</ol>\n<h3 id=\"代码实现-6\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>maxNiceDivisors</span><span>(</span><span>int</span> primeFactors<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>primeFactors <span>&lt;=</span> <span>3</span><span>)</span> <span>{</span>\n        <span>return</span> primeFactors<span>;</span>\n    <span>}</span>\n\n    <span>long</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>int</span> a <span>=</span> primeFactors <span>/</span> <span>3</span><span>;</span>\n    <span>int</span> b <span>=</span> primeFactors <span>%</span> <span>3</span><span>;</span>\n\n    <span>// 整除的情况</span>\n    <span>if</span> <span>(</span>b <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        result <span>=</span> <span>quickPow</span><span>(</span><span>3</span><span>,</span> a<span>)</span><span>;</span>\n    <span>}</span>\n    <span>// 余数1的情况</span>\n    <span>else</span> <span>if</span> <span>(</span>b <span>==</span> <span>1</span><span>)</span> <span>{</span>\n        result <span>=</span> <span>quickPow</span><span>(</span><span>3</span><span>,</span> a <span>-</span> <span>1</span><span>)</span> <span>*</span> <span>4</span><span>;</span>\n    <span>}</span>\n    <span>// 余数2的情况</span>\n    <span>else</span> <span>{</span>\n        result <span>=</span> <span>quickPow</span><span>(</span><span>3</span><span>,</span> a<span>)</span> <span>*</span> <span>2</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>(</span><span>int</span><span>)</span> <span>(</span>result <span>%</span> <span>1000000007</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>long</span> <span>quickPow</span><span>(</span><span>int</span> x<span>,</span> <span>int</span> n<span>)</span> <span>{</span>\n    <span>int</span> mod <span>=</span> <span>1000000007</span><span>;</span>\n    <span>long</span> result <span>=</span> <span>1</span><span>;</span>\n    <span>long</span> base <span>=</span> x<span>;</span>\n    <span>while</span> <span>(</span>n <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span><span>(</span>n <span>&amp;</span> <span>1</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n            result <span>=</span> result <span>*</span> base <span>%</span> mod<span>;</span>\n        <span>}</span>\n        base <span>=</span> base <span>*</span> base <span>%</span> mod<span>;</span>\n        n <span>>>=</span> <span>1</span><span>;</span>\n    <span>}</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：35.3 MB, 在所有 Java 提交中击败了100.00%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1812-判断国际象棋棋盘中一个格子的颜色\"> <a href=\"https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square/\" target=\"_blank\" rel=\"noopener noreferrer\">1812.判断国际象棋棋盘中一个格子的颜色</a></h2>\n<h3 id=\"题目描述-7\"> 题目描述</h3>\n<p>给你一个坐标 <code>coordinates</code>，它是一个字符串，表示国际象棋棋盘中一个格子的坐标，下图是国际象棋棋盘示意图。</p>\n<p><img src=\"https://i.loli.net/2021/04/06/cePQwvorX7C8EyJ.png\" alt=\"chessboard.png\" /></p>\n<p>如果所给格子的颜色是白色，请返回 <code>true</code>，否则需要返回 <code>false</code>。</p>\n<p>给定的坐标一定代表国际象棋棋盘上一个存在的格子，坐标第一个字符是字母，第二个字符是数字。</p>\n<p>{% note info flat %}</p>\n<ul>\n<li><code>coordinates.length == 2</code></li>\n<li><code>'a' &lt;= coordinates[0] &lt;= 'h'</code></li>\n<li><code>'1' &lt;= coordinates[1] &lt;= '8'</code>\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-7\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>coordinates = &quot;a1&quot;</code>\n输出： <code>false</code>\n</p>\n\n<p>输入： <code>coordinates = &quot;h3&quot;</code>\n输出： <code>true</code>\n</p>\n\n<p>输入： <code>coordinates = &quot;c7&quot;</code>\n输出： <code>false</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-7\"> 解题思路</h3>\n<p>棋盘的横轴是字母，可以将它转换为对应的 ASCII 码。这样 <code>a</code> 将会对应数字 <code>0</code>，<code>b</code> 对应数字 <code>1</code>，…… ，字母 <code>h</code> 代表数字 <code>7</code>。这样当横轴与纵轴坐标奇偶性相同时，对应的格子就是白色，否则是黑色。</p>\n<p>{% note info flat %}\n可以使用位运算来判断奇偶性\n{% endnote %}</p>\n<h3 id=\"代码实现-7\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>boolean</span> <span>squareIsWhite</span><span>(</span><span>String</span> coordinates<span>)</span> <span>{</span>\n    <span>int</span> x <span>=</span> coordinates<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>-</span> <span>'a'</span><span>;</span>\n    <span>int</span> y <span>=</span> coordinates<span>.</span><span>charAt</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>return</span> <span>(</span><span>(</span>x <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>(</span>y <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>1</span><span>)</span> <span>||</span> <span>(</span><span>(</span>x <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> <span>&amp;&amp;</span> <span>(</span>y <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：36.3 MB, 在所有 Java 提交中击败了98.32%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1813-句子相似性-iii\"> <a href=\"https://leetcode-cn.com/problems/sentence-similarity-iii/\" target=\"_blank\" rel=\"noopener noreferrer\">1813.句子相似性 III</a></h2>\n<h3 id=\"题目描述-8\"> 题目描述</h3>\n<p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>&quot;Hello World&quot;</code>，<code>&quot;HELLO&quot;</code>，<code>&quot;hello world hello world&quot;</code> 都是句子。每个单词都 只包含<strong>大写和小写英文字母</strong>。</p>\n<p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code>，可以通过往其中一个句子插入一个任意的句子（可以是空句子）而得到另一个句子，那么我们称这两个句子是相似的。比方说，<code>sentence1 = &quot;Hello my name is Jane&quot;</code>，<code>sentence2 = &quot;Hello Jane&quot;</code>，我们可以往 <code>sentence2</code> 中的 <code>&quot;Hello&quot;</code> 和 <code>&quot;Jane&quot;</code> 之间插入 <code>&quot;my name is&quot;</code> 得到 <code>sentence1</code>。</p>\n<p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code>，如果 <code>sentence1</code> 和 <code>sentence2</code> 是相似的，请返回 <code>true</code>，否则返回 <code>false</code>。</p>\n<p>{% note info flat %}</p>\n<ul>\n<li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li>\n<li><code>sentence1</code> 和 <code>sentence2</code> 都只包含大小写英文字母和空格</li>\n<li><code>sentence1</code> 和 <code>sentence2</code> 中的单词都只由单个空格隔开\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-8\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>sentence1 = &quot;My name is Haley&quot;, sentence2 = &quot;My Haley&quot;</code>\n输出： <code>true</code>\n</p>\n\n<p>输入： <code>sentence1 = &quot;of&quot;, sentence2 = &quot;A lot of words&quot;</code>\n输出： <code>false</code>\n</p>\n\n<p>输入： <code>sentence1 = &quot;Eating right now&quot;, sentence2 = &quot;Eating&quot;</code>\n输出： <code>true</code>\n</p>\n\n<p>输入： <code>sentence1 = &quot;Luky&quot;, sentence2 = &quot;Lucccky&quot;</code>\n输出： <code>false</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-8\"> 解题思路</h3>\n<p>从左右两边同时查找首个单词不一样的位置，如果相同的单词个数与两字符串中单词数量较小的那一个的单词个数相同就代表是相似的。</p>\n<h3 id=\"代码实现-8\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>boolean</span> <span>areSentencesSimilar</span><span>(</span><span>String</span> sentence1<span>,</span> <span>String</span> sentence2<span>)</span> <span>{</span>\n    <span>String</span><span>[</span><span>]</span> partsOfOne <span>=</span> sentence1<span>.</span><span>split</span><span>(</span><span>\" \"</span><span>)</span><span>;</span>\n    <span>String</span><span>[</span><span>]</span> partsOfTwo <span>=</span> sentence2<span>.</span><span>split</span><span>(</span><span>\" \"</span><span>)</span><span>;</span>\n\n    <span>int</span> length1 <span>=</span> partsOfOne<span>.</span>length<span>;</span>\n    <span>int</span> length2 <span>=</span> partsOfTwo<span>.</span>length<span>;</span>\n\n    <span>int</span> left <span>=</span> <span>0</span><span>;</span>\n    <span>int</span> right <span>=</span> <span>0</span><span>;</span>\n\n    <span>// 从左边遍历, 找到首个单词不同的位置</span>\n    <span>while</span> <span>(</span>left <span>&lt;</span> length1 <span>&amp;&amp;</span> left <span>&lt;</span> length2<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>partsOfOne<span>[</span>left<span>]</span><span>.</span><span>equals</span><span>(</span>partsOfTwo<span>[</span>left<span>]</span><span>)</span><span>)</span> <span>{</span>\n            left<span>++</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// 如果左侧直接就把数组遍历完了, 直接返回</span>\n    <span>if</span> <span>(</span>left <span>==</span> length1 <span>&amp;&amp;</span> left <span>==</span> length2<span>)</span> <span>{</span>\n        <span>return</span> <span>true</span><span>;</span>\n    <span>}</span>\n\n    <span>// 从右边遍历, 找到首个单词不同的位置</span>\n    <span>while</span> <span>(</span>right <span>&lt;</span> length1 <span>&amp;&amp;</span> right <span>&lt;</span> length2<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>partsOfOne<span>[</span>length1 <span>-</span> right <span>-</span> <span>1</span><span>]</span><span>.</span><span>equals</span><span>(</span>partsOfTwo<span>[</span>length2 <span>-</span> right <span>-</span> <span>1</span><span>]</span><span>)</span><span>)</span> <span>{</span>\n            right<span>++</span><span>;</span>\n        <span>}</span> <span>else</span> <span>{</span>\n            <span>break</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>// 判断长度与字符串长度是否一致</span>\n    <span>return</span> <span>(</span>right <span>+</span> left<span>)</span> <span>==</span> <span>Math</span><span>.</span><span>min</span><span>(</span>length1<span>,</span> length2<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>{% note success flat %}\n执行用时：1 ms, 在所有 Java 提交中击败了95.97%的用户\n内存消耗：36.9 MB, 在所有 Java 提交中击败了23.83%的用户\n{% endnote %}</p>\n<hr>\n<h2 id=\"_1814-统计一个数组中好对子的数目\"> <a href=\"https://leetcode-cn.com/problems/count-nice-pairs-in-an-array/\" target=\"_blank\" rel=\"noopener noreferrer\">1814.统计一个数组中好对子的数目</a></h2>\n<h3 id=\"题目描述-9\"> 题目描述</h3>\n<p>给你一个数组 <code>nums</code>，数组中只包含非负整数。定义 <code>rev(x)</code> 的值为将整数 <code>x</code> 各个数字位反转得到的结果。比方说 <code>rev(123) = 321</code>，<code>rev(120) = 21</code>。我们称满足下面条件的下标对 <code>(i, j)</code> 是<strong>好的</strong>：</p>\n<ul>\n<li><code>0 &lt;= i &lt; j &lt; nums.length</code></li>\n<li><code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code></li>\n</ul>\n<p>请你返回好下标对的数目。由于结果可能会很大，请将结果对 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>7</span></span></span></span> 取余后返回。</p>\n<p>{% note info flat %}</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>5</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>0</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>9</span></span></span></span></span></span></span></span></span></span></span>\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出-9\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入： <code>nums = [42, 11, 1, 97]</code>\n输出： <code>2</code>\n</p>\n\n<p>输入： <code>nums = [13, 10, 35, 24, 76]</code>\n输出： <code>4</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路-9\"> 解题思路</h3>\n<p>暴力破解的时间复杂度是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span><span>n</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>2</span></span></span></span></span></span></span></span><span>)</span></span></span></span> 会超时，需要进行简化。</p>\n<p>考虑题目中的这个条件： <code>nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])</code> ，将它重新整理一下，可以得到：<code>nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])</code>。</p>\n<p>因此只要出现重复的 <code>nums[i] - rev(nums[i])</code> ，它们两两之间就可以进行配对，所以只做一次遍历就可以了。</p>\n<h3 id=\"代码实现-9\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> <span>countNicePairs</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>Map</span><span><span>&lt;</span><span>Integer</span><span>,</span> <span>Integer</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>long</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>:</span> nums<span>)</span> <span>{</span>\n        <span>int</span> num <span>=</span> i <span>-</span> <span>reverse</span><span>(</span>i<span>)</span><span>;</span>\n        result <span>+=</span> map<span>.</span><span>getOrDefault</span><span>(</span>num<span>,</span> <span>0</span><span>)</span><span>;</span>\n        map<span>.</span><span>put</span><span>(</span>num<span>,</span> map<span>.</span><span>getOrDefault</span><span>(</span>num<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>\n    <span>}</span>\n   <span>return</span> <span>(</span><span>int</span><span>)</span> <span>(</span>result <span>%</span> <span>1000000007</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>int</span> <span>reverse</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>\n    <span>int</span> res <span>=</span> <span>0</span><span>;</span>\n    <span>while</span> <span>(</span>num <span>!=</span> <span>0</span><span>)</span> <span>{</span>\n        <span>int</span> t <span>=</span> num <span>%</span> <span>10</span><span>;</span>\n        res <span>=</span> res <span>*</span> <span>10</span> <span>+</span> t<span>;</span>\n        num <span>/=</span> <span>10</span><span>;</span>\n    <span>}</span>\n    <span>return</span> res<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>{% note success flat %}\n执行用时：52 ms, 在所有 Java 提交中击败了50.31%的用户\n内存消耗：55.7 MB, 在所有 Java 提交中击败了22.09%的用户\n{% endnote %}</p>\n<hr>\n",
      "image": "https://i.loli.net/2021/04/02/ky1pv4xsiUaCzYo.png",
      "date_published": "2021-04-13T14:48:05.000Z",
      "date_modified": "2021-04-13T07:11:18.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 501-600题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/501-600/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/501-600/",
      "summary": "501-600题题解",
      "content_html": "<h2 id=\"_561-数组拆分i\"> <a href=\"https://leetcode-cn.com/problems/array-partition-i/\" target=\"_blank\" rel=\"noopener noreferrer\">561.数组拆分I</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给定长度为 <code>2n</code> 的整数数组 <code>nums</code> ，你的任务是将这些数分成 <code>n</code> 对，例如 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>(</span><span>a</span><span>1</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>b</span><span>1</span><span>)</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>a</span><span>2</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>b</span><span>2</span><span>)</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>…</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>(</span><span>an</span><span>,</span><span style=\"margin-right:0.16666666666666666em;\"></span><span>bn</span><span>)</span></span></span></span> ，使得从 <code>1</code> 到 <code>n</code> 的 <code>min(ai, bi)</code>\n总和最大。</p>\n<p>返回该<strong>最大总和</strong> 。</p>\n<p>其中：</p>\n<ul>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.78041em;vertical-align:-0.13597em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span>n</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>.</span><span style=\"margin-right:0.01968em;\">l</span><span>e</span><span>n</span><span style=\"margin-right:0.03588em;\">g</span><span>t</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span>2</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>×</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.43056em;vertical-align:0em;\"></span><span>n</span></span></span></span></li>\n<li><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.950078em;vertical-align:-0.13597em;\"></span><span>−</span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>n</span><span>u</span><span>m</span><span>s</span><span>[</span><span>i</span><span>]</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>≤</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span>1</span><span><span>0</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>4</span></span></span></span></span></span></span></span></span></span></span>。</li>\n</ul>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n\n输入：<code>nums = [1, 4, 3, 2]</code>\n输出：<code>4</code>\n</p>\n\n<p>输入：<code>nums = [6, 2, 6, 5, 1, 2]</code>\n输出：<code>9</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>题目要求返回所有最小值的和的最大值，只要能保证以下两点就可以保证最后的结果是符合题意的：</p>\n<ol>\n<li>\n<p>取最小值时只舍弃一个局部最大值</p>\n<p>比如对于 <code>[1, 4, 3, 2]</code>，如果将 <code>[1, 4]</code> 组合并舍弃 <code>4</code> 是不合理的，但 如果将<code>[1, 2]</code> 组合并舍弃 <code>2</code> 是合理的，这里 <code>2</code> 就是相对于 <code>1</code> 的一个局部最大值</p>\n</li>\n<li>\n<p>求和时每一个部分都是局部最大</p>\n</li>\n</ol>\n<p>如果满足了第一点，那么数组就会剩下相对较大的值，就可以保证第二点的实现。因此本题只需关注第一点要求。</p>\n<p>为了实现这一点要求，需要找到相对于当前数字的一个最小的最大值。不难想到需要对数组做排序，排序后的下一个数字就是相对于上一个数字的最小的最大值，这样每两个数取最小值就可以保证舍弃的只是一个局部最大值，而数组整体中的较大值会被保留下来（满足了第二点要求）。</p>\n<p>同时，由于每次都是对排序后的数组两两取最小值，那么最后会被保留的就是奇数位置（索引是偶数）的数，在求和时只要对他们求和就可以了。</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>public</span> <span>int</span> <span>arrayPairSum</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>\n    <span>Arrays</span><span>.</span><span>sort</span><span>(</span>nums<span>)</span><span>;</span>\n    <span>int</span> sum <span>=</span> <span>0</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> nums<span>.</span>length<span>;</span> i <span>=</span> i <span>+</span> <span>2</span><span>)</span> <span>{</span>\n        sum <span>+=</span> nums<span>[</span>i<span>]</span><span>;</span>\n    <span>}</span>\n    <span>return</span> sum<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><hr>\n",
      "date_published": "2021-04-13T14:42:58.000Z",
      "date_modified": "2021-04-13T07:11:18.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "LeetCode 701-800题题解",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/701-800/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/common/701-800/",
      "summary": "701-800题题解",
      "content_html": "<h2 id=\"_783-二叉搜索树节点最小距离\"> <a href=\"https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/\" target=\"_blank\" rel=\"noopener noreferrer\">783.二叉搜索树节点最小距离</a></h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给你一个二叉搜索树的根节点 <code>root</code>，返回树中任意两不同节点值之间的最小差值。</p>\n<p>{% note info flat %}</p>\n<ul>\n<li>树中节点数目在范围 <code>[2, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 10^5</code>\n{% endnote %}</li>\n</ul>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>{% tabs sample %}\n</p>\n<p><img src=\"https://i.loli.net/2021/04/13/BplQOwciLIvDMJS.jpg\" alt=\"bst1.jpg\" /></p>\n<p>输入： <code>root = [4, 2, 6, 1, 3]</code>\n输出： <code>1</code>\n</p>\n\n<p><img src=\"https://i.loli.net/2021/04/13/GDLPOhMK91WXqYl.jpg\" alt=\"bst2.jpg\" /></p>\n<p>输入： <code>root = [1, 0, 48, null, null, 12, 49]</code>\n输出： <code>1</code>\n\n{% endtabs %}</p>\n<h3 id=\"解题思路\"> 解题思路</h3>\n<p>根据二叉搜索树的定义，其中序遍历的结果一定是一个升序集合。比如示例1的中序输出结果是：<code>[1, 2, 3, 4, 6]</code>，示例2的中序输出结果是：<code>[0, 1, 12, 48, 49]</code>。计算这个集合中相邻两数差的最小值就是题目要求的结果。</p>\n<h3 id=\"代码实现\"> 代码实现</h3>\n<div><pre><code><span>/**\n * 保存前一个节点的值\n */</span>\n<span>private</span> <span>int</span> pre <span>=</span> <span>-</span><span>1</span><span>;</span>\n\n<span>/**\n * 保存结果\n */</span>\n<span>private</span> <span>int</span> result <span>=</span> <span>0x3f3f3f3f</span><span>;</span>\n\n<span>/**\n * 计算树中任意两不同节点值之间的最小差值\n *\n * &lt;p>\n * 思路:&lt;br>\n * 对于二叉搜索树, 中序遍历的结果是一个递增的数组, 最小的差值就是相邻两个元素之差的最小值\n * &lt;/p>\n *\n * @param root 树的根节点\n * @return 树中任意两不同节点值之间的最小差值\n */</span>\n<span>public</span> <span>int</span> <span>minDiffInBST</span><span>(</span><span>TreeNode</span> root<span>)</span> <span>{</span>\n    <span>inorder</span><span>(</span>root<span>)</span><span>;</span>\n    <span>return</span> result<span>;</span>\n<span>}</span>\n\n<span>/**\n * 对树做中序遍历\n *\n * @param node 某个节点\n */</span>\n<span>public</span> <span>void</span> <span>inorder</span><span>(</span><span>TreeNode</span> node<span>)</span> <span>{</span>\n    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>{</span>\n        <span>return</span><span>;</span>\n    <span>}</span>\n    <span>inorder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>\n    <span>// 对于第一个节点, 因为还没有前一个节点的值, 所以这个时候不要取小值</span>\n    <span>if</span> <span>(</span>pre <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>\n        result <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>result<span>,</span> node<span>.</span>val <span>-</span> pre<span>)</span><span>;</span>\n    <span>}</span>\n    pre <span>=</span> node<span>.</span>val<span>;</span>\n    <span>inorder</span><span>(</span>node<span>.</span>right<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>{% note success flat %}\n执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户\n内存消耗：36.1 MB, 在所有 Java 提交中击败了39.65%的用户\n{% endnote %}</p>\n<hr>\n",
      "image": "https://i.loli.net/2021/04/13/BplQOwciLIvDMJS.jpg",
      "date_published": "2021-04-13T15:12:29.000Z",
      "date_modified": "2021-04-13T07:27:24.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "17.21.直方图的水量",
      "url": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/interview/17/17.21.%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/",
      "id": "https://blog.lixiangyu.xyz/_posts/leetcode/solution/interview/17/17.21.%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F/",
      "summary": "动态规划/单调栈/双指针",
      "content_html": "<h2 id=\"题目信息\"> 题目信息</h2>\n<h3 id=\"题目描述\"> 题目描述</h3>\n<p>给定一个直方图（也称柱状图），假设有人从上面源源不断地倒水，最后直方图能存多少水量？ 直方图的宽度为 <code>1</code>。</p>\n<p><img src=\"https://i.loli.net/2021/04/02/OaSvsxBPWKgiq6F.png\" alt=\"rainwatertrap.png\" /></p>\n<p>上面的图像是数组 <code>[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]</code> （即示例输出中的数组）表示的直方图，在这种情况下，可以接 <code>6</code> 个单位的水（蓝色部分表示水）。</p>\n<h3 id=\"示例输出\"> 示例输出</h3>\n<p>输入： <code>[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]</code>\n输出： <code>6</code></p>\n<h2 id=\"解题思路\"> 解题思路</h2>\n<p>{% tabs solution %}\n</p>\n<p>以示例数组为例，索引 <code>5</code> 位置，两侧的最大高度的较小值是 <code>2</code>， 所以能够放水的量是 <code>2 - 0 = 2</code>（<code>0</code> 是自身高度）。对于索引 <code>4</code> 位置就是 <code>2 - 1 = 1</code>。</p>\n<p>因此某个位置能够防水的量取决于它<strong>两侧高度最大值中的较小值-自身高度</strong>，计算两侧的最大高度可以通过动态规划来实现。</p>\n\n\n<p>待补充\n</p>\n\n<p>待补充\n\n{% endtabs %}</p>\n<h2 id=\"代码实现\"> 代码实现</h2>\n<p>{% tabs code %}\n</p>\n<div><pre><code><span>public</span> <span>int</span> <span>trap</span><span>(</span><span>int</span><span>[</span><span>]</span> height<span>)</span> <span>{</span>\n    <span>// 数组高度</span>\n    <span>int</span> n <span>=</span> height<span>.</span>length<span>;</span>\n\n    <span>// 题目没有限制数量一定大于0, 如果数量为0, 需要返回0</span>\n    <span>if</span> <span>(</span>n <span>==</span> <span>0</span><span>)</span> <span>{</span>\n        <span>return</span> <span>0</span><span>;</span>\n    <span>}</span>\n\n    <span>// 表示i位置的左侧最大高度</span>\n    <span>int</span><span>[</span><span>]</span> leftHeightMax <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>\n    <span>// 表示i位置的右侧最大高度</span>\n    <span>int</span><span>[</span><span>]</span> rightHeightMax <span>=</span> <span>new</span> <span>int</span><span>[</span>n<span>]</span><span>;</span>\n\n    <span>// 0位置的左侧最大高度是自身</span>\n    leftHeightMax<span>[</span><span>0</span><span>]</span> <span>=</span> height<span>[</span><span>0</span><span>]</span><span>;</span>\n    <span>// n-1位置的右侧最大高度是自身</span>\n    rightHeightMax<span>[</span>n <span>-</span> <span>1</span><span>]</span> <span>=</span> height<span>[</span>n <span>-</span> <span>1</span><span>]</span><span>;</span>\n\n    <span>// dp计算最大高度</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        leftHeightMax<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>leftHeightMax<span>[</span>i <span>-</span> <span>1</span><span>]</span><span>,</span> height<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> n <span>-</span> <span>2</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span> <span>{</span>\n        rightHeightMax<span>[</span>i<span>]</span> <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>rightHeightMax<span>[</span>i <span>+</span> <span>1</span><span>]</span><span>,</span> height<span>[</span>i<span>]</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 保存结果</span>\n    <span>int</span> result <span>=</span> <span>0</span><span>;</span>\n    <span>// 两侧高度的最小值-自身高度就是可以防水的量</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> n<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        result <span>+=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>leftHeightMax<span>[</span>i<span>]</span><span>,</span> rightHeightMax<span>[</span>i<span>]</span><span>)</span> <span>-</span> height<span>[</span>i<span>]</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> result<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>{% note success flat %}\n执行用时：1 ms, 在所有 Java 提交中击败了99.90%的用户\n内存消耗：38 MB, 在所有 Java 提交中击败了83.22%的用户\n{% endnote %}\n</p>\n\n<p>待补充\n</p>\n\n<p>待补充\n\n{% endtabs %}</p>\n<hr>\n",
      "image": "https://i.loli.net/2021/04/02/OaSvsxBPWKgiq6F.png",
      "date_published": "2021-04-02T13:54:56.000Z",
      "date_modified": "2021-04-02T08:43:16.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "♟️ 百度",
      "url": "https://blog.lixiangyu.xyz/interview/experience/baidu/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/baidu/",
      "content_html": "<h2 id=\"acg-私有云\"> ACG 私有云</h2>\n<h3 id=\"视频面试\"> 视频面试</h3>\n<h4 id=\"一面\"> 一面</h4>\n<ol>\n<li>自我介绍，项目中有什么地方印象深刻</li>\n<li><code>synchronized</code> 和 <code>Lock</code> 接口的区别</li>\n<li>悲观锁和乐观锁</li>\n<li>乐观锁的典型实现是什么，CAS 怎么实现</li>\n<li>CAS 有什么问题</li>\n<li><code>HashMap</code> 底层数据结构</li>\n<li>什么情况下链表会转换为红黑树，什么情况下红黑树会退化为链表</li>\n<li><code>HashMap</code> 的 <code>resize</code> 原理</li>\n<li>重点说一下 <code>resize</code> 中 <code>rehash</code> 部分的原理</li>\n<li>JVM 内存分区</li>\n<li>线程私有区域的虚拟机栈，本地方法栈，程序计数器都是干啥的</li>\n<li>说说 MySQL 了解什么</li>\n<li>B+ 树非叶子节点不保存数据有什么好处</li>\n<li>B+ 树比红黑树树高低，有什么好处</li>\n<li>SpringBoot 用过吗，它有什么优点</li>\n<li>那你了解 starter 的原理吗</li>\n<li>动态代理，JDKProxy 和 CGLib</li>\n<li>算法题 1：<a href=\"https://leetcode-cn.com/problems/angle-between-hands-of-a-clock/\" target=\"_blank\" rel=\"noopener noreferrer\">1344. 时钟指针的夹角</a></li>\n<li>算法题 2：口述，<a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\" target=\"_blank\" rel=\"noopener noreferrer\">232. 用栈实现队列</a></li>\n</ol>\n<h4 id=\"二面\"> 二面</h4>\n<ol>\n<li>自我介绍</li>\n<li>算法题 1：手写快排、冒泡排序，要讲解它们的原理，比如某次循环后数组变成什么样</li>\n<li>算法题 2：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\" target=\"_blank\" rel=\"noopener noreferrer\">206. 反转链表</a></li>\n<li>TCP 三次握手</li>\n<li>TCP 四次挥手</li>\n<li>四次挥手的目的</li>\n<li>四次挥手过程中的 wait 状态以及 2MSL</li>\n<li>TCP 和 UDP 的区别</li>\n<li>TCP 怎么保证可靠性</li>\n<li>内存泄漏和内存溢出</li>\n<li>介绍一下你最熟悉的项目</li>\n<li>这个项目的流程和架构</li>\n<li>用了什么中间件</li>\n<li>MQ 在项目中的作用</li>\n<li>Redis 在项目中的作用</li>\n<li>如果让你来设计 MQ，你会考虑哪些方面</li>\n<li>离职原因</li>\n<li>有什么想问我的</li>\n</ol>\n<h3 id=\"总结\"> 总结</h3>\n<p>一二面都过了，但是三面面试官时间不合适，而且已经快入职了，所以三面拒了。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🎭 Boss 直聘",
      "url": "https://blog.lixiangyu.xyz/interview/experience/boss/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/boss/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>简历筛选：两天。</p>\n<h2 id=\"笔试\"> 笔试</h2>\n<p>一个问卷，前三道题任选两道，后两道题选其中一道。</p>\n<ol>\n<li>两个线程，一个线程输出小写字母a-z，一个线程输出大写字母A-Z，最后输出结果是aAbB...zZ，同时还有每个线程的打印耗时，以及总耗时</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>MultiThreadTest</span> multiThreadTest <span>=</span> <span>new</span> <span>MultiThreadTest</span><span>(</span><span>)</span><span>;</span>\n    <span>new</span> <span>Thread</span><span>(</span>multiThreadTest<span>::</span><span>printCharacterInLowerCase</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>new</span> <span>Thread</span><span>(</span>multiThreadTest<span>::</span><span>printCharacterInUpperCase</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n<span>}</span>\n\n<span>class</span> <span>MultiThreadTest</span> <span>{</span>\n    <span>/**\n     * 控制小写字母输出的信号量\n     */</span>\n    <span>private</span> <span>Semaphore</span> semaphoreLower <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>1</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 控制大写字母输出的信号量\n     */</span>\n    <span>private</span> <span>Semaphore</span> semaphoreUpper <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>0</span><span>)</span><span>;</span>\n\n    <span>/**\n     * 线程1执行所用时间\n     */</span>\n    <span>private</span> <span>long</span> timeOfThread1<span>;</span>\n\n    <span>/**\n     * 输出小写字母\n     */</span>\n    <span>public</span> <span>void</span> <span>printCharacterInLowerCase</span><span>(</span><span>)</span> <span>{</span>\n        <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>97</span><span>;</span> i <span>&lt;</span> <span>123</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                semaphoreLower<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>(</span><span>char</span><span>)</span> i<span>)</span><span>;</span>\n                semaphoreUpper<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        timeOfThread1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> startTime<span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 输出大写字母\n     */</span>\n    <span>public</span> <span>void</span> <span>printCharacterInUpperCase</span><span>(</span><span>)</span> <span>{</span>\n        <span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>65</span><span>;</span> i <span>&lt;</span> <span>91</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                semaphoreUpper<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>(</span><span>char</span><span>)</span> i<span>)</span><span>;</span>\n                semaphoreLower<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>Exception</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>long</span> timeOfThread2 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span> <span>-</span> startTime<span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"\\n线程1执行时间: \"</span> <span>+</span> timeOfThread1 <span>+</span> <span>\"ms\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"线程2执行时间: \"</span> <span>+</span> timeOfThread2 <span>+</span> <span>\"ms\"</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"总执行时间: \"</span> <span>+</span> <span>(</span>timeOfThread1 <span>+</span> timeOfThread2<span>)</span> <span>+</span> <span>\"ms\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><ol start=\"2\">\n<li>求 100 以内的质数的阶乘和，即 2! + 3! + 5! + ... + 97! 的和（会溢出，用 BigDecimal 类）</li>\n</ol>\n<div><pre><code><span>public</span> <span>BigDecimal</span> <span>primeFactorialSum</span><span>(</span><span>)</span> <span>{</span>\n    <span>BigDecimal</span> num <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>1</span><span>)</span><span>;</span>\n    <span>BigDecimal</span> sum <span>=</span> <span>new</span> <span>BigDecimal</span><span>(</span><span>0</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>// 计算阶乘</span>\n        num <span>=</span> num<span>.</span><span>multiply</span><span>(</span><span>new</span> <span>BigDecimal</span><span>(</span>i<span>)</span><span>)</span><span>;</span>\n        <span>// 只有是质数时才相加</span>\n        <span>if</span> <span>(</span><span>isPrime</span><span>(</span>i<span>)</span><span>)</span> <span>{</span>\n            sum <span>=</span> sum<span>.</span><span>add</span><span>(</span>num<span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> sum<span>;</span>\n<span>}</span>\n\n<span>public</span> <span>boolean</span> <span>isPrime</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>2</span><span>;</span> i <span>*</span> i <span>&lt;=</span> x<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>x <span>%</span> i <span>==</span> <span>0</span><span>)</span> <span>{</span>\n            <span>return</span> <span>false</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    <span>return</span> <span>true</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ol start=\"3\">\n<li>设计并实现一个尽可能满足 Exactly Once 协议的阻塞队列，并基于该队列实现一个准确计数的 publish-subscribe 模型</li>\n</ol>\n<p>没写，有空再看。</p>\n<ol start=\"4\">\n<li>有 23 枚硬币在桌子上，10 枚正面朝上，假设别人蒙住你的眼睛，而你的手又摸不出硬币的正反面。让你用最好的方法把硬币分成两堆，每堆正面朝上的硬币个数相同</li>\n</ol>\n<p>分为一堆 10 个，另一堆 13 个，然后将 10 个那一堆所有的硬币翻转就可以了。</p>\n<ol start=\"5\">\n<li>中间只隔一个数字的两个质数被称为质数对，比如 17 和 19。证明质数对之间的数字总能被 6 整除（假设这两个质数都大于 6）</li>\n</ol>\n<ul>\n<li>穷举：通过代码可以验证一定范围内（比如小于 2147483674 的质数对）的质数对都是满足题意的</li>\n<li>数学证明：\n<ul>\n<li>两个质数都不会被 2 整除，因此中间的数是 2 的倍数</li>\n<li>两个质数都不会被 3 整除，因此第一个质数的前一个数也不会被 3 整除（因为它和后一个质数相差 3），所以中间的数是 3 的倍数</li>\n<li>因为中间的数既是 2 的倍数，又是 3 的倍数，所以这个数是 6 的倍数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"视频面\"> 视频面</h2>\n<h3 id=\"一面\"> 一面</h3>\n<ol>\n<li>自我介绍</li>\n<li>简单聊聊项目</li>\n<li>TCP/IP 模型</li>\n<li>TCP 三次握手</li>\n<li>TCP 的超时重传机制</li>\n<li>操作系统的分页和分段</li>\n<li>常见的排序算法</li>\n<li>它们的时间复杂度和空间复杂度各是多少</li>\n<li>快排的时间复杂度为什么是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>o</span><span style=\"margin-right:0.03588em;\">g</span><span>n</span><span>)</span></span></span></span></li>\n<li>快排除了递归的写法还知道其他实现方式嘛</li>\n<li>算法题：手写快排或者堆排</li>\n<li>MySQL 索引</li>\n<li>B 树、B + 树、红黑树的区别</li>\n<li>红黑树的时间复杂度为什么是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span style=\"margin-right:0.01968em;\">l</span><span>o</span><span style=\"margin-right:0.03588em;\">g</span><span>n</span><span>)</span></span></span></span></li>\n<li><code>HashMap</code> 底层数据结构</li>\n<li><code>HashMap</code> 的 <code>put</code> 操作的逻辑</li>\n<li><code>ConcurrentHashMap</code> 如何保证线程安全</li>\n<li>微服务的优点</li>\n<li>最近看了什么书</li>\n<li>有什么想问我的</li>\n</ol>\n<h3 id=\"二面\"> 二面</h3>\n<ol>\n<li>自我介绍</li>\n<li>链表和数组的特点</li>\n<li>链表查询的时间复杂度是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>)</span></span></span></span>，怎么优化（我回答红黑树）</li>\n<li>红黑树相比 B 树有什么优点</li>\n<li>Redis 的基本数据结构</li>\n<li><code>zset</code> 的底层数据结构（到了这个问题我才意识到面试官的第三个问题是想让我答跳跃表）</li>\n<li>跳跃表的原理</li>\n<li>给你一百万的数据，跳跃表只能建立一层索引，跳跃表的步长怎么定</li>\n<li>有什么问题想问我的</li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>Boss 直聘给我感觉是面试体验最差的，两个面试官都贼严肃，整场面试下来感觉特别压抑。而且 hr 打电话的时候直接说了加班比较严重，我和之前在这个公司的一个同事聊天也确认了，加班确实严重，准备去这里的提前做好心理准备。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🎲 字节跳动",
      "url": "https://blog.lixiangyu.xyz/interview/experience/bytedance/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/bytedance/",
      "content_html": "<h2 id=\"幸福里\"> 幸福里</h2>\n<h3 id=\"视频面试\"> 视频面试</h3>\n<h4 id=\"一面\"> 一面</h4>\n<p>参考网上的面经吧，实在是想不起来了。。。</p>\n<ol>\n<li>场景：12306 抢票 30 分钟过期怎么设计</li>\n<li>算法题：<a href=\"https://leetcode-cn.com/problems/merge-intervals/\" target=\"_blank\" rel=\"noopener noreferrer\">56. 合并区间</a></li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>面试官人不错，同样感觉答得还行，但是还是一面挂了。后来有个国际支付部门的 hr 联系我，但因为已经准备去老虎了，所以拒了。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🥁 好大夫在线",
      "url": "https://blog.lixiangyu.xyz/interview/experience/haodf/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/haodf/",
      "content_html": "<h2 id=\"视频面试\"> 视频面试</h2>\n<h3 id=\"一面\"> 一面</h3>\n<ol>\n<li>面试官先介绍了一下公司背景：公司老项目涉及 php，过程中可能会与 php 做交互（php 牛逼）</li>\n<li>自我介绍</li>\n<li>问问项目</li>\n<li>SQL 如何优化</li>\n<li>索引失效场景</li>\n<li>最左匹配原则</li>\n<li>覆盖索引</li>\n<li>运行时常量池和字符串常量池</li>\n<li>类加载时机</li>\n<li>双亲委派机制</li>\n<li>Java 提供双亲委派机制的意义是什么</li>\n<li>Spring 中怎么表示对象需要 Spring 容器管理（Bean 注解）</li>\n<li>Spring Bean 的作用域</li>\n<li>Spring MVC 请求流程</li>\n<li>Netty 的 I/O 模型</li>\n<li>I/O 模型都有哪些</li>\n<li>I/O 多路复用</li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>一面过了，二面需要到现场，但是已经快入职了，所以二面就拒了</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧩 美团",
      "url": "https://blog.lixiangyu.xyz/interview/experience/meituan/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/meituan/",
      "content_html": "<h2 id=\"美团优选\"> 美团优选</h2>\n<h3 id=\"视频面试\"> 视频面试</h3>\n<h4 id=\"一面\"> 一面</h4>\n<ol>\n<li>自我介绍</li>\n<li>简单聊聊项目</li>\n<li>MQ 怎么处理重复消费的场景</li>\n<li><code>HashMap</code> 底层数据结构</li>\n<li><code>ConcurrentHashMap</code> 如何保证线程安全</li>\n<li><code>synchronized</code> 和 CAS</li>\n<li>锁升级过程</li>\n<li>线程池的 7 个参数</li>\n<li>线程池执行流程</li>\n<li>垃圾回收算法</li>\n<li>CMS 收集器</li>\n<li>最近看了什么书</li>\n<li>有什么想问我的</li>\n<li>算法题：<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\" target=\"_blank\" rel=\"noopener noreferrer\">129. 求根节点到叶节点数字之和</a></li>\n</ol>\n<h2 id=\"美团到店\"> 美团到店</h2>\n<h3 id=\"视频面试-2\"> 视频面试</h3>\n<h4 id=\"一面-2\"> 一面</h4>\n<ol>\n<li>自我介绍</li>\n<li>用过哪些容器</li>\n<li><code>ArrayList</code> 底层数据结构，数组的特点</li>\n<li>数组是插入删除慢，那么哪个数据结构是增删快</li>\n<li>哪种容器用了链表</li>\n<li><code>ArrayList</code> 是线程安全的吗</li>\n<li>哪些方式可以实现 <code>List</code> 的线程安全</li>\n<li><code>HashMap</code> 的 <code>resize</code></li>\n<li><code>ConcurrentHashMap</code> 怎么保证线程安全</li>\n<li>JMM</li>\n<li>JVM 内存分区</li>\n<li><code>String a = &quot;abc&quot;，String b = new String(&quot;abc&quot;)</code> 在哪些区域创建对象</li>\n<li>垃圾回收算法有哪些</li>\n<li>哪些对象可以是 GC Roots</li>\n<li>MySQL 隔离级别</li>\n<li>脏读、不可重复读和幻读</li>\n<li>Linux 常用命令有哪些</li>\n<li>你用 <code>top</code> 命令是查看什么（因为我上面那个问题回答了 top 命令，所以面试官问了一下）</li>\n<li>Spring IoC，AOP 的特点</li>\n<li>使用 Spring 容器管理的好处</li>\n<li>MyBatis 怎么处理 SQL 注入攻击</li>\n<li>算法题：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\" target=\"_blank\" rel=\"noopener noreferrer\">141. 环形链表</a></li>\n<li>有什么想问我的</li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>美团的面试官人很好，给人的感觉不错。感觉答得不错，但很可惜一面都挂了。</p>\n<p>面试题的话，记得可能不是很清楚了，大体内容是这些可能会少那么一两道，可以参考网上其他的面经。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 面经",
      "url": "https://blog.lixiangyu.xyz/interview/experience/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/",
      "content_html": "<p>面经整理：</p>\n<ol>\n<li><a href=\"/interview/experience/bytedance\">字节跳动</a></li>\n<li><a href=\"/interview/experience/meituan\">美团</a></li>\n<li><a href=\"/interview/experience/baidu\">百度</a></li>\n<li><a href=\"/interview/experience/yuanfudao\">猿辅导</a></li>\n<li><a href=\"/interview/experience/tiger\">老虎集团</a></li>\n<li><a href=\"/interview/experience/boss\">Boss 直聘</a></li>\n<li><a href=\"/interview/experience/haodf\">好大夫在线</a></li>\n<li><a href=\"/interview/experience/xuetangzaixian\">学堂在线</a></li>\n<li><a href=\"/interview/experience/yuanbaoshuke\">元保数科</a></li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🎱 老虎集团",
      "url": "https://blog.lixiangyu.xyz/interview/experience/tiger/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/tiger/",
      "content_html": "<h2 id=\"视频面试\"> 视频面试</h2>\n<h3 id=\"一面\"> 一面</h3>\n<ol>\n<li>自我介绍</li>\n<li>聊聊指令公司系统相关的内容</li>\n<li>MySQL 了解哪些</li>\n<li>聚簇和非聚簇索引的区别</li>\n<li>联合索引的最左匹配原则</li>\n<li>SQL 优化</li>\n<li>讲讲报表</li>\n<li>索引失效的场景</li>\n<li>JVM 内存分区、哪些是共享的，哪些是线程私有的</li>\n<li>JVM 参数</li>\n<li>垃圾回收算法</li>\n<li>线程池 7 个参数，<code>execute</code> 执行流程</li>\n<li>用过哪些线程安全的类</li>\n<li><code>ConcurrentHashMap</code> 如何保证线程安全</li>\n<li>什么是 CAS</li>\n<li>CAS 的 ABA 问题</li>\n<li>你们公司系统的账号加密怎么实现的</li>\n<li>Redis 使用过吗，有哪些数据类型</li>\n<li>你们的 C# 客户端是怎么跟 Java 后端通信的</li>\n<li>算法题：<a href=\"https://leetcode-cn.com/problems/reorder-list/\" target=\"_blank\" rel=\"noopener noreferrer\">143. 重排链表</a></li>\n</ol>\n<h2 id=\"二面\"> 二面</h2>\n<ol>\n<li>自我介绍</li>\n<li>认为哪个项目自己做的最好</li>\n<li>项目的难点</li>\n<li><code>equals</code> 和 <code>hashcode</code></li>\n<li>如果 <code>equals</code> 相等，<code>hashcode</code> 不等，在 <code>HashMap</code> 中会有什么影响</li>\n<li>Redis 的分布式锁</li>\n<li>ZooKeeper 的分布式锁</li>\n<li>ZooKeeper 的选举机制</li>\n<li>依次启动五个 ZooKeeper 节点，哪个是主</li>\n<li>AQS 原理</li>\n<li>AQS 为什么使用双向队列</li>\n<li>读已提交和可重复读</li>\n<li>间隙锁和 Next-Key Lock</li>\n<li>JDKProxy 和 CGLib</li>\n<li>代码题（二选一）</li>\n</ol>\n<ul>\n<li>延迟加载的单例类，使用双检锁，注意加上 <code>volatile</code></li>\n<li>三个线程循环打印 ABC（与 <a href=\"https://leetcode-cn.com/problems/print-zero-even-odd/\" target=\"_blank\" rel=\"noopener noreferrer\">1116. 打印零与奇偶数</a> 类似），可以使用三个信号量来解决</li>\n</ul>\n<ol start=\"16\">\n<li>目前的工资</li>\n<li>最快到岗时间</li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>除了二面的 ZK 我没用过，其他内容难度中等，面试官挺友善，已拿 offer。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🎧 学堂在线",
      "url": "https://blog.lixiangyu.xyz/interview/experience/xuetangzaixian/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/xuetangzaixian/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>公司地点：五道口 科建大厦 7 层</p>\n<p>上班时间：9 点半（左右）到 7 点（左右）</p>\n<p>技术栈：k8s，kotlin，vert，JDK11</p>\n<p>简历筛选：半天</p>\n<h2 id=\"笔试\"> 笔试</h2>\n<ol>\n<li>何时可以设置线程的优先级</li>\n<li>根据二叉树的前中序序列得到后序序列</li>\n<li>下面代码的输出结果：</li>\n</ol>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>String</span> a <span>=</span> <span>\"hello\"</span><span>;</span>\n    <span>String</span> b <span>=</span> <span>\"hello\"</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> b<span>)</span><span>;</span> <span>// true，因为是字符串池中的同一个引用</span>\n    <span>String</span> c <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"C\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> c<span>)</span><span>;</span> <span>// false，因为在堆上新建了对象，所以肯定不等</span>\n    <span>StringBuffer</span> d <span>=</span> <span>new</span> <span>StringBuffer</span><span>(</span><span>\"hello\"</span><span>)</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a <span>==</span> d<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// false，StringBuffer的toString是通过new String返回一个新的字符串</span>\n    <span>String</span> e <span>=</span> <span>\"hel\"</span> <span>+</span> <span>\"lo\"</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b <span>==</span> e<span>)</span><span>;</span> <span>// true，编译时会将e直接替换为hello</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol start=\"4\">\n<li>下面代码的输出结果：</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 只有C，因为使用了final，所以只涉及类的常量池，不会触发初始化</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>B</span><span>.</span>c<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>A</span> <span>{</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>extends</span> <span>A</span> <span>{</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>final</span> <span>static</span> <span>String</span> c <span>=</span> <span>\"C\"</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ol start=\"5\">\n<li>下面代码的输出结果：</li>\n</ol>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>// 与上面代码的区别在于没有使用final，所以会触发类的初始化</span>\n        <span>// 输出ABC</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>B</span><span>.</span>c<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>A</span> <span>{</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"A\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>extends</span> <span>A</span> <span>{</span>\n    <span>static</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"B\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>String</span> c <span>=</span> <span>new</span> <span>String</span><span>(</span><span>\"C\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><ol start=\"6\">\n<li>手写两种线程安全的单例模式</li>\n<li>JVM 中内存区域的划分，主要永久代和元空间</li>\n<li>JVM 调优工具</li>\n</ol>\n<h2 id=\"现场面试\"> 现场面试</h2>\n<p>笔试结束后，总共三个人挨个找我面试，最后一个人是 CTO。</p>\n<h3 id=\"第一个面试官\"> 第一个面试官</h3>\n<ol>\n<li>自我介绍</li>\n<li>介绍一下项目经历</li>\n<li>MySQL 索引失效的场景</li>\n<li>InnoDB 怎么实现事务的</li>\n<li>Redis 的数据删除策略</li>\n<li>怎么实现 LRU</li>\n<li>说了一下笔试中错的问题</li>\n</ol>\n<h3 id=\"第二个面试官\"> 第二个面试官</h3>\n<p>就一直在聊项目经历。</p>\n<h3 id=\"第三个面试官-cto\"> 第三个面试官（CTO）</h3>\n<ol>\n<li>自我介绍</li>\n<li>讲讲自己最感兴趣的项目经历</li>\n<li>为什么离职</li>\n<li>介绍一下 MySQL 的事务</li>\n<li>了解 Linux 内核嘛，介绍一下 select 和 epoll</li>\n<li>场景：程序上线，CPU 100%，怎么排查</li>\n</ol>\n<h2 id=\"总结\"> 总结</h2>\n<p>总的来说，技术性的东西问的不多，对项目经历问的会比较多。因为是跟教育相关的公司，所以我觉得如果你的项目经历有教育相关的经历，他们会比较感兴趣。</p>\n<p>后续：hr 认为项目经历与公司需求不太相符，压工资到 15k，拒了。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🎺 猿辅导",
      "url": "https://blog.lixiangyu.xyz/interview/experience/yuanfudao/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/yuanfudao/",
      "content_html": "<h2 id=\"视频面试\"> 视频面试</h2>\n<h3 id=\"一面\"> 一面</h3>\n<ol>\n<li>自我介绍</li>\n<li>聊聊专注度检测系统（简历上我的毕设项目）</li>\n<li>聊聊报表</li>\n<li>写 SQL 的时候你是怎么优化的</li>\n<li><code>explain</code> 字段有哪些，说说这些字段不同取值代表什么含义</li>\n<li>索引有哪些</li>\n<li>索引底层数据结构</li>\n<li>为什么用B+树，而不是B树和红黑树</li>\n<li>索引失效的场景</li>\n<li>隐式类型转换一定会导致索引失效吗</li>\n<li>最左匹配原则</li>\n<li>面试官写了三个 SQL，问我哪个会用索引</li>\n<li>MySQL 隔离级别</li>\n<li>脏读、不可重复读、幻读</li>\n<li>MySQL 默认的隔离级别</li>\n<li>MVCC + Next-Key Lock</li>\n<li>除了行锁、间隙锁还知道哪些锁</li>\n<li>MySQL 主从复制原理</li>\n<li>Redis 的数据结构</li>\n<li>SDS 的底层实现</li>\n<li>Spring Bean 生命周期</li>\n<li>Spring 三级缓存</li>\n<li>通过构造器和 <code>set</code> 方法的注入都可以通过三级缓存解决循环引用吗</li>\n<li>分布式微服务的优点</li>\n<li><code>HashMap</code> 是线程安全的吗</li>\n<li><code>ConcurrentHashMap</code> 怎么保证线程安全</li>\n<li><code>HashMap</code> 的 <code>put</code> 操作逻辑</li>\n<li><code>List</code> 怎么获取一定范围的子集</li>\n<li><code>ThreadLocal</code> 底层数据结构</li>\n<li><code>ThreadLocal</code> 所用 Map 的键是什么</li>\n<li><code>ThreadLocal</code> 取值的逻辑</li>\n<li>线程池的 7 个参数</li>\n<li>线程池在什么情况下会触发拒绝策略</li>\n<li>线程池的线程什么时候会被回收</li>\n<li>核心线程一定不会被回收吗</li>\n<li>核心线程数量你们是怎么定义的</li>\n<li><code>volatile</code> 关键字</li>\n</ol>\n<p>12题：\n表里可能还有别的字段</p>\n<p>索引1：abcd</p>\n<p>索引2：e</p>\n<ul>\n<li><code>select * from table where b = 1 and c = 3 and a &gt; 1 and d like '%12' order by b;</code></li>\n<li><code>select * from table where b &lt; 3 and c = 3 and a &gt; 1 and d like '%12' order by e;</code></li>\n<li><code>select * from table where e &gt; 3;</code></li>\n</ul>\n<h2 id=\"总结\"> 总结</h2>\n<p>猿辅导是我所有面试里面问的最细最多的，尤其是 MySQL 和并发，可劲怼着问。现在教育行业有点不太行，可能刚进去就直接被裁。谨慎考虑一下。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧶 元保数科",
      "url": "https://blog.lixiangyu.xyz/interview/experience/yuanbaoshuke/",
      "id": "https://blog.lixiangyu.xyz/interview/experience/yuanbaoshuke/",
      "content_html": "<h2 id=\"简介\"> 简介</h2>\n<p>简历筛选：一天。</p>\n<h2 id=\"视频面试\"> 视频面试</h2>\n<h3 id=\"一面\"> 一面</h3>\n<ol>\n<li>自我介绍</li>\n<li>常见的排序算法有哪些，时间复杂度是多少，为什么时间复杂度是这个</li>\n<li>Linux 进程间通讯方式</li>\n<li>设计模式的六大原则，举例</li>\n<li>什么是内存泄漏和内存溢出</li>\n<li>介绍一下可达性算法</li>\n<li>相比引用计数法，可达性算法为什么不会出现相互引用无法回收的情况</li>\n<li>双亲委派机制</li>\n<li>为什么 Java 要这么费劲的弄个双亲委派机制，直接动态修改 classpath 加载类不好吗</li>\n<li><code>ThreadLocal</code> 原理，<code>ThreadLocal</code> 的内存泄露</li>\n<li>MySQL 索引的最左匹配原则</li>\n<li>重放攻击</li>\n<li>TCP/IP 五层模型</li>\n<li>两道算法题：</li>\n</ol>\n<ul>\n<li><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\" target=\"_blank\" rel=\"noopener noreferrer\">21. 合并两个有序链表</a></li>\n<li>删除 json 字符串中的空值</li>\n</ul>\n<h2 id=\"总结\"> 总结</h2>\n<p>面试官不错，整体的面试过程是循序渐进的、有引导的。这是刚开始面试时找的一个公司，准备的不太充分，一面挂了。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🍁 Dubbo",
      "url": "https://blog.lixiangyu.xyz/interview/framework/communication/dubbo/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/communication/dubbo/",
      "content_html": "<h2 id=\"什么是-dubbo\"> 什么是 Dubbo？</h2>\n<p>Dubbo 是阿里开源的高性能 RPC 分布式服务框架。</p>\n<h2 id=\"dubbo-服务治理的逻辑\"> Dubbo 服务治理的逻辑？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/bGE1WX8RKnsVrk9.png\" alt=\"Dubbo服务治理.png\" /></p>\n</div>\n<h2 id=\"dubbo-都支持哪些协议\"> Dubbo 都支持哪些协议？</h2>\n<p>Dubbo 支持 dubbo、rmi、hessian、http、webservice、thrift、redis、rest 等协议。dubbo 协议是推荐使用的，默认使用的协议就是 dubbo 协议，这种协议采用单一长连接和 NIO 异步通讯，适合于小数据量、大并发的服务，或者服务消费者机器数远大于服务提供者机器数的情况。dubbo 协议的缺点是不适合传送大数据量的服务，比如传送文件、视频等，除非请求量很低。</p>\n<h2 id=\"dubbo-有哪几种节点角色\"> Dubbo 有哪几种节点角色？</h2>\n<ul>\n<li>Provider：暴露服务的服务提供方</li>\n<li>Consumer：调用远程服务的服务消费方</li>\n<li>Registry：服务注册与发现中心</li>\n<li>Monitor：监控中心</li>\n<li>Container：服务运行容器</li>\n</ul>\n<h2 id=\"服务注册与发现流程图\"> 服务注册与发现流程图？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/Tql5AeNrvS92MYo.png\" alt=\"Dubbo服务注册与发现.png\" /></p>\n</div>\n<h2 id=\"dubbo-有哪几种集群容错方案\"> Dubbo 有哪几种集群容错方案？</h2>\n<ul>\n<li>failsafe：失败安全，出现错误时直接忽略</li>\n<li>failover（默认）：失败时会自动重试其他服务器</li>\n<li>failfast：快速事变，立即报错，只发起一次调用</li>\n<li>failback：失败后自动恢复，记录失败请求，定时重发</li>\n<li>forking：并行调用一个服务器，只要一个成功就返回</li>\n<li>broadcast：广播并逐个调用服务者，任意一个报错则就失败</li>\n</ul>\n<h2 id=\"dubbo-的负载均衡策略\"> Dubbo 的负载均衡策略？</h2>\n<ul>\n<li>Random LoadBalance：随机，按权重设置随机概率（默认）</li>\n<li>RoundRobin LoadBalance：轮询，按公约后的权重设置轮询比率</li>\n<li>LeastActive LoadBalance：最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差</li>\n<li>ConsistentHash LoadBalance：一致性哈希，相同参数的请求总是发到同一提供者</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/07/31/bGE1WX8RKnsVrk9.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "☘️ 通讯组件 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/framework/communication/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/communication/",
      "content_html": "<p>开发程序离不开通讯，看一下常见的通讯框架：</p>\n<ol>\n<li><a href=\"/interview/framework/communication/netty\">Netty</a>：基于 NIO 的通讯框架，快就完事了</li>\n<li><a href=\"/interview/framework/communication/dubbo\">Dubbo</a>：阿里推出的基于 RPC 的通讯框架</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌻 MyBatis",
      "url": "https://blog.lixiangyu.xyz/interview/framework/mybatis/mybatis/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/mybatis/mybatis/",
      "content_html": "<h2 id=\"xml-配置文件中常用的标签有哪些\"> XML 配置文件中常用的标签有哪些？</h2>\n<ul>\n<li><code>select</code>/<code>insert</code>/<code>update</code>/<code>delete</code>：对应这四种 SQL 语句</li>\n<li><code>sql</code>：可被其他语句引用的可重用语句块，比如表字段</li>\n<li><code>include</code>：引用代码片段</li>\n<li><code>parameterType</code>：限定参数类型</li>\n<li><code>resultType</code>：限定返回结果类型</li>\n<li><code>resultMap</code>：结果集映射</li>\n</ul>\n<p>另外还有动态 sql 标签：<code>trim</code>、<code>where</code>、<code>set</code>、<code>foreach</code>、<code>if</code>、<code>choose</code>、<code>when</code>、<code>otherwise</code>、<code>bind</code>。</p>\n<h2 id=\"mybatis-的动态-sql\"> MyBatis 的动态 SQL？</h2>\n<p>Mybatis 动态 SQL 可以让开发人员在 XML 配置文件中，以标签的形式编写动态 SQL，完成逻辑判断和动态拼接 SQL 的功能，Mybatis 提供了 9 种动态 sql 标签：<code>trim</code>，<code>where</code>，<code>set</code>，<code>foreach</code>，<code>if</code>，<code>choose</code>，<code>when</code>，<code>otherwise</code>，<code>bind</code>。</p>\n<p>执行原理为，使用 OGNL 从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL。</p>\n<h2 id=\"和-的区别\"> #{} 和 ${} 的区别？<i>Not supported content</i></h2>\n<ul>\n<li><code>${}</code> 是 Properties 文件中的变量占位符，它可以用于标签属性值和 SQL 内部，属于静态文本替换，比如 <code>${driver}</code> 会被静态替换为 <code>com.mysql.jdbc.Drive</code></li>\n<li><code>#{}</code> 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 <code>#{}</code> 替换为 <code>?</code>，在 sql 执行前会使用 <code>PreparedStatement</code> 的参数设置方法，按序给 SQL 中的 <code>?</code> 设置参数值，比如 <code>ps.setInt(0, parameterValue)</code>，可以解决 SQL 注入攻击问题</li>\n</ul>\n<h2 id=\"mybatis-是如何将结果封装为对象的\"> MyBatis 是如何将结果封装为对象的？</h2>\n<ol>\n<li>通过 <code>&lt;resultMap&gt;</code> 标签，逐一定义列名和对象属性名之间的映射关系</li>\n<li>使用 SQL 列的别名功能，将列别名书写为对象属性名，比如 <code>T_NAME AS NAME</code>。尽管对象属性名一般是小写，但是 Mybatis 会忽略列名的大小写，智能找到与之对应对象属性名，甚至可以写成 <code>T_NAME AS NaMe</code>，Mybatis 一样可以正常工作</li>\n</ol>\n<p>有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h2 id=\"介绍一下-mapper-接口\"> 介绍一下 Mapper 接口？</h2>\n<p>Mapper 接口会对应一个配置文件，这个配置文件中 <code>namespace</code> 的值，就是接口的全限定名。接口中的方法名，就是配置文件中 <code>MappedStatement</code> 的 id 值，接口方法内的参数，就是传递给 SQL 的参数。</p>\n<p>Mapper 接口是不需要给出实现类的，当调用接口方法时，接口全限定名 + 方法名拼接字符串作为 <code>key</code> 值，可唯一定位一个 <code>MappedStatement</code>，比如根据 <code>mypackage.dao.findUserById</code>，可以唯一找到 <code>namespace</code> 为 <code>mypackage.dao</code> 下面 <code>id = findUserById</code> 的 <code>MappedStatement</code>。</p>\n<p>在运行时，MyBatis 利用 JDK 动态代理，为接口生成代理对象，代理对象会拦截接口方法，转而执行 <code>MappedStatement</code> 所代表的 SQL，然后将 SQL 执行结果返回。</p>\n<div><p>MappedStatement</p>\n<p>在 Mybatis 中，每一个 <code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p>\n</div>\n<div><p>方法不能重载</p>\n<p>这个接口中的方法，是不能重载的，因为是根据全限定名 + 方法名的策略来寻找的。</p>\n</div>\n<h2 id=\"mybatis-插件机制的原理\"> MyBatis 插件机制的原理？</h2>\n<p>Mybatis 仅可以编写针对 <code>ParameterHandler</code>、<code>ResultSetHandler</code>、<code>StatementHandler</code>、<code>Executor</code> 这 4 种接口的插件。Mybatis 使用 JDK 动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法。</p>\n<p>实现 Mybatis 的 <code>Interceptor</code> 接口并重写 <code>intercept()</code> 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法就可以实现一个插件了，不要忘了在配置文件中配置上编写的插件。</p>\n<h2 id=\"mybatis-的分页机制\"> MyBatis 的分页机制？</h2>\n<p>Mybatis 使用 <code>RowBounds</code> 对象进行分页，它是针对 <code>ResultSet</code> 结果集执行的内存分页，而非物理分页，可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>\n<p>分页插件的基本原理是使用 Mybatis 提供的插件接口实现自定义插件，在插件的拦截方法内拦截待执行的 SQL 并重写，添加对应的物理分页语句和物理分页参数。</p>\n<p>举例：<code>select _ from student</code>，拦截 SQL 后重写为：<code>select t._ from (select * from student) t limit 0, 10</code>。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🍀 Netty",
      "url": "https://blog.lixiangyu.xyz/interview/framework/communication/netty/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/communication/netty/",
      "content_html": "<h2 id=\"什么是-netty\"> 什么是 Netty？</h2>\n<ul>\n<li>Netty 是一个基于 NIO 的 client-server（客户端服务器）框架，使用它可以快速简单地开发网络应用程序</li>\n<li>它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程，并且性能以及安全性等很多方面甚至都要更好</li>\n<li>支持多种协议，如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议</li>\n</ul>\n<p>用官方的总结就是：Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发、性能、稳定性和灵活性的方法。</p>\n<h2 id=\"为什么要使用-netty\"> 为什么要使用 Netty？</h2>\n<ul>\n<li>统一的 API，支持多种传输类型，阻塞和非阻塞的</li>\n<li>简单而强大的线程模型</li>\n<li>自带编解码器解决 TCP 粘包/拆包问题</li>\n<li>自带各种协议栈</li>\n<li>真正的无连接数据包套接字支持</li>\n<li>比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制</li>\n<li>安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持</li>\n<li>社区活跃，成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如 Dubbo、RocketMQ 等</li>\n</ul>\n<h2 id=\"netty-有哪些应用场景\"> Netty 有哪些应用场景？</h2>\n<ul>\n<li>作为 RPC 框架的网络通信工具</li>\n<li>作为 HTTP 服务器（可类比 Tomcat）</li>\n<li>实现一个即时通讯软件</li>\n<li>实现消息推送系统</li>\n</ul>\n<h2 id=\"netty-有哪些核心组件\"> Netty 有哪些核心组件？</h2>\n<h3 id=\"channel\"> Channel</h3>\n<p><code>Channel</code> 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，以及 <code>bind()</code>、<code>connect()</code>、<code>read()</code>、<code>write()</code> 操作等。比较常用的 <code>Channel</code> 接口实现类是 <code>NioServerSocketChannel</code>（服务端）和 <code>NioSocketChannel</code>（客户端），这两个 <code>Channel</code> 可以和 BIO 编程模型中的 <code>ServerSocket</code> 以及 <code>Socket</code> 两个概念对应上。Netty 的 <code>Channel</code> 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。</p>\n<h3 id=\"eventloop\"> EventLoop</h3>\n<p><code>EventLoop</code> 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件，主要作用就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。</p>\n<h3 id=\"channelfuture\"> ChannelFuture</h3>\n<p>Netty 是异步非阻塞的，所有的 I/O 操作都是异步的。可以通过 <code>ChannelFuture</code> 接口的 <code>addListener()</code> 方法注册一个 <code>ChannelFutureListener</code>，当操作执行成功或者失败时，监听就会自动返回结果。</p>\n<h3 id=\"channelhandler-和-channelpipeline\"> ChannelHandler 和 ChannelPipeline</h3>\n<p><code>ChannelHandler</code> 是消息的具体处理器，它负责处理读写操作、客户端连接等事情。<code>ChannelPipeline</code> 为 <code>ChannelHandler</code> 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 <code>Channel</code> 被创建时，它会被自动地分配到它专属的 <code>ChannelPipeline</code>，再通过 <code>addLast()</code> 方法添加一个或者多个 <code>ChannelHandler</code>，因为一个数据或者事件可能会被多个 <code>Handler</code> 处理。当一个 <code>ChannelHandler</code> 处理完之后就将数据交给下一个 <code>ChannelHandler</code>。</p>\n<h2 id=\"什么是-eventloopgroup\"> 什么是 EventLoopGroup？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/ihueo5ZHfASXItr.png\" alt=\"EventLoopGroup.png\" /></p>\n</div>\n<p><code>EventLoopGroup</code> 包含多个 <code>EventLoop</code>，<code>EventLoop</code> 处理的 I/O 事件都将在它专有的 <code>Thread</code> 上被处理，即 <code>Thread</code> 和 <code>EventLoop</code> 属于 <code>1 : 1</code> 的关系，从而保证线程安全。上图是一个服务端使用 <code>EventLoopGroup</code> 的模块图，其中 <code>Boss EventloopGroup</code> 用于接收连接，<code>Worker EventloopGroup</code> 用于具体的处理（消息的读写以及其他逻辑处理）。</p>\n<p>当客户端通过 <code>connect()</code> 方法连接服务端时，<code>bossGroup</code> 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 <code>workerGroup</code> 来处理，然后 <code>workerGroup</code> 负责处理其 I/O 相关操作。</p>\n<h2 id=\"什么是-bootstrap-和-serverbootstrap\"> 什么是 Bootstrap 和 ServerBootstrap？</h2>\n<p><code>Bootstrap</code> 是客户端的启动引导类/辅助类，<code>ServerBootstrap</code> 是客户端的启动引导类/辅助类。区别：</p>\n<ul>\n<li><code>Bootstrap</code> 通常使用 <code>connect()</code> 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。但是它也可以通过 <code>bind()</code> 方法绑定本地的一个端口，作为 UDP 协议通信中的一端</li>\n<li><code>ServerBootstrap</code> 通常使用 <code>bind()</code> 方法绑定本地的端口上，然后等待客户端的连接</li>\n<li><code>Bootstrap</code> 只需要配置一个线程组，而 <code>ServerBootstrap</code> 需要配置两个线程组，一个用于接收连接（<code>bossGroup</code>），一个用于具体的处理（<code>workerGroup</code>）</li>\n</ul>\n<h2 id=\"nioeventloopgroup-的默认构造函数会启动多少个线程\"> NioEventLoopGroup 的默认构造函数会启动多少个线程？</h2>\n<p>默认数量为 CPU 核心数 * 2。</p>\n<h2 id=\"介绍一下-netty-的线程模型\"> 介绍一下 Netty 的线程模型？<i>Not supported content</i></h2>\n<h3 id=\"单线程模型\"> 单线程模型</h3>\n<p>一个线程需要执行处理所有的 <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。对于高负载、高并发，并且对性能要求比较高的场景不适用。</p>\n<h3 id=\"多线程模型\"> 多线程模型</h3>\n<p>一个 <code>Acceptor</code> 线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： <code>accept</code>、<code>read</code>、<code>decode</code>、<code>process</code>、<code>encode</code>、<code>send</code> 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/jLMVbGTH3Dw6qlP.png\" alt=\"Netty多线程模型.png\" /></p>\n</div>\n<h3 id=\"主从多线程模型\"> 主从多线程模型</h3>\n<p>从一个主线程 NIO 线程池中选择一个线程作为 <code>Acceptor</code> 线程，绑定监听端口接收客户端的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足需求，可以考虑使用主从多线程模型。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/LbNd4cTRja1SHvU.png\" alt=\"Netty主从多线程模型.png\" /></p>\n</div>\n<h2 id=\"netty-服务端的启动过程\"> Netty 服务端的启动过程？</h2>\n<ul>\n<li>创建两个 <code>NioEventLoopGroup</code> 对象实例：<code>bossGroup</code> 和 <code>workerGroup</code></li>\n<li>创建服务端启动引导/辅助类：<code>ServerBootstrap</code>，这个类将引导服务端的启动工作</li>\n<li>给引导类配置上面示例化的两大线程组，确定了线程模型</li>\n<li>给引导类指定 I/O 模型为 NIO</li>\n<li>给引导类指定 <code>ChannelInitializer</code>，指定 <code>ChannelPipeline</code> 和 <code>ChannelHandler</code> 的初始化方式</li>\n<li>通过引导类绑定端口</li>\n</ul>\n<h2 id=\"netty-客户端的启动过程\"> Netty 客户端的启动过程？</h2>\n<ul>\n<li>创建一个 <code>NioEventLoopGroup</code> 对象</li>\n<li>创建客户端启动引导类：<code>Bootstrap</code></li>\n<li>给引导类 <code>Bootstrap</code> 配置一个线程组</li>\n<li>给引导类 <code>Bootstrap</code> 指定了 I/O 模型为 NIO</li>\n<li>给引导类配置 <code>ChannelInitializer</code>，指定 <code>ChannelPipeline</code> 和 <code>ChannelHandler</code> 的初始化方式</li>\n<li>调用 <code>Bootstrap</code> 类的 <code>connect()</code> 方法进行连接，参数为 IP 地址和端口号</li>\n</ul>\n<h2 id=\"什么是-tcp-粘包-拆包\"> 什么是 TCP 粘包/拆包？</h2>\n<p>TCP 粘包/拆包指的：基于 TCP 发送数据的时候，出现了多个字符串“粘”在了一起或者一个字符串被“拆”开的问题。</p>\n<h2 id=\"netty-怎么解决的-tcp-粘包-拆包问题\"> Netty 怎么解决的 TCP 粘包/拆包问题？</h2>\n<p>使用 Netty 自带的解码器：</p>\n<ul>\n<li><code>LineBasedFrameDecoder</code>：发送端发送数据包的时候，每个数据包之间以换行符作为分隔，<code>LineBasedFrameDecoder</code> 会遍历判断是否有换行符，然后进行相应的截取</li>\n<li><code>DelimiterBasedFrameDecoder</code>：自定义分隔符解码器，<code>LineBasedFrameDecoder</code> 实际上是一种特殊的 <code>DelimiterBasedFrameDecoder</code> 解码器</li>\n<li><code>FixedLengthFrameDecoder</code>：固定长度解码器，它能够按照指定的长度对消息进行相应的拆包</li>\n<li><code>LengthFieldBasedFrameDecoder</code>：自定义长度解码器</li>\n</ul>\n<h2 id=\"介绍一下-netty-的心跳机制\"> 介绍一下 Netty 的心跳机制？</h2>\n<p>在 TCP 保持长连接的过程中，可能会出现断网或者其他的引起网络异常的情况，在异常发生的时候，如果客户端与服务端之间没有交互的话，它们彼此是无法发现对方已经掉线的。为了解决这个问题, 需要引入心跳机制。</p>\n<p>心跳机制的工作原理是：当客户端与服务端在一定时间内没有数据交互时，客户端或服务器就会发送一个特殊的数据包给对方，当接收方收到这个数据报文后，也立即发送一个特殊的数据报文进行回应。所以当某一端收到心跳消息后，就知道了对方仍然在线，确保了 TCP 连接的有效性。通过 Netty 实现心跳机制的核心类是 <code>IdleStateHandler</code>。</p>\n<h2 id=\"介绍一下-netty-的零拷贝机制\"> 介绍一下 Netty 的零拷贝机制？</h2>\n<p>在操作系统层面，<strong>零拷贝通常指避免在用户态与内核态之间来回拷贝数据</strong>。而在 Netty 层面，零拷贝主要体现在对于数据操作的优化：</p>\n<ul>\n<li>使用 Netty 提供的 <code>CompositeByteBuf</code> 类, 可以将多个 <code>ByteBuf</code> 合并为一个逻辑上的 <code>ByteBuf</code>，避免了各个 <code>ByteBuf</code> 之间的拷贝</li>\n<li><code>ByteBuf</code> 支持 <code>slice</code> 操作，因此可以将 <code>ByteBuf</code> 分解为多个共享同一个存储区域的 <code>ByteBuf</code>，避免了内存的拷贝</li>\n<li>通过 <code>FileRegion</code> 包装的 <code>FileChannel.transferTo</code> 实现文件传输，可以直接将文件缓冲区的数据发送到目标 <code>Channel</code>，避免了传统通过循环 <code>write</code> 方式导致的内存拷贝问题</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/07/31/ihueo5ZHfASXItr.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 框架使用 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/framework/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/",
      "content_html": "<p>框架相关的内容问的较少，整理一下常用框架的知识点：</p>\n<ol>\n<li><a href=\"/interview/framework/spring/\">Spring 全家桶</a>：没的说，开发必用框架</li>\n<li><a href=\"/interview/framework/mybatis/\">MyBatis</a>：一个操作数据库的半 ORM 框架，因为比较灵活，更适合国内互联网公司使用</li>\n<li><a href=\"/interview/framework/communication/\">通讯</a>：通讯相关的组件</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌼 MyBatis 框架 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/framework/mybatis/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/mybatis/",
      "content_html": "<p>MyBatis 是一个半 ORM 框架，以为其灵活性收到国内互联网公司的欢迎。本部分包含以下内容：</p>\n<ol>\n<li><a href=\"/interview/framework/mybatis/mybatis\">MyBatis</a>：整理 MyBatis 常见问题</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "💐 Spring 全家桶 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/framework/spring/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/spring/",
      "content_html": "<p>Spring 是 Java 开发人员必用的框架之一，大的来说，Spring 家族包含以下几个成员：</p>\n<ol>\n<li><a href=\"/interview/framework/spring/spring\">Spring</a>：Spring 最核心的功能</li>\n<li><a href=\"/interview/framework/spring/spring-mvc\">Spring MVC</a>：用于 web 的框架</li>\n<li><a href=\"/interview/framework/spring/springboot\">Spring Boot</a>：为了简化开发流程而提出的一个框架</li>\n<li><a href=\"/interview/framework/spring/springcloud\">Spring Cloud</a>：用于微服务开发的框架</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌳 SpringMVC",
      "url": "https://blog.lixiangyu.xyz/interview/framework/spring/spring-mvc/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/spring/spring-mvc/",
      "content_html": "<h2 id=\"spring-mvc-的请求流程\"> Spring MVC 的请求流程？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/7Po6lweIR3ntqsy.png\" alt=\"SpringMVC流程图.jpg\" /></p>\n</div>\n<div><p>基本不会有视图渲染的过程</p>\n<p>由于现在基本都是前后端分离开发，所以上图已经不适用了。步骤 7 就会返回最终结果，不再需要后续的视图解析与渲染。</p>\n</div>\n<h2 id=\"restcontroller-和-controller-注解有什么区别\"> @RestController 和 @Controller 注解有什么区别？</h2>\n<h3 id=\"使用-controller-注解\"> 使用 @Controller 注解</h3>\n<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code> 注解一般使用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。如果需要在 Spring4 之前开发 RESTFul Web 服务的话，需要使用 <code>@Controller</code> 并结合 <code>@ResponseBody</code> 注解，也就是说 <code>@Controller + @ResponseBody = @RestController</code>（Spring 4 之后新加的注解）。</p>\n<h3 id=\"使用-restcontroller-注解\"> 使用 @RestController 注解</h3>\n<p><code>@RestController</code> 只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP Response 中，这种情况属于 RESTFul Web 服务，这也是目前日常开发所接触的最常用的情况。</p>\n<h2 id=\"cookie-和-session\"> Cookie 和 Session</h2>\n<h3 id=\"什么是-cookie\"> 什么是 Cookie？</h3>\n<p>Cookie 一般用来保存用户信息，比如：</p>\n<ul>\n<li>替用户填入基本信息</li>\n<li>保存用户的登录状态（一般是一个 token）</li>\n</ul>\n<h3 id=\"什么是-session\"> 什么是 Session？</h3>\n<p>Session 的主要作用是通过服务端记录用户的状态。因为 HTTP 协议是无状态的，服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>\n<h3 id=\"cookie-和-session-的区别\"> Cookie 和 Session 的区别？</h3>\n<p>Cookie 数据保存在客户端，Session 数据保存在服务器端，所以相对来说 Session 安全性更高，最好不要在 Cookie 中保存敏感信息。Cookie 可以手动设置过期时间，Session 在关闭浏览器后就关闭了。</p>\n",
      "image": "https://i.loli.net/2021/07/31/7Po6lweIR3ntqsy.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌴 SpringBoot",
      "url": "https://blog.lixiangyu.xyz/interview/framework/spring/springboot/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/spring/springboot/",
      "content_html": "<h2 id=\"为什么要使用-spring-boot\"> 为什么要使用 Spring Boot？</h2>\n<ul>\n<li>简化配置和开发的流程</li>\n<li>简化部署流程</li>\n<li>使用注解替代 XML</li>\n<li>提供运行中应用状态的监控</li>\n</ul>\n<h2 id=\"什么是-spring-boot-starter\"> 什么是 Spring Boot Starter？</h2>\n<p>Starter 可以理解成配置了一堆 jar 组合的空 maven 项目，用来简化 maven 依赖配置，starter 可以继承也可以依赖于别的 starter。</p>\n<h2 id=\"springboot-支持哪些嵌入式-servlet-容器\"> SpringBoot 支持哪些嵌入式 Servlet 容器？</h2>\n<ul>\n<li>Tomcat</li>\n<li>Jetty</li>\n<li>Undertow</li>\n</ul>\n<h2 id=\"在-springboot-中怎么切换嵌入式-servlet-容器\"> 在 SpringBoot 中怎么切换嵌入式 Servlet 容器？</h2>\n<p>修改 pom.xml：</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-web<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n    <span><span><span>&lt;</span>exclusions</span><span>></span></span>\n        <span><span><span>&lt;</span>exclusion</span><span>></span></span>\n            <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n            <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-tomcat<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n        <span><span><span>&lt;/</span>exclusion</span><span>></span></span>\n    <span><span><span>&lt;/</span>exclusions</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n<span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-jetty<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id=\"介绍一下-springbootapplication-注解\"> 介绍一下 @SpringBootApplication 注解？</h2>\n<p>使用这个注解可以配置 SpringBoot 项目的启动类。这个注解继承了 <code>@SpringBootConfiguration</code>，<code>@EnableAutoConfiguration</code>，<code>@ComponentScan</code> 注解。</p>\n<ul>\n<li><code>@SpringBootConfiguration</code>：这个注解继承了 <code>@Configuration</code> 注解，表明这是一个配置类</li>\n<li><code>@EnableAutoConfiguration</code>：启用自动配置</li>\n<li><code>@ComponentScan</code>：配置注解扫描的包</li>\n</ul>\n<h2 id=\"springboot-是怎么实现自动配置的\"> SpringBoot 是怎么实现自动配置的？</h2>\n<p><code>@SpringBootApplication</code> 继承了 <code>@EnableAutoConfiguration</code> 注解，在这个注解中，有一行：<code>@Import(AutoConfigurationImportSelector.class)</code>。查看这个类的代码，它会调用 <code>getCandidateConfigurations()</code> 函数。这个函数内部通过 <code>SpringFactoriesLoader.loadFactoryNames()</code> 获取配置信息。它会根据相应的 starter 的 spring.factories 文件加载配置，在这个文件里面保存了要加载的配置类。比如：</p>\n<div><pre><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\n...\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在这些配置类上配置 <code>@Conditional</code> 注解，可以根据指定的情况动态加载配置。</p>\n<h2 id=\"springboot-项目使用的配置文件有什么格式\"> SpringBoot 项目使用的配置文件有什么格式？</h2>\n<p>可以使用 <code>yaml/yml</code> 或者 <code>properties</code> 格式的配置文件，通过配置项 <code>spring.profiles.active</code> 还可以根据不同的环境指定具体是哪个配置文件生效。</p>\n<div><p>boostrap.yml</p>\n<p>SpringBoot 除了有 <code>application.yml</code> 配置文件以外，还可以使用 <code>boostrap.yml</code> 进行配置。在启动顺序上，<code>bootstrap.yml</code> 文件会优先加载，用于应用程序上下文的引导阶段。</p>\n</div>\n<h2 id=\"springboot-加载配置文件的顺序是怎样的\"> SpringBoot 加载配置文件的顺序是怎样的？</h2>\n<p>SpringBoot 会从以下四个位置加载配置文件，越上的优先级越高：</p>\n<ul>\n<li>项目根路径 config 目录中的 <code>application.yml</code> 文件</li>\n<li>项目根路径中的 <code>application.yml</code> 文件</li>\n<li>resources 目录下 config 目录中的 <code>application.yml</code> 文件</li>\n<li>resources 目录下的 <code>application.yml</code> 文件</li>\n</ul>\n<h2 id=\"springboot-读取配置文件有哪几种方式\"> SpringBoot 读取配置文件有哪几种方式？</h2>\n<h3 id=\"使用-value-注解\"> 使用 @Value 注解</h3>\n<div><pre><code><span>@Value</span><span>(</span><span>\"${security.token}\"</span><span>)</span>\n<span>private</span> <span>String</span> token\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"使用-configurationproperties-注解\"> 使用 @ConfigurationProperties 注解</h3>\n<p>使用 <code>@ConfigurationProperties</code> 注解可以加载一组属性的值。对于要加载的属性过多的情况，使用这个注解比 <code>@Value</code> 更加简洁。通过定义静态内部类可以获得某个配置项的子配置项。</p>\n<div><pre><code><span>@ConfigurationProperties</span><span>(</span>prefix <span>=</span><span>\"config\"</span><span>)</span>  \n<span>public</span> <span>class</span> <span>Config</span> <span>{</span>\n    <span>// 获取 config.token 的值</span>\n    <span>private</span> <span>String</span> token<span>;</span>\n  \n    <span>// 获取 config.username 的值</span>\n    <span>private</span> <span>String</span> username<span>;</span>\n    \n    <span>// 定义子配置项，即 config.subconfig</span>\n    <span>public</span> <span>static</span> <span>class</span> <span>SubConfig</span> <span>{</span>\n        <span>// 获取 congfig.subconfig.subConfigToken 的值</span>\n        <span>private</span> <span>String</span> subConfigToken<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id=\"读取指定文件中的内容\"> 读取指定文件中的内容</h3>\n<p>使用 <code>@PropertySource</code> 指定要加载的文件，再配合 <code>@Value</code> 或者 <code>@ConfigurationProperties</code> 注解加载属性值。</p>\n<h3 id=\"使用-environment-接口获取配置\"> 使用 Environment 接口获取配置</h3>\n<p>参考：<a href=\"/interview/framework/spring/spring/#bean-的生命周期\">Bean 的生命周期</a></p>\n<h2 id=\"开发-restful-web-程序常用的注解有哪些\"> 开发 RESTFul Web 程序常用的注解有哪些？</h2>\n<ul>\n<li><code>@SpringBootApplication</code>：启动类</li>\n<li><code>@RestController</code>：控制器注解</li>\n<li><code>@xxMapping</code>：指定访问的 url 以及请求类型</li>\n<li><code>@Service</code>：服务层注解</li>\n<li><code>@Repository</code>：DAO 层注解</li>\n<li><code>@Component</code>：Bean 注解</li>\n<li><code>@Bean</code>：Bean 注解</li>\n<li><code>@Configuration</code>：配置类注解</li>\n<li><code>@MapperScan</code>：指定 Mybatis 接口类扫描路径</li>\n<li><code>@Value</code>：通过 SpEL 表达式获取 Environment 中的值</li>\n<li><code>@Valid</code>：SpringBoot 校验</li>\n</ul>\n<h2 id=\"怎么通过-springboot-进行运行状态监控\"> 怎么通过 SpringBoot 进行运行状态监控？</h2>\n<p>SpringBoot 的 <code>Actuator</code> 提供了运行状态监控的功能，<code>Actuator</code> 的监控数据可以通过 REST、远程 shell 和 JMX 方式获得。</p>\n<h2 id=\"springboot-怎么对数据做校验\"> SpringBoot 怎么对数据做校验？</h2>\n<p>引入 <code>Validation</code> 库：</p>\n<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>\n    <span><span><span>&lt;</span>groupId</span><span>></span></span>org.springframework.boot<span><span><span>&lt;/</span>groupId</span><span>></span></span>\n    <span><span><span>&lt;</span>artifactId</span><span>></span></span>spring-boot-starter-validation<span><span><span>&lt;/</span>artifactId</span><span>></span></span>\n<span><span><span>&lt;/</span>dependency</span><span>></span></span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"springboot-的全局异常处理\"> SpringBoot 的全局异常处理？</h2>\n<p>新建一个类使用 <code>@ControllerAdvice</code> 注解标注，对于其中的方法，使用 <code>@ExceptionHandler(value = xx.class)</code> 注解标注。</p>\n<h2 id=\"springboot-实现定时任务\"> SpringBoot 实现定时任务？</h2>\n<ul>\n<li>使用 <code>java.util.Timer</code></li>\n<li>使用 <code>Quartz</code> 等第三方库</li>\n<li>使用 <code>@Schedule</code> 注解</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌲 Spring",
      "url": "https://blog.lixiangyu.xyz/interview/framework/spring/spring/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/spring/spring/",
      "content_html": "<h2 id=\"什么是-spring-框架\"> 什么是 Spring 框架？</h2>\n<p>Spring 是一个轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。一般说的 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助开发人员进行开发。</p>\n<p>Spring 框架的特点：</p>\n<ul>\n<li>轻量：Spring 是轻量的</li>\n<li>控制反转：Spring 通过控制反转实现了解耦</li>\n<li>面向切面的编程（AOP）：Spring 支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li>\n<li>容器：Spring 包含并管理应用中对象的生命周期和配置</li>\n<li>MVC 框架：Spring 的 WEB 框架是个精心设计的框架，是 Web 框架的一个很好的替代品</li>\n<li>事务管理：Spring 提供了一个持续的事务管理接口</li>\n<li>异常处理：Spring 提供方便的 API 把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的 unchecked 异常。</li>\n</ul>\n<h2 id=\"spring-有哪些模块\"> Spring 有哪些模块？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/7UEfnFxiscSywvQ.png\" alt=\"Spring模块.png\" /></p>\n</div>\n<h2 id=\"什么是-ioc\"> 什么是 IoC？<i>Not supported content</i></h2>\n<p>IoC（Inverse of Control，控制反转）是一种设计思想，就是将原本在程序中手动创建对象的控制权，交由 Spring 来管理。IoC 在其他语言中也有应用，并非 Spring 特有。IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个 <code>Map</code>，其中存放的是各种对象。IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件或者注解，完全不用考虑对象是如何被创建出来的。Spring 早期版本一般是通过 XML 文件来配置 Bean，目前更为流行的是通过注解来进行配置。</p>\n<h2 id=\"什么是-aop\"> 什么是 AOP？<i>Not supported content</i></h2>\n<p>AOP（Aspect-Oriented Programming，面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。Spring AOP 是基于动态代理实现的，如果要代理的对象实现了某个接口，那么 Spring AOP 会使用 JDKProxy 去创建代理对象，而对于没有实现接口的对象，会使用 CGLib 做代理，如下图所示：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/fnhaAE5dxJw3pq6.png\" alt=\"动态代理.png\" /></p>\n</div>\n<h2 id=\"spring-框架中使用的设计模式\"> Spring 框架中使用的设计模式？<i>Not supported content</i></h2>\n<ul>\n<li>工厂设计模式：Spring 使用工厂模式，通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 Bean</li>\n<li>代理设计模式：Spring AOP 功能的实现</li>\n<li>单例设计模式：Spring 中的 Bean 默认都是单例的</li>\n<li>包装器设计模式：项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库，这种模式可以根据客户的需求能够动态切换不同的数据源</li>\n<li>观察者模式: Spring 事件驱动模型</li>\n<li>适配器模式：Spring AOP 的增强或通知（Advice）使用到了适配器模式，Spring MVC 中也使用到了适配器模式适配 Controller</li>\n</ul>\n<h2 id=\"spring-bean\"> Spring Bean</h2>\n<h3 id=\"component-和-bean-注解的区别\"> @Component 和 @Bean 注解的区别？<i>Not supported content</i></h3>\n<h4 id=\"作用对象不同\"> <strong>作用对象不同</strong></h4>\n<p><code>@Component</code> 注解作用于类，而 <code>@Bean</code> 注解作用于方法。</p>\n<h4 id=\"含义不同\"> <strong>含义不同</strong></h4>\n<p>因为 <code>@Component</code> 注解是作用于类的，所以它通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中的（通过 <code>@ComponentScan</code> 注解定义要扫描的路径）。<code>@Bean</code> 注解作用于方法，它注明了某个方法会产生一个 Bean。</p>\n<h4 id=\"bean-注解能力更强\"> <strong>@Bean 注解能力更强</strong></h4>\n<p>如果需要引用第三方库中的类到 Spring 容器中，那么就只能通过 <code>@Bean</code> 注解来实现。</p>\n<p>下面为两种注解的代码示例：</p>\n<div><pre><code><span>// Bean 注解代码示例</span>\n<span>@Configuration</span>\n<span>public</span> <span>class</span> <span>MyConfiguration</span> <span>{</span>\n    <span>@Bean</span>\n    <span>public</span> <span>MyBean</span> <span>createMyBean</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>new</span> <span>MyBean</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// Component 注解代码示例</span>\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>MyComponent</span> <span>{</span>\n    <span>// fields and functions</span>\n<span>}</span>\n\n<span>@Service</span>\n<span>public</span> <span>class</span> <span>MyService</span> <span>{</span>\n    <span>@Autowried</span>\n    <span>MyComponent</span> myComponent<span>;</span>\n    \n    <span>// fields and functions</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><p>Bean 的装配</p>\n<p>一般使用 <code>@Autowired</code> 注解自动装配 Bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 Bean，除了上面提到的这两种注解以外，还可以使用以下的三个注解。这些注解没有功能上的扩展，只是为了语义清晰：</p>\n<ul>\n<li><code>@Repository</code>: 对应持久层，即 Dao 层，主要用于数据库相关操作</li>\n<li><code>@Service</code>: 对应服务层，主要涉及一些复杂的业务逻辑，需要用到 Dao 层</li>\n<li><code>@Controller</code>: 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</li>\n</ul>\n</div>\n<h3 id=\"bean-的生命周期\"> Bean 的生命周期？<i>Not supported content</i></h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/VtnmjZBhIK6scJM.png\" alt=\"Bean生命周期.jpg\" /></p>\n</div>\n<div><p>@PostConstruct 和 @PreDestroy</p>\n<p><code>@PostConstruct</code> 和 <code>@PreDestroy</code> 注解不是 Spring 提供的注解，而是 javax 包中提供的注解，Spring 支持使用这两个注解。</p>\n</div>\n<p>示例代码如下：</p>\n<div><pre><code><span>// 以下内容为Bean的实现</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span></span><span>BeansException</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span></span><span>*</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>ApplicationContext</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>ApplicationContextAware</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>EnvironmentAware</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>context<span>.</span></span><span>ResourceLoaderAware</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>core<span>.</span>env<span>.</span></span><span>Environment</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>core<span>.</span>env<span>.</span></span><span>PropertySource</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>core<span>.</span>io<span>.</span></span><span>ResourceLoader</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Component</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>web<span>.</span>context<span>.</span>support<span>.</span></span><span>StandardServletEnvironment</span><span>;</span>\n\n<span>import</span> <span>javax<span>.</span>annotation<span>.</span></span><span>PostConstruct</span><span>;</span>\n<span>import</span> <span>javax<span>.</span>annotation<span>.</span></span><span>PreDestroy</span><span>;</span>\n<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>\n\n<span>/**\n * 以下函数的调用顺序与函数编写顺序相同\n *\n * @author lixiangyu\n */</span>\n<span>@Component</span><span>(</span><span>\"MyBean\"</span><span>)</span>\n<span>public</span> <span>class</span> <span>MyBean</span> <span>implements</span> <span>InitializingBean</span><span>,</span> <span>DisposableBean</span><span>,</span> <span>ApplicationContextAware</span><span>,</span> <span>BeanFactoryAware</span><span>,</span>\n        <span>BeanClassLoaderAware</span><span>,</span> <span>BeanNameAware</span><span>,</span> <span>EnvironmentAware</span><span>,</span> <span>ResourceLoaderAware</span> <span>{</span>\n    <span>/**\n     * 获取Bean名称\n     *\n     * @param s 名称\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setBeanName</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"bean name is: \"</span> <span>+</span> s<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取类加载器\n     *\n     * @param classLoader 类加载器\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setBeanClassLoader</span><span>(</span><span>ClassLoader</span> classLoader<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"class loader: \"</span> <span>+</span> classLoader<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取Bean Factory\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setBeanFactory</span><span>(</span><span>BeanFactory</span> beanFactory<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"set bean factory... \"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取运行时环境变量\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setEnvironment</span><span>(</span><span>Environment</span> environment<span>)</span> <span>{</span>\n        <span>// 这里是在获取nacos中的配置项并转为Map</span>\n        <span>PropertySource</span><span><span>&lt;</span><span>?</span><span>></span></span> propertySource\n                <span>=</span> <span>(</span><span>(</span><span>StandardServletEnvironment</span><span>)</span> environment<span>)</span><span>.</span><span>getPropertySources</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>\"demo.yaml|DEFAULT_GROUP|||192.168.4.185:8848|||||||\"</span><span>)</span><span>;</span>\n        <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> obj <span>=</span> <span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span><span>)</span> propertySource<span>.</span><span>getSource</span><span>(</span><span>)</span><span>;</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>obj<span>)</span><span>;</span>\n\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"set environment...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取资源加载器\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setResourceLoader</span><span>(</span><span>ResourceLoader</span> resourceLoader<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"set resource loader...\"</span> <span>+</span> resourceLoader<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 获取上下文\n     *\n     * @param applicationContext 上下文\n     * @throws BeansException beansException\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>setApplicationContext</span><span>(</span><span>ApplicationContext</span> applicationContext<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"set application context...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// ------ Bean Post Processor begin -----------</span>\n    <span>// 在这里会调用postProcessBeforeInitialization方法</span>\n\n    <span>/**\n     * 在类实例化并且设置完属性后调用\n     */</span>\n    <span>@PostConstruct</span>\n    <span>public</span> <span>void</span> <span>postConstruct</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"postConstruct...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * 初始化方法\n     *\n     * @throws Exception 异常\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>afterPropertiesSet</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after properties set...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>// 在这里会调用postProcessAfterInitialization方法</span>\n    <span>// ------ Bean Post Processor end ------------</span>\n\n    <span>/**\n     * Bean销毁时执行的方法\n     */</span>\n    <span>@PreDestroy</span>\n    <span>public</span> <span>void</span> <span>preDestroy</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"pre destroy...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>/**\n     * Bean销毁时执行的方法\n     *\n     * @throws Exception 异常\n     */</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>destroy</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"destroy...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>// 以下内容为后置处理器BeanPostProcessor的实现</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span></span><span>BeansException</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>beans<span>.</span>factory<span>.</span>config<span>.</span></span><span>BeanPostProcessor</span><span>;</span>\n<span>import</span> <span>org<span>.</span>springframework<span>.</span>stereotype<span>.</span></span><span>Component</span><span>;</span>\n\n<span>@Component</span>\n<span>public</span> <span>class</span> <span>MyBeanPostProcessor</span> <span>implements</span> <span>BeanPostProcessor</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>postProcessBeforeInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        <span>if</span> <span>(</span>bean <span>instanceof</span> <span>MyBean</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"bean post process before init...  \"</span> <span>+</span> bean <span>+</span> <span>\" \"</span> <span>+</span> beanName<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>BeanPostProcessor</span><span>.</span><span>super</span><span>.</span><span>postProcessBeforeInitialization</span><span>(</span>bean<span>,</span> beanName<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>@Override</span>\n    <span>public</span> <span>Object</span> <span>postProcessAfterInitialization</span><span>(</span><span>Object</span> bean<span>,</span> <span>String</span> beanName<span>)</span> <span>throws</span> <span>BeansException</span> <span>{</span>\n        <span>if</span> <span>(</span>bean <span>instanceof</span> <span>MyBean</span><span>)</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"bean post process after init...  \"</span> <span>+</span> bean <span>+</span> <span>\" \"</span> <span>+</span> beanName<span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> <span>BeanPostProcessor</span><span>.</span><span>super</span><span>.</span><span>postProcessAfterInitialization</span><span>(</span>bean<span>,</span> beanName<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br></div></div><h3 id=\"bean-的作用域有哪些\"> Bean 的作用域有哪些？<i>Not supported content</i></h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Singleton</td>\n<td style=\"text-align:center\">单例，Spring 中的 Bean 默认都是单例的。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Prototype</td>\n<td style=\"text-align:center\">每次请求都会创建一个新的 Bean 实例。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Request</td>\n<td style=\"text-align:center\">每个 HTTP 请求都会产生一个新的 Bean，这个 Bean 仅在当前 HTTP request 内有效。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Session</td>\n<td style=\"text-align:center\">每个 HTTP 请求都会产生一个新的 Bean，这个 Bean 仅在当前 HTTP session 内有效。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Global-Session</td>\n<td style=\"text-align:center\">全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件，它们基于 Portlet 容器，可以像 servlet 一样处理 HTTP 请求，但是与 servlet 不同的是每个 portlet 都有不同的会话。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"常见的-bean-转换工具有哪些\"> 常见的 Bean 转换工具有哪些？</h3>\n<p>推荐使用 <code>MapStruct</code>（编译时生成接口的实现类），<code>ModelMapper</code>（反射）。或者使用 Spring 提供的 <code>BeanUtils</code> 类（可能会有问题）。</p>\n<div><p>不用使用 Apache 提供的 BeanUtils 类</p>\n<p>阿里编程规范不推荐使用 Apache 提供的 <code>BeanUtils</code> 类，因为存在性能问题（存在大量的校验和日志记录）。</p>\n</div>\n<h3 id=\"beanfactory-和-factorybean-有哪些区别\"> BeanFactory 和 FactoryBean 有哪些区别？</h3>\n<p><code>BeanFactory</code> 是接口，是 Spring 给 IoC 容器定义的一套完整的规范。<code>BeanFactory</code> 的实现类包括：</p>\n<ul>\n<li><code>AbstractBeanFactory</code>：抽象 Bean 工厂，绝大部分的实现类都是继承于他</li>\n<li><code>DefaultListableBeanFactory</code>：Spring 默认的工厂类</li>\n<li><code>XmlBeanFactory</code>：早期使用 XML 文件配置时所使用的 Bean 工厂</li>\n<li><code>AbstractXmlApplicationContext</code>：抽象应用容器上下文对象</li>\n<li><code>ClassPathXmlApplicationContext</code>：XML 解析上下文对象</li>\n</ul>\n<p><code>FactoryBean</code> 是 Spring IoC 容器创建 Bean 的一种形式，融合了简单工厂设计模式与装饰器模式。</p>\n<h3 id=\"spring-的三级缓存\"> Spring 的三级缓存？<i>Not supported content</i></h3>\n<p>在代码中有时可能会出现循环依赖，循环依赖是指是指 A 对象需要 B 对象，B 对象又需要 A 对象。比如下面这样：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>A</span> <span>{</span>\n    <span>private</span> <span>B</span> b<span>;</span>\n \n    <span>public</span> <span>A</span><span>(</span><span>B</span> b<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>b <span>=</span> b<span>;</span>\n    <span>}</span>\n<span>}</span>\n \n<span>public</span> <span>class</span> <span>B</span> <span>{</span>\n    <span>private</span> <span>A</span> a<span>;</span>\n \n    <span>public</span> <span>B</span><span>(</span><span>A</span> a<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>a <span>=</span> a<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>如果碰到这种情况，那么实例化时必然会陷入死循环，因此 Spring 使用三级缓存来解决循环依赖这一问题。</p>\n<ul>\n<li><code>Map&lt;String, Object&gt; singletonObjects</code>：第一级缓存，用来存放已经完全创建好的单例 Bean，映射关系为 <code>beanName -&gt; Bean</code> 实例。</li>\n<li><code>Map&lt;String, Object&gt; earlySingletonObjects</code>：第二级缓存，用来存放半成品的 Bean，映射关系为 <code>beanName -&gt; Bean</code> 实例。</li>\n<li><code>Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories</code>：第三级缓存，用来存放单例 Bean 的 <code>ObjectFactory</code>，映射关系为 <code>beanName -&gt; ObjectFactory</code> 实例。</li>\n</ul>\n<p>还是以上面的 A 和 B 两个类为例，对创建过程详细的描述一下：</p>\n<ul>\n<li>首先创建 A，此时三级缓存中都没有 A，将 A 扔到一个集合中，这个集合的名称叫做：<code>singletonsCurrentlyInCreation</code>，表示它们正处于创建状态</li>\n<li>对 A 做实例化，并放到第三级缓存中</li>\n<li>为 A 注入对象，发现需要 B</li>\n<li>从三级缓存中查找 B，发现都没有 B，将 B 放到 <code>singletonsCurrentlyInCreation</code> 中</li>\n<li>对 B 做实例化，并放到第三级缓存中</li>\n<li>为 B 注入对象，发现需要 A</li>\n<li>将 A 从第三级缓存移动到第二级缓存，并返回给 B 做填充，但此时 A 只是个半成品，它的属性还没有填充完</li>\n<li>B 创建完毕，从第三级缓存移动到第一级缓存</li>\n<li>将 B 返回给 A，A 将 B 填充，A 创建完成</li>\n<li>判断最后创建好的 A 和 B 中填充的 A 是不是一个对象，如果不是则抛出异常</li>\n</ul>\n<h2 id=\"spring-事务\"> Spring 事务</h2>\n<h3 id=\"管理事务的两种方式\"> 管理事务的两种方式？</h3>\n<ul>\n<li>编程式事务，在代码中硬编码（不推荐使用）</li>\n<li>声明式事务，在配置文件中配置（推荐使用），包括基于 XML 的声明式事务和基于注解的声明式事务</li>\n</ul>\n<h3 id=\"事务隔离级别有哪些\"> 事务隔离级别有哪些？</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">TransactionDefinition.ISOLATION_DEFAULT</td>\n<td style=\"text-align:center\">使用后端数据库默认的隔离级别，MySQL 默认采用的 REPEATABLE_READ。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TransactionDefinition.ISOLATION_READ_UNCOMMITTED</td>\n<td style=\"text-align:center\">最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读和不可重复读。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TransactionDefinition.ISOLATION_READ_COMMITTED</td>\n<td style=\"text-align:center\">允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读仍有可能发生。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TransactionDefinition.ISOLATION_REPEATABLE_READ</td>\n<td style=\"text-align:center\">对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TransactionDefinition.ISOLATION_SERIALIZABLE</td>\n<td style=\"text-align:center\">最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"事务的传播方式有哪几种\"> 事务的传播方式有哪几种？</h3>\n<p>事务传播行为（Propagation Behavior）指的是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。例如：方法 A 调用方法 B 时，方法 B 是继续在调用者方法 A 的事务中运行，还是为自己开启一个新事务运行，这就是由方法 B 的事务传播行为决定的。</p>\n<p>Spring 支持以下 7 种事务传播方式：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_REQUIRED</td>\n<td style=\"text-align:center\">如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_SUPPORTS</td>\n<td style=\"text-align:center\">如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_MANDATORY</td>\n<td style=\"text-align:center\">如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_REQUIRES_NEW</td>\n<td style=\"text-align:center\">创建一个新的事务，如果当前存在事务，则把当前事务挂起</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_NOT_SUPPORTED</td>\n<td style=\"text-align:center\">以非事务方式运行，如果当前存在事务，则把当前事务挂起</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_NEVER</td>\n<td style=\"text-align:center\">以非事务方式运行，如果当前存在事务，则抛出异常</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">PROPAGATION_NESTED</td>\n<td style=\"text-align:center\">如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"哪些方法可以开启事务\"> 哪些方法可以开启事务？</h3>\n<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 <code>public</code> 方法将都具有该类型的事务属性，可以在方法上再次使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会导致回滚。</p>\n<h3 id=\"什么情况下会导致事务回滚\"> 什么情况下会导致事务回滚？</h3>\n<p>在 <code>@Transactional</code> 注解中如果不配置 <code>rollbackFor</code> 属性，那么事务只会在遇到 <code>RuntimeException</code> 的时候才会回滚，加上 <code>rollbackFor=Exception.class</code> 可以让事务在遇到非运行时异常时也回滚。</p>\n<h3 id=\"在什么场景下会导致事务失效\"> 在什么场景下会导致事务失效？</h3>\n<ul>\n<li>数据库引擎不支持事务，比如 MyISAM</li>\n<li>使用 <code>@Transactional</code> 标注的类没有被 Spring 容器管理</li>\n<li>方法的修饰符不是 <code>public</code></li>\n<li>自调用问题</li>\n<li>数据源没有配置事务管理器</li>\n<li>事务传播级别为：<code>PROPAGATION_NOT_SUPPORTED</code></li>\n<li>没有添加 <code>rollbackFor=Exception.class</code></li>\n<li>使用 <code>try-catch</code> 语句对异常进行了捕获，但没有重新抛出运行时异常</li>\n</ul>\n<div><p>什么是自调用</p>\n<p>自调用是指在类 A 里面有方法 a 和方法 b， 在方法 b 上面添加了 <code>@Transactional</code> 注解，在方法 a 中调用方法 b， 方法 b 的事务是不会生效的。原因在于同一个类之中，方法互相调用导致切面无效，而不仅仅是事务。事务之所以无效，是因为 Spring 的事务是通过 AOP 实现的。</p>\n</div>\n",
      "image": "https://i.loli.net/2021/07/31/7UEfnFxiscSywvQ.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌵 SpringCloud",
      "url": "https://blog.lixiangyu.xyz/interview/framework/spring/springcloud/",
      "id": "https://blog.lixiangyu.xyz/interview/framework/spring/springcloud/",
      "content_html": "<h2 id=\"什么是集群\"> 什么是集群？</h2>\n<p>计算机集群简称集群。它是一种计算机系统，通过一组松散集成的计算机软件和/或硬件连接起来，高度紧密地协作完成计算工作。在某种意义上，他们可以被看作是一台计算机。集群系统中的单个计算机通常称为节点，通常通过局域网连接，但也有其它的可能连接方式。集群计算机通常用来改进单个计算机的计算速度和/或可靠性。一般情况下集群计算机比单个计算机，比如工作站或超级计算机性能价格比要高得多。</p>\n<p>特点：</p>\n<ul>\n<li>通过多台计算机完成同一个工作，达到更高的效率</li>\n<li>两机或多机内容、工作过程等完全一样，如果一台死机，另一台可以起作用</li>\n</ul>\n<h2 id=\"什么是分布式\"> 什么是分布式？</h2>\n<p>分布式系统是一组计算机通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统，组件之间彼此进行交互以实现一个共同的目标。</p>\n<p>特点：</p>\n<ul>\n<li>功能拆分，模块之间独立，在使用的时候再将这些独立的模块组合起来就是一个系统了</li>\n<li>模块之间独立，各做各的事，便于扩展，复用性高</li>\n<li>高吞吐量，某个任务需要一个机器运行 10 个小时，将该任务用 10 台机器的分布式跑（将这个任务拆分成 10 个小任务），可能 2 个小时就跑完了</li>\n</ul>\n<h2 id=\"为什么要采用分布式开发的方案\"> 为什么要采用分布式开发的方案？<i>Not supported content</i></h2>\n<p>由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题，所以近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring Cloud 是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。</p>\n<h2 id=\"什么是-spring-cloud\"> 什么是 Spring Cloud？</h2>\n<p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p>\n<p>Spring Cloud 并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</p>\n<p>SpringCloud 的基础功能：</p>\n<ul>\n<li>服务治理：Spring Cloud Eureka</li>\n<li>客户端负载均衡：Spring Cloud Ribbon</li>\n<li>服务容错保护：Spring Cloud Hystrix</li>\n<li>声明式服务调用：Spring Cloud Feign</li>\n<li>API 网关服务：Spring Cloud Zuul</li>\n<li>分布式配置中心：Spring Cloud Config</li>\n</ul>\n<p>SpringCloud的高级功能：</p>\n<ul>\n<li>消息总线：Spring Cloud Bus</li>\n<li>消息驱动的微服务：Spring Cloud Stream</li>\n<li>分布式服务跟踪：Spring Cloud Sleuth</li>\n</ul>\n<h2 id=\"介绍一下-eureka\"> 介绍一下 Eureka？</h2>\n<p>Eureka 是专门用于给其他服务注册的，称为 Eureka Server（服务注册中心），其余注册到 Eureka Server 上的服务称为 Eureka Client。注册的目的在于方便调用，省去了手动维护远程调用方的 IP 地址这一步骤。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/XVOaj8Y3MKiZHFW.png\" alt=\"Eureka.png\" /></p>\n</div>\n<h3 id=\"服务提供者\"> 服务提供者</h3>\n<ul>\n<li>服务注册：启动的时候会通过发送 REST 请求的方式将自己注册到 Eureka Server 上，同时带上了自身服务的一些元数据信息</li>\n<li>服务续约：在注册完服务之后，服务提供者会维护一个心跳信息</li>\n<li>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的 REST 请求给 Eureka Server</li>\n</ul>\n<h3 id=\"服务消费者\"> 服务消费者</h3>\n<ul>\n<li>获取服务：当我们启动服务消费者的时候，它会发送一个 REST 请求给服务注册中心，来获取注册的服务清单</li>\n<li>服务调用：服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息，在进行服务调用的时候，优先访问同处一个 Zone 中的服务提供方</li>\n</ul>\n<h3 id=\"eureka-server\"> Eureka Server</h3>\n<ul>\n<li>失效剔除：默认每隔一段时间（默认为 60 秒） 将当前清单中超时（默认为 90 秒）没有续约的服务剔除出去</li>\n<li>自我保护：EurekaServer 在运行期间，会统计心跳失败的比例在 15 分钟之内是否低于 85%（通常由于网络不稳定导致的），Eureka Server 会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息</li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/Wg2UrxH7C3oPfLj.png\" alt=\"Eureka服务治理.png\" /></p>\n</div>\n<h2 id=\"介绍一下-ribbon\"> 介绍一下 Ribbon？</h2>\n<p>为了实现服务的高可用，通常需要使用集群。为了使请求能尽可能平摊到所有节点上，需要用到负载均衡。这就需要用到 Ribbon，它是客户端的负载均衡。</p>\n<div><p>Ribbon 和 Nginx 的区别</p>\n<p>在 Nginx 中请求是先进入负载均衡器再进行分发，而在 Ribbon 中是先在客户端进行负载均衡才进行请求的。</p>\n</div>\n<h2 id=\"介绍一下-hystrix\"> 介绍一下 Hystrix？</h2>\n<p>在高并发的情况下，由于单个服务的延迟，可能导致所有的请求都处于延迟状态，甚至在几秒钟就使服务处于负载饱和的状态，导致资源耗尽，最终整个分布式系统都不可用，这就是雪崩。针对上述问题，Spring Cloud Hystrix 实现了断路器、线程隔离等一系列服务保护功能：</p>\n<ul>\n<li>Fallback（失败快速返回）：当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待，这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延</li>\n<li>资源/依赖隔离（线程池隔离）：它会为每一个依赖服务创建一个独立的线程池，这样就算某个依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的依赖服务</li>\n</ul>\n<p>Hystrix提供了几个熔断相关的关键参数：滑动窗口大小（20）、 熔断器开关间隔（5s）、错误率（50%）：</p>\n<ul>\n<li>每当 20 个请求中，有 50% 失败时，熔断器就会打开，此时再调用此服务，将会直接返回失败，不再调远程服务</li>\n<li>直到 5s 之后，重新检测该触发条件，判断是否把熔断器关闭，或者继续打开</li>\n</ul>\n<h2 id=\"介绍一下-feign\"> 介绍一下 Feign？</h2>\n<p>Feign 是一种声明式、模板化的 HTTP 客户端。在 Spring Cloud 中使用 Feign，可以做到与调用本地方法一样的编码体验。</p>\n<div><pre><code><span>/**\n * value --> 指定调用哪个服务\n * fallbackFactory --> 熔断器的降级提示\n */</span>\n<span>@FeignClient</span><span>(</span>value <span>=</span> <span>\"xx\"</span><span>,</span> fallbackFactory <span>=</span> xx<span>.</span><span>class</span><span>)</span>\n<span>public</span> <span>interface</span> <span>DeptClientService</span> <span>{</span>\n    <span>// 采用Feign我们可以使用SpringMVC的注解来对服务进行绑定！</span>\n    <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>\"/dept/get/{id}\"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>\n    <span>public</span> <span>Dept</span> <span>get</span><span>(</span><span>@PathVariable</span><span>(</span><span>\"id\"</span><span>)</span> <span>long</span> id<span>)</span><span>;</span>\n\n    <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>\"/dept/list\"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>GET<span>)</span>\n    <span>public</span> <span>List</span><span><span>&lt;</span><span>Dept</span><span>></span></span> <span>list</span><span>(</span><span>)</span><span>;</span>\n\n    <span>@RequestMapping</span><span>(</span>value <span>=</span> <span>\"/dept/add\"</span><span>,</span> method <span>=</span> <span>RequestMethod</span><span>.</span>POST<span>)</span>\n    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>Dept</span> dept<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id=\"介绍一下-zuul\"> 介绍一下 Zuul？</h2>\n<p>基于上面的内容，现在的程序可能设计成了这样：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/e4CJ6XgAKtbqjvh.png\" alt=\"zuul.png\" /></p>\n</div>\n<p>这样的架构会有两个比较麻烦的问题：</p>\n<ul>\n<li>路由规则与服务实例的维护间题：外层的负载均衡（Nginx）需要维护所有的服务实例清单（图上的 OpenService）</li>\n<li>签名校验、登录校验冗余问题：为了保证对外服务的安全性，在服务端实现的微服务接口往往都会有一定的权限校验机制，但服务是独立的，这样不得不在这些应用中都实现这样一套校验逻辑，这就会造成校验逻辑的冗余</li>\n</ul>\n<p>为了解决上面这些常见的架构问题，API 网关的概念应运而生。在 SpringCloud 中了提供了基于 Netflix Zuul 实现的 API 网关组件 Spring Cloud Zuul。Spring Cloud Zuul 是这样解决上述两个问题的：</p>\n<ul>\n<li>SpringCloud Zuul 通过与 SpringCloud Eureka 进行整合，将自身注册为 Eureka 服务治理下的应用，同时从 Eureka 中获得了所有其他微服务的实例信息，外层调用都必须通过 API 网关，使得将维护服务实例的工作交给了服务治理框架自动完成</li>\n<li>在 API 网关服务上进行统一调用来对微服务接口做前置过滤，以实现对微服务接口的拦截和校验</li>\n</ul>\n<p>Zuul 天生就拥有线程隔离和断路器的自我保护功能，以及对服务调用的客户端负载均衡功能。也就是说：Zuul 也是支持 Hystrix 和 Ribbon 的。</p>\n<div><p>Zuul 既然支持负载均衡，那么 Feign 的负载均衡是否还有必要</p>\n<ul>\n<li>Zuul 是对外暴露的唯一接口，相当于路由的是 Controller 请求，而 Ribbon 和 Feign 路由了 Service 请求</li>\n<li>Zuul 做最外层请求的负载均衡，而 Ribbon 和 Feign 做的是系统内部各个微服务的 Service 的调用的负载均衡</li>\n</ul>\n</div>\n",
      "image": "https://i.loli.net/2021/07/31/XVOaj8Y3MKiZHFW.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤪 包装类和缓存池",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/datatype-wrapper-cache/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/datatype-wrapper-cache/",
      "content_html": "<h2 id=\"介绍一下基本数据类型和对应的包装类\"> 介绍一下基本数据类型和对应的包装类？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:center\">包装类</th>\n<th style=\"text-align:center\">基本类型的长度(位)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">byte</td>\n<td style=\"text-align:center\">Byte</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">8</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">char</td>\n<td style=\"text-align:center\">Character</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">short</td>\n<td style=\"text-align:center\">Short</td>\n<td style=\"text-align:center\">16</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">Integer</td>\n<td style=\"text-align:center\">32</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">float</td>\n<td style=\"text-align:center\">Float</td>\n<td style=\"text-align:center\">32</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">long</td>\n<td style=\"text-align:center\">Long</td>\n<td style=\"text-align:center\">64</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">double</td>\n<td style=\"text-align:center\">Double</td>\n<td style=\"text-align:center\">64</td>\n</tr>\n</tbody>\n</table>\n<p>包装类型与其基本类型之间的赋值会通过自动装箱和自动拆箱来进行转换（以下内容通过字节码可以查看）：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Integer</span> a <span>=</span> <span>2</span><span>;</span> <span>// 装箱，调用了Integer.valueOf(2)</span>\n    <span>int</span> b <span>=</span> a<span>;</span> <span>// 拆箱，调用了a.intValue()</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id=\"了解缓存池吗\"> 了解缓存池吗？<i>Not supported content</i></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">包装类</th>\n<th style=\"text-align:center\">缓存池范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Integer</td>\n<td style=\"text-align:center\">-128~127</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Boolean</td>\n<td style=\"text-align:center\">true 和 false</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Short</td>\n<td style=\"text-align:center\">-128~127</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Character</td>\n<td style=\"text-align:center\">\\u0000~\\u007F</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Byte</td>\n<td style=\"text-align:center\">所有</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Double</td>\n<td style=\"text-align:center\">未实现缓存池</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Float</td>\n<td style=\"text-align:center\">未实现缓存池</td>\n</tr>\n</tbody>\n</table>\n<div><p>调整 Integer 缓存池的上限</p>\n<p><code>Integer</code> 缓存池可通过 VM 参数 <code>-XX:AutoBoxCacheMax</code> 来指定缓存池的上限。</p>\n</div>\n<div><p>valueof 与 new</p>\n<p>简单来说，调用 <code>valueof()</code> 方法会从缓存池中取值（可以通过 <code>valueof()</code> 的源码进行证实），使用 <code>new</code> 会新建对象。这就是为什么 <code>new String()</code>\n会创建两个对象（一个在堆，一个在常量池）。</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😵 异常",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/exception/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/exception/",
      "content_html": "<h2 id=\"介绍一下-java-中的异常\"> 介绍一下 Java 中的异常？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/kyXmHLnpdaj7vQw.png\" alt=\"异常.jpg\" /></p>\n</div>\n<p><code>Throwable</code> 可以用来表示任何可以作为异常抛出的类，分为 <code>Error</code> 和 <code>Exception</code> 两种类型。</p>\n<h3 id=\"error-错误\"> Error-错误</h3>\n<p><code>Error</code> 表示 JVM 无法处理的错误，如：<code>OutOfMemoryError</code>，<code>StackOverflowError</code> 等。</p>\n<h3 id=\"exception-异常\"> Exception-异常</h3>\n<p><code>Exception</code> 表示异常，它会再细分为下面两类：</p>\n<ul>\n<li>非受检异常：是程序运行时的错误，也可以通过 <code>try/catch</code> 来捕获处理，如：<code>NPE</code>，<code>IndexOutOfBoundsException</code> 等</li>\n<li>受检异常：必须使用 <code>try/catch</code> 语句捕获并处理的异常，如果不处理就要使用 <code>throws</code> 关键字向上层抛出</li>\n</ul>\n<h2 id=\"什么是异常链\"> 什么是异常链？</h2>\n<p>异常链是指在进行一个异常处理时抛出了另外一个异常，由此产生了一个异常链条。特别需要注意的是如果你因为一个异常而决定抛出另一个新的异常时，一定要包含原有的异常（通过 <code>Throwable</code> 提供的构造器），这样处理程序才可以通过 <code>getCause()</code> 和 <code>initCause()</code> 方法来访问异常最终的根源。</p>\n<h2 id=\"try-中如果包含返回语句-finally-会怎么执行\"> try 中如果包含返回语句，finally 会怎么执行？</h2>\n<p>在 <code>try</code> 中如果使用了返回语句，仍然会继续执行 <code>finally</code> 块。如果 <code>finally</code> 块同样使用了返回语句，那么返回值将会使用 <code>finally</code> 块中的返回值，而不是 <code>try</code> 中的返回值。</p>\n<div><p>在 finally 中修改返回值对应的变量的的值并不会影响返回值</p>\n<p>在下面的这个例子中，将输出 1 而不是 2：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>test</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>int</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> a <span>=</span> <span>0</span><span>;</span>\n    <span>try</span> <span>{</span>\n        a <span>=</span> <span>1</span><span>;</span>\n        <span>return</span> a<span>;</span>\n    <span>}</span> <span>finally</span> <span>{</span>\n        a <span>=</span> <span>2</span><span>;</span>\n        <span>// 使用return会返回2</span>\n        <span>// return 2;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></div>\n",
      "image": "https://i.loli.net/2021/07/31/kyXmHLnpdaj7vQw.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😎 泛型",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/generics/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/generics/",
      "content_html": "<h2 id=\"什么是泛型\"> 什么是泛型？</h2>\n<p>泛型是 JDK1.5 之后出现的，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。如果直接使用 <code>Object</code> 类来实现通用、不同类型的处理，有这么两个缺点：</p>\n<ul>\n<li>每次使用时都需要强制转换成想要的类型</li>\n<li>在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全</li>\n</ul>\n<h2 id=\"什么是泛型的类型擦除\"> 什么是泛型的类型擦除？</h2>\n<p>在 Java 中，泛型是 Java 编译器的概念，当编译器对带有泛型的 Java 代码进行编译时，它会去执行类型检查和类型推断，然后生成普通的不带泛型的字节码，这种普通的字节码可以被一般的 Java 虚拟机接收并执行，这个过程就叫做类型擦除（type erasure）。由于存在类型擦除，所以下面的操作在编译时就是不被允许的：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>// 提示：'test(List&lt;String>)' 与 'test(List&lt;Integer>)' 冲突；</span>\n    <span>// 两个方法具有相同的擦除</span>\n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>List</span><span><span>&lt;</span><span>String</span><span>></span></span> list<span>)</span> <span>{</span>\n        \n    <span>}</span>\n    \n    <span>public</span> <span>void</span> <span>test</span><span>(</span><span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list<span>)</span> <span>{</span>\n    \n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id=\"什么是泛型中的限定通配符和非限定通配符\"> 什么是泛型中的限定通配符和非限定通配符？</h2>\n<ul>\n<li><code>?</code>：非限定通配符，可以表示任意类型</li>\n<li><code>&lt;? extends T&gt;</code>：表示这个类型必须是 <code>T</code> 类型、<code>T</code> 类型的子类或者实现了 <code>T</code> 接口</li>\n<li><code>&lt;? super T&gt;</code>：表示这个类型必须是 <code>T</code> 类型或者 <code>T</code> 类型的父类</li>\n</ul>\n<h2 id=\"怎么新建一个泛型类、泛型方法、泛型变量\"> 怎么新建一个泛型类、泛型方法、泛型变量？</h2>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>{</span>\n    <span>private</span> <span>T</span> data<span>;</span>\n    \n    <span>// 不支持静态泛型变量，这么写是错误的</span>\n    <span>// private static T staticData;</span>\n\n    <span>public</span> <span>Test</span><span>(</span><span>T</span> data<span>)</span> <span>{</span>\n        <span>this</span><span>.</span>data <span>=</span> data<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>T</span> <span>get</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>this</span><span>.</span>data<span>;</span>\n    <span>}</span>\n    \n    <span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span> <span>getStatic</span><span>(</span><span>T</span> data<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>data<span>)</span><span>;</span>\n        <span>return</span> data<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div>",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😛 关键字",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/keyword/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/keyword/",
      "content_html": "<h2 id=\"介绍一下-final-关键字\"> 介绍一下 final 关键字？</h2>\n<h3 id=\"修饰变量\"> 修饰变量</h3>\n<p>如果使用 <code>final</code> 来修饰变量，那么表示这个变量是常量。对于基本类型，<code>final</code> 使它的值不能改变；对于引用类型，<code>final</code> 使引用不变，所以它不能再引用其他对象，但已经被引用的对象仍然是可以修改的。</p>\n<h3 id=\"修饰方法\"> 修饰方法</h3>\n<p>如果使用 <code>final</code> 来修饰方法，那么表示这个方法不能被子类重写。</p>\n<h3 id=\"修饰类\"> 修饰类</h3>\n<p>如果使用 <code>final</code> 来修饰变量，那么表示这个类不能被继承。</p>\n<div><p>提示</p>\n<p>除了 <code>String</code> 类以外，<code>Math</code>、<code>System</code> 等类也是使用 <code>final</code> 修饰的。</p>\n</div>\n<h2 id=\"介绍一下-static-关键字\"> 介绍一下 static 关键字？</h2>\n<h3 id=\"修饰变量-2\"> 修饰变量</h3>\n<p>表示这个变量是静态变量，可以直接通过类名来访问这个变量。</p>\n<h3 id=\"修饰方法-2\"> 修饰方法</h3>\n<p>表示这个方法是静态方法，静态方法只能调用本类中的静态变量和其他静态方法。</p>\n<h3 id=\"修饰一段代码块\"> 修饰一段代码块</h3>\n<p>表示这段代码是静态代码块，静态代码块会在类初始化的时候执行一次。</p>\n<h3 id=\"修饰内部类\"> 修饰内部类</h3>\n<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类，而静态内部类不需要。</p>\n<h3 id=\"静态导包\"> 静态导包</h3>\n<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低，不推荐使用。</p>\n<h3 id=\"类的初始化顺序\"> 类的初始化顺序</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/29/YTFHv7G2xny9la8.png\" alt=\"init_order.png\" /></p>\n</div>\n<h2 id=\"介绍一下-synchronized-关键字\"> 介绍一下 synchronized 关键字？<i>Not supported content</i></h2>\n<p>在 Java 中，<code>synchronized</code> 关键字是用来控制线程同步的，在多线程环境下，被 <code>synchronized</code> 关键字修饰的代码段、方法不会被多个线程同时执行。<code>synchronized</code> 既可以加在一段代码上，也可以加在方法上，还可以是类上。同时它还是一个可重入锁。</p>\n<h2 id=\"介绍一下-volatile-关键字\"> 介绍一下 volatile 关键字？<i>Not supported content</i></h2>\n<p>当一个变量使用 <code>volatile</code> 关键字修饰时：</p>\n<ul>\n<li>在修改时，会强制把该线程本地内存中的变量刷新到主内存中</li>\n<li>在读取时，会强制从主内存中读取最新的值</li>\n</ul>\n<p><code>volatile</code> 仅保证可见性，不保证原子性（如果要保证原子性，需要使用 <code>AtomicXX</code> 类，如 <code>AtomicInteger</code>），测试代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span> \n    <span>private</span> <span>static</span> <span>volatile</span> <span>long</span> value <span>=</span> <span>0</span><span>;</span> \n \n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span> \n        <span>testVolatile</span><span>(</span><span>)</span><span>;</span> \n    <span>}</span> \n \n    <span>private</span> <span>static</span> <span>class</span> <span>LoopVolatile</span> <span>implements</span> <span>Runnable</span> <span>{</span> \n        <span>@Override</span> \n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span> \n            <span>long</span> val <span>=</span> <span>0</span><span>;</span> \n            <span>while</span> <span>(</span>val <span>&lt;</span> <span>10000000L</span><span>)</span> <span>{</span> \n                value<span>++</span><span>;</span> \n                val<span>++</span><span>;</span> \n            <span>}</span> \n        <span>}</span> \n    <span>}</span> \n \n    <span>private</span> <span>static</span> <span>class</span> <span>LoopVolatile2</span> <span>implements</span> <span>Runnable</span> <span>{</span> \n        <span>@Override</span> \n        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span> \n            <span>long</span> val <span>=</span> <span>0</span><span>;</span> \n            <span>while</span> <span>(</span>val <span>&lt;</span> <span>10000000L</span><span>)</span> <span>{</span> \n                value<span>++</span><span>;</span> \n                val<span>++</span><span>;</span> \n            <span>}</span> \n        <span>}</span> \n    <span>}</span> \n \n    <span>private</span> <span>static</span> <span>void</span> <span>testVolatile</span><span>(</span><span>)</span><span>{</span> \n        <span>Thread</span> t1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>LoopVolatile</span><span>(</span><span>)</span><span>)</span><span>;</span> \n        t1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span> \n \n        <span>Thread</span> t2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>LoopVolatile2</span><span>(</span><span>)</span><span>)</span><span>;</span> \n        t2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span> \n \n        <span>while</span> <span>(</span>t1<span>.</span><span>isAlive</span><span>(</span><span>)</span> <span>||</span> t2<span>.</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>{</span> \n        <span>}</span> \n \n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"final val is: \"</span> <span>+</span> value<span>)</span><span>;</span> \n    <span>}</span> \n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><p>同时 <code>volatile</code> 会禁止指令重排，通过内存屏障保证特定操作的顺序。</p>\n<div><p>volatile 在单例模式中的使用</p>\n<p>双捡锁方式的单例模式建议加上 <code>volatile</code>，因为实例化操作并不是原子操作。假设单例类为 <code>Singleton</code>，通过 <code>javap -v Singleton.class</code> 查看字节码：</p>\n<ol>\n<li><code>new #3 // class Singleton</code></li>\n<li><code>dup</code></li>\n<li><code>invokespecial #4 // Method init</code></li>\n<li><code>a_store_1</code></li>\n</ol>\n<p>它们对应的操作为：</p>\n<ol>\n<li>分配对象内存</li>\n<li>调用构造器方法，执行初始化</li>\n<li>将对象引用赋值给变量</li>\n</ol>\n<p>由于步骤二、三需要步骤一的结果，所以步骤一不会被重排，但是步骤二、三是可能重排的。在多线程情况下，就可能导致有的线程拿到了未初始化的变量。通过 <code>volatile</code>\n避免指令重排可以解决这个问题。</p>\n</div>\n<h2 id=\"介绍一下-transient-关键字\"> 介绍一下 transient 关键字？</h2>\n<p>使用 <code>transient</code> 关键字修饰的变量在序列化时将不会进行序列化。可以参考 <code>ArrayList</code> 类，通过重写 <code>readObject()</code> 和 <code>writeObject()</code>\n方法实现自定义序列化内容。</p>\n<h2 id=\"有哪些访问修饰符\"> 有哪些访问修饰符？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">修饰符</th>\n<th style=\"text-align:center\">当前类</th>\n<th style=\"text-align:center\">同包</th>\n<th style=\"text-align:center\">子类</th>\n<th style=\"text-align:center\">其他包</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">public</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">protected</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">default</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">private</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n</tbody>\n</table>\n",
      "image": "https://i.loli.net/2021/07/29/YTFHv7G2xny9la8.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😁 Object 类",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/object-class/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/object-class/",
      "content_html": "<h2 id=\"介绍一下-equals-方法\"> 介绍一下 equals() 方法？<i>Not supported content</i></h2>\n<ul>\n<li>自反性：自身和自身是相同的</li>\n<li>对称性：a 和 b 相同，同时 b 和 a 也是相同的（调换前后顺序不影响结果）</li>\n<li>传递性：a 和 b 相同且 b 和 c 相同，可以得到 a 和 c 相同</li>\n<li>一致性：多次调用 <code>equals()</code> 方法，结果是不变的</li>\n<li>与 <code>null</code> 的比较：结果一定是 <code>false</code></li>\n</ul>\n<div><p>等价与相等</p>\n<ul>\n<li>对于基本类型，<code>==</code> 判断两个值是否相等，基本类型没有 <code>equals()</code> 方法</li>\n<li>对于引用类型，<code>==</code> 判断两个变量是否引用同一个对象，而 <code>equals()</code> 判断引用的对象是否等价（默认也是通过 <code>==</code> 来进行比较，这就是为什么需要重写这个方法）</li>\n</ul>\n</div>\n<h2 id=\"介绍一下-hashcode-方法\"> 介绍一下 hashcode() 方法？<i>Not supported content</i></h2>\n<p><code>hashCode()</code> 方法将返回这个对象对应的哈希值，等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。 在覆盖 <code>equals()</code> 方法时应当总是覆盖 <code>hashCode()</code> 方法，保证等价的两个对象哈希值也相等。</p>\n<h2 id=\"介绍一下-tostring-方法\"> 介绍一下 toString() 方法？</h2>\n<p>默认返回 <code>ClassName@30dae81</code> 这种形式，其中 <code>@</code> 后面的数值为哈希值的无符号十六进制表示。</p>\n<h2 id=\"介绍一下-clone-方法\"> 介绍一下 clone() 方法？</h2>\n<p>虽然 <code>clone()</code> 是 <code>Object</code> 类中的方法，但直接重写（因为 <code>clone()</code> 方法的权限是 <code>protected</code>，需要重写并将权限放大，要不然无法调用）并调用会抛出 <code>CloneNotSupportedException</code> 异常。这是因为 <code>Cloneable</code> 接口的规定：如果一个类没有实现 <code>Cloneable</code> 接口又调用了 <code>clone()</code> 方法，就会抛出 <code>CloneNotSupportedException</code> 异常。</p>\n<div><p>浅拷贝</p>\n<p>直接调用 <code>super.clone()</code> 所得到对象的是浅拷贝对象。</p>\n</div>\n<div><p>clone() 方法的替代方案</p>\n<p>使用 <code>clone()</code> 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。替代方案有：</p>\n<ol>\n<li>提供拷贝构造函数：<code>public MyClass(MyClass clazz)</code></li>\n<li>提供拷贝工厂</li>\n<li>实现序列化接口</li>\n</ol>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😀 面向对象的特点",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/oo-feature/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/oo-feature/",
      "content_html": "<h2 id=\"面向对象的特点包括哪些\"> 面向对象的特点包括哪些？</h2>\n<h3 id=\"封装\"> 封装</h3>\n<p>通常认为封装是把数据和操作数据的方法绑定起来，想要访问数据只能通过已定义的接口来进行访问。面向对象的本质就是将现实世界描绘成一系列完全自治、封闭的对象。可以说封装就是隐藏一切可隐藏的东西，只向外界提供最简单的编程接口。</p>\n<div><p>不一定都需要封装</p>\n<p>对于绝大部分的类而言，它们所包含的成员变量都不可以给 <code>public</code> 权限，否则封装就失去了意义。但是如果是内部类，可以特殊一点。</p>\n</div>\n<h3 id=\"继承\"> 继承</h3>\n<p>继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类），得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封装程序中可变因素的重要手段。</p>\n<h3 id=\"多态\"> 多态</h3>\n<p>多态性是指允许不同子类型的对象对同一消息作出不同的响应，简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。实现多态的关键在于：</p>\n<ul>\n<li>继承</li>\n<li>重写</li>\n<li>父类引用指向子类对象（如 <code>Parent p = new Child()</code>）</li>\n</ul>\n<div><p>多态的前绑定和后绑定</p>\n<p>前绑定指指编译时的多态性，通过方法重载可以实现，后绑定指指运行时的多态性，通过方法重写可以实现。</p>\n</div>\n<h3 id=\"抽象\"> 抽象</h3>\n<p>抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧐 其他",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/other/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/other/",
      "content_html": "<h2 id=\"接口\"> 接口</h2>\n<h3 id=\"介绍一下-serializable-接口\"> 介绍一下 Serializable 接口？</h3>\n<p><code>Serializable</code> 接口是一个标记接口，实现了这个接口的类可以实现序列化和反序列化。在序列化的时候系统将 <code>serialVersionUID</code> 写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的 <code>serialVersionUID</code> 是否跟当前类的 <code>serialVersionUID</code> 一致，如果一致则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会报错。</p>\n<h2 id=\"运算符\"> 运算符</h2>\n<h3 id=\"有哪些算术运算符\"> 有哪些算术运算符？</h3>\n<p>算术运算符包括：<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>++</code>，<code>--</code>（<code>+=</code>、<code>-=</code> 等不再罗列）。</p>\n<h3 id=\"有哪些逻辑运算符\"> 有哪些逻辑运算符？</h3>\n<p>逻辑运算符包括：<code>&amp;&amp;</code>，<code>||</code>，<code>!</code>。</p>\n<h3 id=\"有哪些位运算符\"> 有哪些位运算符？</h3>\n<ul>\n<li><code>^</code>：异或运算，相同为 0，不同为 1</li>\n<li><code>&amp;</code>：与运算，都是 1 才是 1，否则是 0</li>\n<li><code>|</code>：或运算，只要有一个是 1，就是 1</li>\n<li><code>~</code>：取反， 0 取 1，1 取 0</li>\n<li><code>&gt;&gt;</code>：右移运算符，右移 n 位相当于除 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span></li>\n<li><code>&gt;&gt;&gt;</code>：无符号右移，高位全部置为 0</li>\n<li><code>&lt;&lt;</code>：左移运算符，左移 n 位相当于乘 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span></li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 Java 基础 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/",
      "content_html": "<p>在阅读这一部分内容时，我假定你已经对 Java 的基本知识有了一定的了解。这部分的内容平时开发会经常用，但是面试中问的确实比较少，快速看看当作复习就行了。</p>\n<p>本部分共分为以下几个方面：</p>\n<ol>\n<li><a href=\"/interview/java-basic/oo-feature/\">面向对象的特点</a>：Java 是一门面向对象的程序语言，OO 的特点有必要了解一下</li>\n<li><a href=\"/interview/java-basic/keyword\">关键字</a>：Java 中提供了非常多的关键字，某些关键字要特别了解一下</li>\n<li><a href=\"/interview/java-basic/datatype-wrapper-cache\">包装类和缓存池</a>：Java 提供了 8 中基本数据类型以及预知对应的包装类，某些值可能会经常使用，所以还提供了缓存池</li>\n<li><a href=\"/interview/java-basic/object-class\">Object类</a>：Java 中所有对象之父 - <code>Object</code> 类</li>\n<li><a href=\"/interview/java-basic/string-class\">String类</a>：Java 中的字符串实现</li>\n<li><a href=\"/interview/java-basic/exception\">异常</a>：Java 中的异常机制</li>\n<li><a href=\"/interview/java-basic/reflect\">反射</a>：Java 提供的在运行时动态获取或调用方法或属性的机制</li>\n<li><a href=\"/interview/java-basic/generics\">泛型</a>：Java 提供的参数化类型</li>\n<li><a href=\"/interview/java-basic/other\">其他</a>：其他问题整理</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😆 String 类",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/string-class/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/string-class/",
      "content_html": "<h2 id=\"为什么-string-对象是不可变的\"> 为什么 String 对象是不可变的？</h2>\n<p>不可变是指一个 <code>String</code> 对象被创建后，这个对象就不允许再被修改。实现不可变性的关键在于：</p>\n<ul>\n<li><code>String</code> 类被声明为 <code>final</code>，因此它不可被继承</li>\n<li><code>String</code> 类内部通过一个 <code>char</code> 型数组来保存数据，这个数组同样被声明为 <code>final</code>，因此不能直接修改保存的数据</li>\n</ul>\n<div><p>String 类设计为不可变的原因</p>\n<ol>\n<li>因为不可变，所以哈希值是不变的，这样就可以缓存哈希值</li>\n<li>可以在 String Pool 中缓存</li>\n<li>不可变性使得它一定是线程安全的</li>\n</ol>\n</div>\n<h2 id=\"了解字符串池-string-pool-吗\"> 了解字符串池（String pool）吗？<i>Not supported content</i></h2>\n<p>JVM 为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，叫做字符串池（String Pool）。</p>\n<h3 id=\"采用字面值赋值\"> 采用字面值赋值</h3>\n<p>如果通过 <code>String a = &quot;abc&quot;</code> 的方式来获得一个新的字符串，那么会自动的将 <code>abc</code> 保存到字符串池中。</p>\n<h3 id=\"通过-new-关键字新建对象\"> 通过 new 关键字新建对象</h3>\n<p>如果通过 <code>new</code> 来获取新的字符串，那么程序总是会在堆上创建一个新的对象（同时如果字符串池中没有这个字符串，那么还要在字符串池中创建一个字符串对象），所以这个步骤会创建两个对象。如果通过 <code>==</code> 进行比较，那么它们一定是不等的。</p>\n<div><p>String.intern()</p>\n<p>除了上述两种方式，还可以调用 <code>String</code> 类中的 <code>intern()</code> 方法从字符串池中获取一个字符串的引用，如果字符串池中不存在这个字符串，那么首先会把它保存起来再返回。</p>\n</div>\n<h2 id=\"讲一下-string-stringbuilder-和-stringbuffer-的区别\"> 讲一下 String，StringBuilder 和 StringBuffer 的区别？</h2>\n<h3 id=\"可变性\"> 可变性</h3>\n<ul>\n<li><code>String</code> 不可变</li>\n<li><code>StringBuilder</code> 和 <code>StringBuffer</code> 均可变</li>\n</ul>\n<h3 id=\"线程安全\"> 线程安全</h3>\n<ul>\n<li><code>String</code> 因为不可变，所以是线程安全的</li>\n<li><code>StringBuilder</code> 不是线程安全的</li>\n<li><code>StringBuffer</code> 是线程安全的，因为使用了 synchronized 关键字（在方法上加锁）</li>\n</ul>\n<div><p>StringBuilder 和 StringBuffer 的区别和联系</p>\n<p><code>StringBuilder</code> 和 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code>，区别在于是否使用了 <code>synchronized</code>。</p>\n<p>另外它们重写的 <code>toString()</code> 方法都是通过 <code>new String()</code> 的方式来返回一个新的字符串，所以在比较时是不相等的。</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "😪 反射",
      "url": "https://blog.lixiangyu.xyz/interview/java-basic/reflect/",
      "id": "https://blog.lixiangyu.xyz/interview/java-basic/reflect/",
      "content_html": "<h2 id=\"什么是反射\"> 什么是反射？</h2>\n<p>反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。</p>\n<h2 id=\"反射机制的优缺点\"> 反射机制的优缺点？</h2>\n<ul>\n<li>优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了 Java 的灵活性</li>\n<li>缺点：对性能有影响，反射操作总是慢于直接执行 Java 代码</li>\n</ul>\n<h2 id=\"反射机制底层是怎么实现的\"> 反射机制底层是怎么实现的？</h2>\n<p>通过 JVM 加载的 class 文件获取相应类的信息。</p>\n<h2 id=\"反射机制在哪里使用到了\"> 反射机制在哪里使用到了？</h2>\n<p>Spring 通过反射创建 Bean 并放入容器中。</p>\n<h2 id=\"什么是动态代理-有哪些实现方式\"> 什么是动态代理，有哪些实现方式？</h2>\n<p>动态代理指的是在运行时动态生成代理类。一般是为了在不干预实现类的正常业务的情况下，给它添加一些预处理或者后置操作。比如 AOP 就是基于动态代理实现的。</p>\n<p>实现动态代理可以使用：</p>\n<ul>\n<li>JDK 动态代理（JDKProxy）：通过实现接口得到一个代理类</li>\n<li>CGLib：通过继承得到目标类的子类</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤸 ArrayList",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/list/arraylist/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/list/arraylist/",
      "content_html": "<h2 id=\"arraylist-的底层实现\"> ArrayList 的底层实现？<i>Not supported content</i></h2>\n<p><code>ArrayList</code> 是基于数组实现的，所以支持快速随机访问。</p>\n<div><p>快速随机访问</p>\n<p><code>ArrayList</code> 类实现了 <code>RandomAccess</code> 接口，这个接口是一个标记接口，实现这个接口的类，表示它支持快速随机访问，直接使用 <code>for</code> 循环会比使用迭代器循环要快。</p>\n</div>\n<h2 id=\"arraylist-的默认大小是多少\"> ArrayList 的默认大小是多少？<i>Not supported content</i></h2>\n<p>在代码中可以看到默认大小是 10。</p>\n<h2 id=\"arraylist-的扩容机制\"> ArrayList 的扩容机制？<i>Not supported content</i></h2>\n<p>在添加元素时使用 <code>ensureCapacityInternal()</code> 保证容量足够，如果容量不够，会使用 <code>grow()</code> 方法进行扩容。新的容量为：<code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，近似是 1.5 倍。</p>\n<div><p>尽量避免扩容</p>\n<p>扩容操作会将原数组的部分内容全部复制到新数组中，这个操作的代价很高，应该尽量减少扩容操作的次数。</p>\n</div>\n<h2 id=\"arraylist-如何删除元素\"> ArrayList 如何删除元素？<i>Not supported content</i></h2>\n<p>在删除元素时会调用 <code>System.arraycopy()</code> 将 <code>index + 1</code> 后面的元素都复制到 <code>index</code> 位置上，时间复杂度是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>)</span></span></span></span>，代价同样很大。</p>\n<h2 id=\"arraylist-的序列化\"> ArrayList 的序列化？</h2>\n<p><code>ArrayList</code> 基于数组实现，并且具有动态扩容特性，因此保存元素的数组可能只有其中一部分是真正使用了的，因此就没必要全部进行序列化。因此保存元素的数组 <code>elementData</code> 使用了 <code>transient</code> 关键字进行修饰，该关键字表示数组默认不会被序列化。同时 <code>ArrayList</code> 通过重新实现 <code>readObject()</code> 和 <code>writeObject()</code> 来控制只序列化有元素的那部分内容。</p>\n<h2 id=\"什么是-fail-fast-机制\"> 什么是 fail-fast 机制？</h2>\n<p>fail-fast（快速失败）机制，是集合类中提供的一种错误检测机制。如果在迭代过程中，该集合在结构上发生改变，那么就有可能会发生 fail-fast，抛出 <code>ConcurrentModificationException</code> 异常。</p>\n<p>fail-fast 机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 bug。最简单的触发方式就是在遍历过程中执行删除元素的操作，比如下面的代码：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>for</span> <span>(</span><span>int</span> val <span>:</span> list<span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>val <span>==</span> <span>2</span><span>)</span> <span>{</span>\n            list<span>.</span><span>remove</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>val<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><p>结构变化</p>\n<p>结构发生改变是指：<strong>添加或者删除至少一个元素，或者调整列表的大小</strong>。涉及这些操作的时候，内部的计数器 <code>modCount</code> 会自增，如果迭代过程中 <code>modCount</code> 发生变化（不相等），就会抛出异常。为了避免抛出 <code>ConcurrentModificationException</code> 异常，需要使用迭代器提供的 <code>remove()</code> 方法来删除元素。</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤹 LinkedList",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/list/linkedlist/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/list/linkedlist/",
      "content_html": "<h2 id=\"linkedlist-的底层实现\"> LinkedList 的底层实现？<i>Not supported content</i></h2>\n<p>基于双向链表实现，使用静态内部类 <code>Node</code> 作为链表中的节点。</p>\n<h2 id=\"与-arraylist-的区别\"> 与 ArrayList 的区别？<i>Not supported content</i></h2>\n<p><code>ArrayList</code> 基于动态数组实现，<code>LinkedList</code> 基于双向链表实现。<code>ArrayList</code> 和 <code>LinkedList</code> 的区别可以归结为数组和链表的区别：</p>\n<ul>\n<li>数组支持随机访问，但插入删除的代价很高，需要移动大量元素</li>\n<li>链表不支持随机访问，但插入删除只需要改变指针</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌩️ List 接口 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/list/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/list/",
      "content_html": "<h2 id=\"list-接口有哪些实现类\"> List 接口有哪些实现类？</h2>\n<iframe :src=\"$withBase('/mindmap/list_summary.html')\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n<p>详细介绍请见：</p>\n<ol>\n<li><a href=\"/interview/java-collection/list/arraylist\">ArrayList</a></li>\n<li><a href=\"/interview/java-collection/list/vector\">Vector</a></li>\n<li><a href=\"/interview/java-collection/list/linkedlist\">LinkedList</a></li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧘 ConcurrentHashMap",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/map/concurrenthashmap/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/map/concurrenthashmap/",
      "content_html": "<h2 id=\"concurrenthashmap-的底层存储结构\"> ConcurrentHashMap 的底层存储结构？</h2>\n<p>JDK7 中使用 <code>Segment</code> 数组和 <code>HashEntry</code> 数组，JDK8 中使用数组 + 链表 + 红黑树。</p>\n<h2 id=\"concurrenthashmap-是如何保证线程安全的\"> ConcurrentHashMap 是如何保证线程安全的？<i>Not supported content</i></h2>\n<p>在 JDK7 中使用分段锁机制（Segment）保证线程安全。每个分段锁维护着几个桶，多个线程可以同时访问不同分段锁上的桶，从而使并发度（分段锁的个数）更高。默认并发度是 16。</p>\n<div>\n<p><img src=\"https://camo.githubusercontent.com/611426fd924e7331fc19768e939456311e3d908fbb76d2441b489b976521399d/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e372e706e67\" alt=\"segment\" /></p>\n</div>\n<p>在 JDK8 中，<code>ConcurrentHashMap</code> 的结构与 <code>HashMap</code> 相同，但是使用了 CAS 和 <code>synchronized</code>（只锁定当前链表或红黑树的头节点，这样只要哈希不冲突，就不会产生并发）来保证线程安全。</p>\n<div>\n<p><img src=\"https://camo.githubusercontent.com/cc65641c880bbab590dab143b848896d814638974c591c0f29f534284d046a6c/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e382d32706e672e706e67\" alt=\"\" /></p>\n</div>\n",
      "image": "https://camo.githubusercontent.com/611426fd924e7331fc19768e939456311e3d908fbb76d2441b489b976521399d/687474703a2f2f626c6f672d696d672e636f6f6c73656e2e636e2f696d672f436f6e63757272656e74486173684d61702d6a646b312e372e706e67",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤾 Vector",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/list/vector/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/list/vector/",
      "content_html": "<h2 id=\"vector-是如何保证线程安全的\"> Vector 是如何保证线程安全的？</h2>\n<p><code>Vector</code> 使用 <code>synchronized</code> 关键字实现同步，但同步的是方法，所以效率很低。</p>\n<h2 id=\"vector-的扩容机制\"> Vector 的扩容机制？</h2>\n<p>可以通过 <code>Vector</code> 的构造器传入 <code>capacityIncrement</code>，表示扩容时的增长大小。这个参数默认为 0，表示每次都将容量翻倍。</p>\n<h2 id=\"vector-的替代方案有哪些\"> Vector 的替代方案有哪些？<i>Not supported content</i></h2>\n<h3 id=\"collections-synchronizedlist\"> Collections.synchronizedList()</h3>\n<p><code>Collections.synchronizedList()</code> 方法会对传入的 <code>List</code> 接口实现类做包装，并返回一个线程安全的 <code>SynchronizedRandomAccessList</code> 或者 <code>SynchronizedList</code>（取决于是否实现了 <code>RandomAccess</code> 接口）。</p>\n<p>与 <code>Vector</code> 的对比：</p>\n<ul>\n<li>只要实现了 <code>List</code> 接口就可以生成一个新的线程安全的包装类</li>\n<li>通过同步代码块实现加锁（<code>Vector</code> 是同步方法），默认为 <code>this</code>，当然也可以指定其他的对象</li>\n<li>迭代是非同步的，所以迭代时需要手动加锁（如果需要）</li>\n</ul>\n<h3 id=\"copyonwritearraylist\"> CopyOnWriteArrayList</h3>\n<p><code>CopyOnWriteArrayList</code> 是 J.U.C 包下的一个类，它将读写操作进行了分离，写操作在一个新复制的数组中进行，读操作还是在原始数组中进行，互不影响。这样就允许了在写操作的同时进行读操作，大大提高了读操作的性能，很适合读多写少的应用场景。</p>\n<p>但是这种设计会导致：</p>\n<ul>\n<li>内存占用增大：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右</li>\n<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中</li>\n</ul>\n<p>所以 <code>CopyOnWriteArrayList</code> 不适合内存敏感以及对实时性要求很高的场景，另外需要注意：</p>\n<ul>\n<li>写操作时需要加锁，防止并发写入时导致写入数据丢失</li>\n<li>写操作结束之后需要把原始数组指向新的复制数组</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤼 HashMap",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/map/hashmap/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/map/hashmap/",
      "content_html": "<h2 id=\"hashmap-涉及的名词概念有哪些\"> HashMap 涉及的名词概念有哪些？<i>Not supported content</i></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">英文名称</th>\n<th style=\"text-align:center\">中文名称</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CAPACITY</td>\n<td style=\"text-align:center\">容量</td>\n<td style=\"text-align:center\">哈希表中桶（数组中的每个索引位置）的数量（数组大小），默认为 16，设计成 16 的好处主要是可以使用与运算替代求余来提升计算哈希值的速度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOAD_FACTOR</td>\n<td style=\"text-align:center\">加载因子</td>\n<td style=\"text-align:center\">加载因子用来衡量哈希表满的程度，它的默认值为 0.75f，计算实时加载因子的方法为：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span>s</span><span>i</span><span>ze</span><span>/</span><span>c</span><span>a</span><span>p</span><span>a</span><span>c</span><span>i</span><span>t</span><span style=\"margin-right:0.03588em;\">y</span></span></span></span> ，而不是占用桶的数量去除以 CAPACITY</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SIZE</td>\n<td style=\"text-align:center\">键值对数量</td>\n<td style=\"text-align:center\">哈希表中保存的键值对的数量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">THRESHOLD</td>\n<td style=\"text-align:center\">阈值</td>\n<td style=\"text-align:center\">当 SIZE 大于设定的这个阈值后，哈希表会进行扩容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DEFAULT_INITIAL_CAPACITY</td>\n<td style=\"text-align:center\">初始容量</td>\n<td style=\"text-align:center\">初始容量为 16，而且容量必须为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>，如果不是也会通过其他方法转换为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MAXIMUM_CAPACITY</td>\n<td style=\"text-align:center\">最大容量</td>\n<td style=\"text-align:center\">最大的容量大小为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>30</span></span></span></span></span></span></span></span></span></span></span></span></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TREEIFY_THRESHOLD</td>\n<td style=\"text-align:center\">树化阈值</td>\n<td style=\"text-align:center\">当链表长度大于 8 时（且同时大于 MIN_TREEIFY_CAPACITY 时），就会将链表转化为红黑树</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UNTREEiFY_THRESHOLD</td>\n<td style=\"text-align:center\">退化阈值</td>\n<td style=\"text-align:center\">当树的节点数量小于 6 时，就会将红黑树重新转化为链表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MIN_TREEIFY_CAPACITY</td>\n<td style=\"text-align:center\">最小树化容量</td>\n<td style=\"text-align:center\">只有 SIZE 大于这个值并且链表长度大于 8 时，才会进行转换，之所以这么设定是因为：如果总的键值对数量太少，并且依然有冲突，那么转换红黑树是治标不治本的解决方案，直接进行扩容的效果会更好</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"hashmap-的底层存储结构\"> HashMap 的底层存储结构？<i>Not supported content</i></h2>\n<p>在 <code>HashMap</code> 类中使用了一个 <code>Node</code> 类型的数组 <code>table</code>，通过 <code>Node</code> 类中的 <code>next</code> 属性可知它是一个链表，即：数组的每个位置被当作一个桶，一个桶存放一个链表。当链表的长度大于 <code>TREEIFY_THRESHOLD</code> 并且桶的数量大于 <code>MIN_TREEIFY_CAPACITY</code>，那么会将链表转化为红黑树，每个节点使用 <code>TreeNode</code> 类表示树节点。因此在整体上，<code>HashMap</code> 是使用数组+链表+红黑树的结构来存储数据的。</p>\n<h2 id=\"如何计算哈希值\"> 如何计算哈希值？</h2>\n<p>以下是 <code>HashMap</code> 类的静态方法 <code>hash()</code> 的实现：</p>\n<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>hash</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>\n    <span>int</span> h<span>;</span>\n    <span>return</span> <span>(</span>key <span>==</span> <span>null</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span>h <span>=</span> key<span>.</span><span>hashCode</span><span>(</span><span>)</span><span>)</span> <span>^</span> <span>(</span>h <span>>>></span> <span>16</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以看到，<code>HashMap</code> 并没有直接使用 <code>key</code> 的哈希值，而是将键的哈希值的低 16 位与高 16 位的异或结果作为哈希值。举例：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:7.500000000000002em;vertical-align:-3.5000000000000018em;\"></span><span><span><span><span><span><span style=\"height:4em;\"><span style=\"top:-6.16em;\"><span style=\"height:3em;\"></span><span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>ha</span><span>s</span><span>h</span><span style=\"margin-right:0.07153em;\">C</span><span>o</span><span>d</span><span>e</span><span>(</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>:</span></span></span><span style=\"top:-4.659999999999999em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:-3.1599999999999984em;\"><span style=\"height:3em;\"></span><span><span>h</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>16</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>:</span></span></span><span style=\"top:-1.6599999999999984em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:-0.15999999999999837em;\"><span style=\"height:3em;\"></span><span><span>ha</span><span>s</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>h</span><span><span>^</span></span><span>(</span><span>h</span><span><span>&gt;&gt;&gt;</span></span><span>16</span><span>)</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>:</span></span></span></span><span>​</span></span><span><span style=\"height:3.5000000000000018em;\"><span></span></span></span></span></span><span><span><span><span style=\"height:4em;\"><span style=\"top:-6.16em;\"><span style=\"height:3em;\"></span><span><span></span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>0000</span><span> </span><span>1110</span><span> </span><span>1010</span></span></span><span style=\"top:-3.1599999999999993em;\"><span style=\"height:3em;\"></span><span><span></span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span></span></span><span style=\"top:-0.15999999999999925em;\"><span style=\"height:3em;\"></span><span><span></span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>0000</span><span> </span><span>1111</span><span> </span><span>0001</span><span> </span><span>0101</span></span></span></span><span>​</span></span><span><span style=\"height:3.500000000000001em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<div><p>为什么要用这种方式来算哈希值</p>\n<p>首先需要注意的是，代码中使用的是无符号右移，右移后结果的高 16 位一定全是 0，一个数和 0 异或，结果还是自身，所以原数据的高 16 位将会保留，从而实现高 16 位与低 16 位进行异或运算。</p>\n<p>下面来说一下为什么要这么计算。<code>HashMap</code> 在计算索引时是采用 <code>(n - 1) &amp; hash</code> （<code>n</code> 表示 <code>table</code> 数组的长度）的方式来计算的，假设 <code>n = 16</code>，那么这个位运算的结果是：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:6.000000000000001em;vertical-align:-2.750000000000001em;\"></span><span><span><span><span><span><span style=\"height:3.25em;\"><span style=\"top:-5.41em;\"><span style=\"height:3em;\"></span><span><span>n</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>:</span></span></span><span style=\"top:-3.91em;\"><span style=\"height:3em;\"></span><span><span>ha</span><span>s</span><span>h</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>:</span></span></span><span style=\"top:-2.4099999999999993em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:-0.9099999999999997em;\"><span style=\"height:3em;\"></span><span><span>res</span><span>u</span><span>lt</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>:</span></span></span></span><span>​</span></span><span><span style=\"height:2.7500000000000004em;\"><span></span></span></span></span></span><span><span><span><span style=\"height:3.25em;\"><span style=\"top:-5.41em;\"><span style=\"height:3em;\"></span><span><span></span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:-3.91em;\"><span style=\"height:3em;\"></span><span><span></span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>1111</span><span> </span><span>0000</span><span> </span><span>1111</span><span> </span><span>0001</span><span> </span><span>0101</span></span></span><span style=\"top:-0.9099999999999993em;\"><span style=\"height:3em;\"></span><span><span></span><span> </span><span>0101</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>5</span></span></span></span><span>​</span></span><span><span style=\"height:2.750000000000001em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>因为使用的是与运算，所以 <code>hash</code> 的高位将全部忽略，在 <code>n</code> 比较小时，很容易发生碰撞，因此最终采用了上面所说的方式来计算哈希。</p>\n<p>注意：因为容量是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>，所以求余操作可以被转化为与运算（因为他们的处理结果相同）。相比求余运算而言，与运算肯定执行效率更高，这也是为什么强制要求容量是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>。</p>\n</div>\n<h2 id=\"hashmap-如何计算初始容量\"> HashMap 如何计算初始容量？</h2>\n<p><code>HashMap</code> 允许通过构造器传入一个自定义的初始容量，但由于容量只能设定为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>，因此需要做转换。通过静态方法 <code>tableSizeFor()</code> 可以将任意一个容量转换为离它最近的一个 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span>。代码如下：</p>\n<div><pre><code><span>static</span> <span>final</span> <span>int</span> <span>tableSizeFor</span><span>(</span><span>int</span> cap<span>)</span> <span>{</span>\n    <span>int</span> n <span>=</span> cap <span>-</span> <span>1</span><span>;</span>\n    n <span>|=</span> n <span>>>></span> <span>1</span><span>;</span>\n    n <span>|=</span> n <span>>>></span> <span>2</span><span>;</span>\n    n <span>|=</span> n <span>>>></span> <span>4</span><span>;</span>\n    n <span>|=</span> n <span>>>></span> <span>8</span><span>;</span>\n    n <span>|=</span> n <span>>>></span> <span>16</span><span>;</span>\n    <span>return</span> <span>(</span>n <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>1</span> <span>:</span> <span>(</span>n <span>>=</span> MAXIMUM_CAPACITY<span>)</span> <span>?</span> MAXIMUM_CAPACITY <span>:</span> n <span>+</span> <span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>以 <code>cap=10</code> 为例，理解一下这段代码的逻辑：</p>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:27em;vertical-align:-13.25em;\"></span><span><span><span><span><span><span style=\"height:13.75em;\"><span style=\"top:-15.91em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span></span></span><span style=\"top:-14.41em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:-12.91em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>1</span><span> </span></span></span><span style=\"top:-11.41em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span>∣</span><span> </span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>1</span><span> </span></span></span><span style=\"top:-9.91em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span></span></span><span style=\"top:-8.409999999999998em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:-6.909999999999998em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>2</span><span> </span></span></span><span style=\"top:-5.409999999999998em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span>∣</span><span> </span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>2</span><span> </span></span></span><span style=\"top:-3.9099999999999984em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span></span></span><span style=\"top:-2.4099999999999984em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:-0.9099999999999988em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>4</span><span> </span></span></span><span style=\"top:0.589999999999999em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span>∣</span><span> </span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>4</span><span> </span></span></span><span style=\"top:2.089999999999999em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span></span></span><span style=\"top:3.589999999999999em;\"><span style=\"height:3em;\"></span><span><span>↓</span></span></span><span style=\"top:5.09em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>8</span><span> </span></span></span><span style=\"top:6.59em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span><span>∣</span><span> </span><span>n</span><span> </span><span><span>&gt;&gt;&gt;</span></span><span> </span><span>8</span><span> </span></span></span><span style=\"top:8.09em;\"><span style=\"height:3em;\"></span><span><span>n</span><span> </span></span></span><span style=\"top:9.59em;\"><span style=\"height:3em;\"></span><span><span>res</span><span>u</span><span>lt</span><span> </span></span></span></span><span>​</span></span><span><span style=\"height:13.25em;\"><span></span></span></span></span></span><span><span><span><span style=\"height:13.75em;\"><span style=\"top:-15.91em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1001</span></span></span><span style=\"top:-12.91em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>0100</span></span></span><span style=\"top:-11.41em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1101</span></span></span><span style=\"top:-9.91em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1101</span></span></span><span style=\"top:-6.909999999999998em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>0011</span></span></span><span style=\"top:-5.409999999999998em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:-3.9099999999999984em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:-0.9099999999999984em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>0000</span></span></span><span style=\"top:0.5899999999999999em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:2.09em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:5.09em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>0000</span></span></span><span style=\"top:6.59em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:8.09em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span></span></span><span style=\"top:9.59em;\"><span style=\"height:3em;\"></span><span><span></span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>0000</span><span> </span><span>1111</span><span> </span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span> </span><span style=\"margin-right:0.2222222222222222em;\"></span><span>0000</span><span> </span><span>0001</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>16</span></span></span></span><span>​</span></span><span><span style=\"height:13.25em;\"><span></span></span></span></span></span></span></span></span></span></span></span></p>\n<h2 id=\"hashmap-如何扩容\"> HashMap 如何扩容？<i>Not supported content</i></h2>\n<p><code>HashMap</code> 调用 <code>resize()</code> 函数对容量进行调整，流程如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/29/AbhYXIBnQ2ZRC4V.png\" alt=\"resize流程图.jpg\" /></p>\n</div>\n<div><p>HashMap 的懒加载</p>\n<p>调用构造器的时候不会初始化 <code>table</code> 数组和设定阈值，是在调用 <code>put()</code> 方法的时候调用的 <code>resize()</code> 方法。</p>\n</div>\n<div><p>加载因子设置为 0.75 的意义</p>\n<p>如果小于 0.5，空着一半就扩容了，空间肯定会很浪费；如果是 1 的话，只能说有超级大的概率，会发生碰撞，这不符合 <code>HashMap</code> 的初衷。既然已经设置了 <code>table</code> 的长度为 16，那么负载因子其实并不重要，重要的其实是那个阈值，毕竟加载因子也是为了计算阈值的。某个数乘 16 需要得到一个整数，那么 0.75 就很合适。</p>\n</div>\n<h2 id=\"hashmap-put-方法的逻辑是什么\"> HashMap put 方法的逻辑是什么？<i>Not supported content</i></h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/29/dZGOl8RjxuaTmeX.png\" alt=\"put流程图.jpg\" /></p>\n</div>\n<div><p>红黑树与链表的互相转化</p>\n<p>不是说满足大于 8 的条件链表就一定会转换为红黑树，还需要判断桶的数量是否大于 64。原因在于：如果桶的数量不够多，但还是冲突了，那么就算转换为了红黑树，实际上依然不能解决问题。</p>\n</div>\n<h2 id=\"hashmap-get-方法的逻辑是什么\"> HashMap get 方法的逻辑是什么？<i>Not supported content</i></h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/29/pbfuvYxEtRG14CZ.png\" alt=\"get流程图.jpg\" /></p>\n</div>\n<h2 id=\"hashmap-与-hashtable-的比较\"> HashMap 与 HashTable 的比较？</h2>\n<ul>\n<li>不保证线程安全</li>\n<li>允许键和值为 <code>null</code></li>\n<li>迭代器是 fail-fast 迭代器</li>\n<li>不保证随着时间的推移 <code>Map</code> 中的元素次序是不变的</li>\n<li><code>HashMap</code> 会做红黑树的转换</li>\n</ul>\n<h2 id=\"hashmap-的线程不安全性体现在哪里\"> HashMap 的线程不安全性体现在哪里？<i>Not supported content</i></h2>\n<ul>\n<li>如果多个线程计算键的 <code>hash</code> 是在同一位置，多次执行 <code>put</code> 操作可能会将数据覆盖</li>\n<li><code>resize()</code> 方法中调用的 <code>transfer()</code> 方法可能会使链表产生环（JDK7 采用头插法会有这个问题，JDK8 采用尾插法不会有这个问题）</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/07/29/AbhYXIBnQ2ZRC4V.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🚵 HashTable",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/map/hashtable/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/map/hashtable/",
      "content_html": "<h2 id=\"hashtable-是如何保证线程安全的\"> HashTable 是如何保证线程安全的？</h2>\n<p>使用 <code>synchronized</code> 关键字，保证线程安全。</p>\n<h2 id=\"hashtable-的替代方案\"> HashTable 的替代方案？<i>Not supported content</i></h2>\n<p><code>HashTable</code> 效率低，同时它是遗留类，不要主动的去使用它。如果需要保证线程安全可以使用 <code>ConcurrentHashMap</code>，它在 JDK7 中使用了分段锁，在 JDK8 中使用了 CAS 操作来支持更高的并发度，执行效率更高。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "⛈️ Map 接口 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/map/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/map/",
      "content_html": "<h2 id=\"map-接口有哪些实现类\"> Map 接口有哪些实现类？</h2>\n<iframe :src=\"$withBase('/mindmap/map_summary.html')\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n<p>详细介绍请见：</p>\n<ol>\n<li><a href=\"/interview/java-collection/map/hashmap\">HashMap</a></li>\n<li><a href=\"/interview/java-collection/map/hashtable\">HashTable</a></li>\n<li><a href=\"/interview/java-collection/map/concurrenthashmap\">ConcurrentHashMap</a></li>\n<li><a href=\"/interview/java-collection/map/linkedhashmap\">LinkedHashMap</a></li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "⛹️ LinkedHashMap",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/map/linkedhashmap/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/map/linkedhashmap/",
      "content_html": "<h2 id=\"linkedhashmap-的特点\"> LinkedHashMap 的特点？</h2>\n<p>在 <code>HashMap</code> 的基础上，使用了双向链表保存他们的顺序。如果成员变量 <code>accessOrder</code> 为 <code>true</code>，则表示使用最近最少使用顺序（LRU），否则是插入顺序（默认就是插入顺序）。通过继承 <code>LinkedHashMap</code>，并重写 <code>removeEldestEntry</code> 方法可以快速的实现一个 LRU 缓存。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 Java 容器 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/",
      "content_html": "<p>容器是一种保存其他的数据的数据结构，在 Java 中其使用是非常广泛的，因此它也是面试的重点，尤其是线程不安全的 <code>HashMap</code> 与线程安全的 <code>ConcurrentHashMap</code>，这俩真是面试必问的问题。</p>\n<p>容器主要可以分为以下几部分，根据不同的实现方式，各个接口也提供了多样的实现类，可以根据具体的使用场景选择更为合适的容器：</p>\n<ol>\n<li><a href=\"/interview/java-collection/set\">Set</a>：一种保存不重复元素的容器</li>\n<li><a href=\"/interview/java-collection/list\">List</a>：一种按照顺序保存元素的容器</li>\n<li><a href=\"/interview/java-collection/map\">Map</a>：一种保存某种映射关系的容器</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🏌️ HashSet",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/set/hashset/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/set/hashset/",
      "content_html": "<h2 id=\"介绍一下-hashset\"> 介绍一下 HashSet？</h2>\n<p>基于哈希表实现，支持快速查找，但不支持有序性操作，也就是说会失去元素的插入顺序信息，所以使用迭代器遍历 <code>HashSet</code> 时得到的结果是不确定的。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🏄 LinkedHashSet",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/set/linkedhashset/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/set/linkedhashset/",
      "content_html": "<h2 id=\"介绍一下-linkedhashset\"> 介绍一下 LinkedHashSet？</h2>\n<p>具有 <code>HashSet</code> 的查找效率，并且内部使用双向链表维护元素的插入顺序。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌧️ Set 接口 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/set/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/set/",
      "content_html": "<h2 id=\"set-接口有哪些实现类\"> Set 接口有哪些实现类？</h2>\n<iframe :src=\"$withBase('/mindmap/set_summary.html')\" width=\"100%\" height=\"400\" frameborder=\"0\" scrolling=\"No\" leftmargin=\"0\" topmargin=\"0\"></iframe>\n<p>详细介绍请见：</p>\n<ol>\n<li><a href=\"/interview/java-collection/set/treeset\">TreeSet</a></li>\n<li><a href=\"/interview/java-collection/set/hashset\">HashSet</a></li>\n<li><a href=\"/interview/java-collection/set/linkedhashset\">LinkedHashSet</a></li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "⛷️ TreeSet",
      "url": "https://blog.lixiangyu.xyz/interview/java-collection/set/treeset/",
      "id": "https://blog.lixiangyu.xyz/interview/java-collection/set/treeset/",
      "content_html": "<h2 id=\"介绍一下-treeset\"> 介绍一下 TreeSet？</h2>\n<p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 <code>HashSet</code>，<code>HashSet</code> 查找的时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>1</span><span>)</span></span></span></span>，<code>TreeSet</code> 则为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.10903em;\">N</span><span>)</span></span></span></span>。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙈 JMM",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/jmm/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/jmm/",
      "content_html": "<h2 id=\"什么是-java-内存模型-jmm\"> 什么是 Java 内存模型（JMM）？<i>Not supported content</i></h2>\n<p>JVM 规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。它主要规定了：一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>\n<h2 id=\"什么是主内存和工作内存\"> 什么是主内存和工作内存？<i>Not supported content</i></h2>\n<p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/Qh7z2FIY5jasHUk.png\" alt=\"JMM.jpg\" /></p>\n</div>\n<h2 id=\"内存间交互的命令\"> 内存间交互的命令？</h2>\n<p>线程间如果需要通讯，那么首先会将工作内存刷新到主内存中，另一个线程再从主内存读取最新的变量值。Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p>\n<ul>\n<li><code>read</code>：把一个变量的值从主内存传输到工作内存中</li>\n<li><code>load</code>：在 <code>read</code> 之后执行，把 <code>read</code> 得到的值放入工作内存的变量副本中</li>\n<li><code>use</code>：把工作内存中一个变量的值传递给执行引擎</li>\n<li><code>assign</code>：把一个从执行引擎接收到的值赋给工作内存的变量</li>\n<li><code>store</code>：把工作内存的一个变量的值传送到主内存中</li>\n<li><code>write</code>：在 <code>store</code> 之后执行，把 <code>store</code> 得到的值放入主内存的变量中</li>\n<li><code>lock</code>：作用于主内存的变量，把一个变量标识为一条线程独占状态</li>\n<li><code>unlock</code>：作用于主存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>\n</ul>\n<h2 id=\"内存模型的三大特性是什么\"> 内存模型的三大特性是什么？</h2>\n<h3 id=\"原子性\"> 原子性</h3>\n<p>Java 内存模型保证了这些操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p>\n<h3 id=\"可见性\"> 可见性</h3>\n<p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有三种实现方式实现可见性：</p>\n<ul>\n<li><code>volatile</code>（再次强调 <code>volatile</code> 只保证可见性不保证原子性）</li>\n<li><code>synchronized</code>，对一个变量执行 <code>unlock</code> 操作之前，必须把变量值同步回主内存</li>\n<li><code>final</code>，被 <code>final</code> 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 <code>this</code> 逃逸（其它线程通过 <code>this</code> 引用访问到初始化了一半的对象），那么其它线程就能看见 <code>final</code> 字段的值</li>\n</ul>\n<h3 id=\"有序性\"> 有序性</h3>\n<p>有序性是指在本线程内观察，所有操作都是有序的（指本线程内是串行操作）。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序（或者是主内存和工作内存之间的延迟）。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>\n<p><code>volatile</code> 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。也可以通过 <code>synchronized</code> 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p>\n<h2 id=\"什么是先行发生原则\"> 什么是先行发生原则？</h2>\n<p>除了上面提到的可以用 <code>volatile</code> 和 <code>synchronized</code> 来保证有序性，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。对于以下提到的内容，JVM 可以保证它的执行顺序，初次之外的内容 JVM 就可以随意的进行重排：</p>\n<ul>\n<li>单一线程原则：在一个线程内，在前面的操作先行发生于后面的操作</li>\n<li>管程锁定规则：一个 <code>unlock</code> 操作先行发生于后面对同一个锁的 <code>lock</code> 操作</li>\n<li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 变量的写操作先行发生于后面对这个变量的读操作</li>\n<li>线程启动规则：<code>Thread</code> 对象的 <code>start()</code> 方法调用先行发生于此线程的每一个动作</li>\n<li>线程加入规则：线程中的所有操作都先行发生于对此线程的终止检测</li>\n<li>线程中断规则：对线程 <code>interrupt()</code> 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 <code>interrupted()</code> 方法检测到是否有中断发生</li>\n<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 <code>finalize()</code> 方法的开始</li>\n<li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/07/30/Qh7z2FIY5jasHUk.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 Java I/O - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-io/",
      "id": "https://blog.lixiangyu.xyz/interview/java-io/",
      "content_html": "<p>待完善。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🐵 J.U.C",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/juc/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/juc/",
      "content_html": "<h2 id=\"什么是-j-u-c\"> 什么是 J.U.C？</h2>\n<p>J.U.C 指 <code>java.util.concurrent</code> 包，在这个包中增加了很多并发编程中常用的工具类，大大提高了并发性能，其中 AQS（<code>AbstractQueuedSynchronizer</code>）被认为是 J.U.C 的核心。</p>\n<h2 id=\"什么是-aqs\"> 什么是 AQS？<i>Not supported content</i></h2>\n<p><code>AbstractQueueSynchronizer</code>，即抽象队列同步器，通常被称为 AQS，是用于构造锁、同步组件的基础框架，它使用一个 <code>int</code> 类型变量 <code>state</code> 来表示同步状态（这个变量使用 <code>volatile</code> 关键字修饰，保证多线程状况下的可见性），使用内置 FIFO 双向队列来完成线程的排队工作。<code>ReentrantLock</code>，<code>Semaphore</code>， <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等皆是基于 AQS 的。</p>\n<p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</p>\n<div><p>CLH 队列</p>\n<p>CLH（Craig, Landin, and Hagersten）队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>\n</div>\n<div><p>面试时的回答</p>\n<ol>\n<li>什么是 AQS：AQS 是 JDK 中提供的抽象队列同步器，<code>Lock</code> 接口的实现类一般内部都维护了一个 AQS 的实现类（比如 <code>FairSync</code>、<code>NonFairSync</code>）。AQS 内部维护了一个双向队列和 <code>int</code> 类型的变量 <code>state</code> 来实现对共享变量的共享。</li>\n<li>线程到来后双向队列如何维护：如果有一个线程 A 希望使用资源，并且此时没有其他线程在使用资源，那么会把它放到双向队列的队首。其他线程比如线程 B、线程 C，如果希望使用这个资源，会依次放入队尾，并做自旋等待。</li>\n<li>线程使用完毕如何竞争：当线程 A 使用完毕后，会释放资源。后续排队的线程有两种方式来竞争资源：一种是公平式，即按照排队顺序依次使用；另一种是非公平式，所以等待的线程共同去抢，谁抢到算谁的。</li>\n<li>可重入性：如果同一线程多次访问资源，<code>state</code> 会依次加一，并记录当前的线程名称。释放时需要这个线程的所有访问全部释放，即 <code>state</code> 减至 0。</li>\n<li>为什么使用双向队列：方便操作队首和队尾元素。</li>\n</ol>\n</div>\n<p>原理图如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/WFibfJ3TLQ7v6q9.png\" alt=\"AQS.jpg\" /></p>\n</div>\n<h2 id=\"aqs-的资源共享方式有哪几种\"> AQS 的资源共享方式有哪几种？</h2>\n<h3 id=\"exclusive-独占\"> Exclusive（独占）</h3>\n<p>只有一个线程能执行，如 <code>ReentrantLock</code>，可继续细分为公平锁和非公平锁：</p>\n<ul>\n<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>\n<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢，谁抢到就是谁的</li>\n</ul>\n<h3 id=\"share-共享\"> Share（共享）</h3>\n<p>多个线程可同时执行，如 <code>CountDownLatch</code>、<code>Semaphore</code>、<code>CyclicBarrier</code>、<code>ReadWriteLock</code>。</p>\n<h2 id=\"如何通过-aqs-自定义一个同步器\"> 如何通过 AQS 自定义一个同步器？</h2>\n<p>AQS 的设计是基于模板模式的，如果需要实现一个自定义同步器，一般的方式是这样的：</p>\n<ul>\n<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法，这些方法是对于共享资源 <code>state</code> 的获取和释放的规则</li>\n<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，这些模板方法会调用重写的方法</li>\n</ul>\n<p>需要实现的方法包括：</p>\n<ul>\n<li><code>isHeldExclusively()</code>：该线程是否正在独占资源，只有用到 condition 才需要去实现它</li>\n<li><code>tryAcquire(int)</code>：独占方式，尝试获取资源</li>\n<li><code>tryRelease(int)</code>：独占方式，尝试释放资源</li>\n<li><code>tryAcquireShared(int)</code>：共享方式，尝试获取资源</li>\n<li><code>tryReleaseShared(int)</code>：共享方式，尝试释放资源</li>\n</ul>\n<p>虽然不同的自定义同步器争用共享资源的方式是不同的，但是在实现时只需要实现共享资源 <code>state</code> 的获取与释放方式即可，至于等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了，使用者不需要关注。</p>\n<h2 id=\"什么是-countdownlatch\"> 什么是 CountDownLatch？</h2>\n<p><code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。示例代码如下：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>int</span> total <span>=</span> <span>10</span><span>;</span>\n    <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>total<span>)</span><span>;</span>\n    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> total<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>int</span> value <span>=</span> i<span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value <span>+</span> <span>\" is running\"</span><span>)</span><span>;</span>\n            countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>try</span> <span>{</span>\n        countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"end\"</span><span>)</span><span>;</span>\n    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"什么是-cyclicbarrier\"> 什么是 CyclicBarrier？</h2>\n<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。<code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。示例代码如下：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>int</span> total <span>=</span> <span>10</span><span>;</span>\n    <span>CyclicBarrier</span> cyclicBarrier <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span>total<span>)</span><span>;</span>\n    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> total<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>int</span> value <span>=</span> i<span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value <span>+</span> <span>\" before\"</span><span>)</span><span>;</span>\n            <span>try</span> <span>{</span>\n                cyclicBarrier<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>|</span> <span>BrokenBarrierException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value <span>+</span> <span>\"after\"</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id=\"什么是-semaphore\"> 什么是 Semaphore？</h2>\n<p><code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源（但同一线程可以多次进入同步块，也就是可重入性），<code>Semaphore</code>（信号量）可以指定多个线程同时访问某个资源。实例代码如下：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>int</span> total <span>=</span> <span>3</span><span>;</span>\n    <span>Semaphore</span> semaphore <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span>total<span>)</span><span>;</span>\n    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>int</span> value <span>=</span> i<span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            <span>try</span> <span>{</span>\n                semaphore<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span>\n                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value <span>+</span> <span>\" is running \"</span> <span>+</span> semaphore<span>.</span><span>availablePermits</span><span>(</span><span>)</span><span>)</span><span>;</span>\n            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span> <span>finally</span> <span>{</span>\n                semaphore<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"什么是-futuretask\"> 什么是 FutureTask？</h2>\n<p>在介绍 [Java 中如何使用线程](/pages/1de94c/#在 Java 中如何使用线程？)时，有说道实现 <code>Callable</code> 接口是可以有返回值的，返回值通过 <code>Future</code> 进行封装。<code>FutureTask</code> 实现了 <code>RunnableFuture</code> 接口，该接口继承自 <code>Runnable</code> 和 <code>Future</code> 这使得 <code>FutureTask</code> 既可以当做一个任务执行，也可以有返回值。</p>\n<h2 id=\"什么是-blockingqueue\"> 什么是 BlockingQueue？</h2>\n<p><code>BlockingQueue</code> 接口有以下阻塞队列的实现：</p>\n<ul>\n<li>FIFO 队列 ：<code>LinkedBlockingQueue</code>、<code>ArrayBlockingQueue</code>（固定长度）</li>\n<li>优先级队列 ：<code>PriorityBlockingQueue</code></li>\n</ul>\n<p>提供了阻塞的 <code>take()</code> 和 <code>put()</code> 方法：如果队列为空 <code>take()</code> 将阻塞，直到队列中有内容；如果队列已满，<code>put()</code> 方法将阻塞，直到队列有空闲位置。</p>\n<h2 id=\"什么是-forkjoin\"> 什么是 ForkJoin？</h2>\n<p>主要用于并行计算中，和 <code>MapReduce</code> 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p>\n",
      "image": "https://i.loli.net/2021/07/30/WFibfJ3TLQ7v6q9.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🐒 锁",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/lock/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/lock/",
      "content_html": "<h2 id=\"什么是互斥同步\"> 什么是互斥同步？</h2>\n<p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁，下面会提到）。互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p>\n<h2 id=\"介绍一下-synchronized-关键字\"> 介绍一下 Synchronized 关键字？<i>Not supported content</i></h2>\n<p><code>synchronized</code> 关键字可用于：</p>\n<ul>\n<li>同步一个代码块</li>\n<li>同步一个方法（可以为静态方法）</li>\n<li>同步一个类</li>\n</ul>\n<p><code>synchronized</code> 可以保证可见性，因为：</p>\n<ul>\n<li>线程加锁前，会清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值</li>\n<li>线程解锁前，必须把共享变量的最新值刷新到主内存中</li>\n</ul>\n<div><p>synchronized 在字节码中的实现</p>\n<ul>\n<li>同步代码块时使用 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置</li>\n<li>同步方法时并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的是使用 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法</li>\n</ul>\n</div>\n<div><p>Mark Word</p>\n<p>在 JVM 中对象是分成三部分存在的：对象头（header）、实例数据（instance Data）、对齐填充（padding）。实例数据存放类的属性数据信息，包括父类的属性信息，如果是数组，那么实例部分还包括数组的长度，这部分内存按 4 字节对齐。对齐填充不是必须部分，由于虚拟机要求对象起始地址必须是 8 字节的整数倍，对齐填充仅仅是为了使字节对齐。</p>\n<p>对象头是 <code>synchronized</code> 实现锁的基础，因为 <code>synchronized</code> 申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由 Mark Word 和 Class Metadata Address 组成的，其中 Mark Word 存储对象的哈希值、锁信息、分代年龄、GC 标志等信息，Class Metadata Address 是类型指针指向对象的类元数据，JVM 通过该指针确定该对象是哪个类的实例。</p>\n<p>其中 Mark Word 的锁信息就体现了锁的状态：</p>\n<ul>\n<li>无锁</li>\n<li>偏向锁：多数情况下，锁不仅不存在竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁，见锁优化部分的第五点</li>\n<li>轻量级锁：如果明显存在其他线程申请锁，那么偏向锁将很快升级为轻量级锁</li>\n<li>重量级锁：指原始的 <code>synchronized</code> 的实现，其他线程试图获取锁时都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程</li>\n</ul>\n</div>\n<h2 id=\"介绍一下-reentrantlock-类\"> 介绍一下 ReentrantLock 类？</h2>\n<p><code>ReentrantLock</code> 是 J.U.C 包中提供的锁。示例代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Lock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>Main</span><span>::</span><span>func</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>Main</span><span>::</span><span>func</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>func</span><span>(</span><span>)</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n                <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>i <span>+</span> <span>\" \"</span><span>)</span><span>;</span>\n            <span>}</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id=\"它们两个有什么区别\"> 它们两个有什么区别？<i>Not supported content</i></h2>\n<p>这个问题可以泛指为 <code>synchronized</code> 和 <code>Lock</code> 接口的区别。</p>\n<ul>\n<li>锁的实现：<code>synchronized</code> 是 JVM 实现，<code>ReentrantLock</code> 是 JDK 实现的</li>\n<li>性能： Java 对 <code>synchronized</code> 进行了很多优化，例如自旋锁等，<code>synchronized</code> 与 <code>ReentrantLock</code> 的性能大致相同</li>\n<li>等待可中断： 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<code>ReentrantLock</code> 可中断，而 <code>synchronized</code> 不行</li>\n<li>公平锁：<code>synchronized</code> 中的锁是非公平的，<code>ReentrantLock</code> 默认情况下也是非公平的，但是也可以是公平的</li>\n<li>锁的绑定条件：一个 <code>ReentrantLock</code> 可以同时绑定多个 <code>Condition</code> 对象，所以它更为灵活</li>\n</ul>\n<div><p>锁的使用</p>\n<p>除非需要使用 <code>ReentrantLock</code> 的高级功能，否则优先使用 <code>synchronized</code>。这是因为 <code>synchronized</code> 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 <code>ReentrantLock</code> 不是所有的 JDK 版本都支持。并且使用 <code>synchronized</code> 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>\n</div>\n<h2 id=\"什么是非阻塞同步\"> 什么是非阻塞同步？</h2>\n<p>与悲观策略不同，还可以使用一种基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步，即乐观锁。</p>\n<h2 id=\"什么是-cas\"> 什么是 CAS？<i>Not supported content</i></h2>\n<p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p>\n<div><p>Unsafe 类</p>\n<p>有关 CAS 的操作可以在 <code>Unsafe</code> 类中查看，CAS 在不能成功交换时会进行自旋。</p>\n</div>\n<h2 id=\"cas-存在的问题\"> CAS 存在的问题？<i>Not supported content</i></h2>\n<h3 id=\"aba-问题\"> ABA 问题</h3>\n<p>如果一个变量初次读取的时候是 A，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。J.U.C 包提供了一个带有标记的原子引用类 <code>AtomicStampedReference</code> 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>\n<h3 id=\"自旋消耗资源\"> 自旋消耗资源</h3>\n<p>CAS 如果长时间不成功，会给CPU带来非常大的执行开销，如果 JVM 能支持处理器提供的 <code>pause</code> 指令，那么效率会有一定的提升。<code>pause</code> 指令有两个作用：</p>\n<ul>\n<li>它可以延迟流水线执行指令（de-pipeline），使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>\n<li>它可以避免在循环的时候因内存顺序冲突（Memory Order Violation）而引起 CPU 流水线被清空，从而提高 CPU 的实行效率</li>\n</ul>\n<h3 id=\"多变量共享一致性问题\"> 多变量共享一致性问题</h3>\n<p>CAS 操作是针对一个变量的，如果对多个变量操作：</p>\n<ul>\n<li>可以加锁</li>\n<li>封装成对象类</li>\n</ul>\n<h2 id=\"介绍一下-atomicinteger-类\"> 介绍一下 AtomicInteger 类？</h2>\n<p>J.U.C 包里面的整数原子类 <code>AtomicInteger</code> 的方法调用了 <code>Unsafe</code> 类的 CAS 操作来保证线程安全。示例代码如下：</p>\n<div><pre><code><span>private</span> <span>static</span> <span>AtomicInteger</span> value <span>=</span> <span>new</span> <span>AtomicInteger</span><span>(</span><span>)</span><span>;</span>\n\n<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>int</span> total <span>=</span> <span>1000</span><span>;</span>\n    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n    <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span>total<span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> total<span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n            value<span>.</span><span>incrementAndGet</span><span>(</span><span>)</span><span>;</span>\n            countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span><span>)</span><span>;</span>\n    <span>}</span>\n    executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><code>incrementAndGet()</code> 会调用 <code>Unsafe</code> 包中的 <code>getAndAddInt</code>，其中：</p>\n<ul>\n<li><code>var1</code> 为原子类对象</li>\n<li><code>var2</code> 为该字段相对对象内存地址的偏移</li>\n<li><code>var4</code> 为要增加的数值，这里为 1</li>\n<li><code>var5</code> 为旧的预期值</li>\n</ul>\n<p>通过 <code>compareAndSwapInt</code> 进行比较并交换，如果失败会一直自旋。</p>\n<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> var1<span>,</span> <span>long</span> var2<span>,</span> <span>int</span> var4<span>)</span> <span>{</span>\n    <span>int</span> var5<span>;</span>\n    <span>do</span> <span>{</span>\n        var5 <span>=</span> <span>this</span><span>.</span><span>getIntVolatile</span><span>(</span>var1<span>,</span> var2<span>)</span><span>;</span>\n    <span>}</span> <span>while</span><span>(</span><span>!</span><span>this</span><span>.</span><span>compareAndSwapInt</span><span>(</span>var1<span>,</span> var2<span>,</span> var5<span>,</span> var5 <span>+</span> var4<span>)</span><span>)</span><span>;</span>\n\n    <span>return</span> var5<span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"锁优化\"> 锁优化 <i>Not supported content</i></h2>\n<h3 id=\"什么是自旋锁\"> 什么是自旋锁？</h3>\n<p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p>\n<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>\n<h3 id=\"什么是锁消除\"> 什么是锁消除？</h3>\n<p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p>\n<h3 id=\"什么是锁粗化\"> 什么是锁粗化？</h3>\n<p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到有这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部，减少加锁的次数。</p>\n<h3 id=\"什么是轻量级锁\"> 什么是轻量级锁？</h3>\n<p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p>\n<h3 id=\"什么是偏向锁\"> 什么是偏向锁？</h3>\n<p>偏向锁的思想是：偏向于第一个获取锁对象的线程，这个线程在之后获取该锁时就不再需要进行同步操作，甚至连 CAS 操作也不再需要。当锁对象第一次被线程获得的时候，进入偏向状态，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。但是只要有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时会撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p>\n<h2 id=\"在-java-中怎么排查死锁\"> 在 Java 中怎么排查死锁？</h2>\n<p>首先模拟一下死锁：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>A</span><span>::</span><span>method</span><span>,</span> <span>\"Thread A\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n        <span>new</span> <span>Thread</span><span>(</span><span>B</span><span>::</span><span>method</span><span>,</span> <span>\"Thread B\"</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>A</span> <span>{</span>\n    <span>public</span> <span>synchronized</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\": method from A\"</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>3000</span><span>)</span><span>;</span>\n            <span>B</span><span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>B</span> <span>{</span>\n    <span>public</span> <span>synchronized</span> <span>static</span> <span>void</span> <span>method</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>\": method from B\"</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>3000</span><span>)</span><span>;</span>\n            <span>A</span><span>.</span><span>method</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>线程 A 首先调用了 A 类中的同步方法，休眠 3 秒再继续调用 B 类中的同步方法。但是 B 类中的同步方法已经被线程 B 所调用，而线程 B 正在等待调用线程 A 的同步方法，所以双方会死锁。执行代码后将只会得到：</p>\n<div><pre><code>Thread A: method from A \nThread B: method from B\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p>可以使用 <code>jstack -l &lt;pid&gt;</code> 命令查看线程信息：</p>\n<div><pre><code>&quot;Thread A&quot; #11 prio=5 os_prio=0 tid=0x000000001e899800 nid=0x32c4 waiting for monitor entry [0x000000001f3af000] \n   java.lang.Thread.State: BLOCKED (on object monitor) \n        at xyz.lixiangyu.demo.B.method(Main.java:25) \n        - waiting to lock &amp;lt;0x000000076b61f5f0&gt; (a java.lang.Class for xyz.lixiangyu.demo.B) \n        at xyz.lixiangyu.demo.A.method(Main.java:16) \n        - locked &amp;lt;0x000000076b3a45c0&gt; (a java.lang.Class for xyz.lixiangyu.demo.A) \n        at xyz.lixiangyu.demo.Main$$Lambda$1/1174361318.run(Unknown Source) \n        at java.lang.Thread.run(Thread.java:748) \n \n   Locked ownable synchronizers: \n        - None\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>另外在 <code>jstack</code> 命令的输出中可以看到 Java 已经分析到了出现了死锁：</p>\n<div><pre><code>Found one Java-level deadlock: \n============================= \n&quot;Thread B&quot;: \n  waiting to lock monitor 0x000000001c5025d8 (object 0x000000076b3a45c0, a java.lang.Class), \n  which is held by &quot;Thread A&quot; \n&quot;Thread A&quot;: \n  waiting to lock monitor 0x000000001c4ffd48 (object 0x000000076b61f5f0, a java.lang.Class), \n  which is held by &quot;Thread B&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🦍 无同步方案",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/non-lock/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/non-lock/",
      "content_html": "<h2 id=\"什么是无同步方案\"> 什么是无同步方案？</h2>\n<p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无需任何同步措施去保证正确性。</p>\n<h2 id=\"什么是不可变对象\"> 什么是不可变对象？</h2>\n<p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p>\n<p>不可变的类型：</p>\n<ul>\n<li><code>final</code> 关键字修饰的基本数据类型</li>\n<li><code>String</code></li>\n<li>枚举类型</li>\n<li><code>Number</code> 部分子类，如 <code>Long</code> 和 <code>Double</code> 等数值包装类型，<code>BigInteger</code> 和 <code>BigDecimal</code> 等大数据类型，但同为 <code>Number</code> 的原子类 <code>AtomicInteger</code> 和 <code>AtomicLong</code> 则是可变的</li>\n</ul>\n<p>对于集合类型，可以使用 <code>Collections.unmodifiableXXX()</code> 方法来获取一个不可变的集合。这个方法会返回一个内部类，重写所有进行修改的方法，转为抛出 <code>UnsupportedOperationException</code> 异常。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Map</span><span><span>&lt;</span><span>String</span><span>,</span> <span>String</span><span>></span></span> map <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>\n    map <span>=</span> <span>Collections</span><span>.</span><span>unmodifiableMap</span><span>(</span>map<span>)</span><span>;</span>\n    map<span>.</span><span>put</span><span>(</span><span>\"1\"</span><span>,</span> <span>\"1\"</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id=\"如何通过栈封闭的方式解决线程安全的问题\"> 如何通过栈封闭的方式解决线程安全的问题？</h2>\n<p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，是属于线程私有的。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>Main</span><span>::</span><span>test</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>public</span> <span>static</span> <span>void</span> <span>test</span><span>(</span><span>)</span> <span>{</span>\n    <span>int</span> value <span>=</span> <span>100</span><span>;</span>\n    value <span>+=</span> <span>100</span><span>;</span>\n    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>value<span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id=\"如何使用-threadlocal-解决线程安全的问题\"> 如何使用 ThreadLocal 解决线程安全的问题？<i>Not supported content</i></h2>\n<p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，那么就可以把共享数据的可见范围限制在同一个线程之内，这样无须同步也能保证线程之间不出现数据争用的问题。</p>\n<p>可以使用 <code>ThreadLocal</code> 类来实现线程本地存储功能。对于以下代码，thread1 中设置 <code>threadLocal</code> 为 1，而 thread2 设置 <code>threadLocal</code> 为 2。过了一段时间之后，thread1 读取 <code>threadLocal</code> 依然是 1，不受 thread2 的影响。原因在于，每个线程内部维护了一个保存数据的 <code>ThreadLocalMap</code> ，在调用 <code>put()</code> 方法时会首先获取当前线程，然后对这个 <code>Map</code> 进行修改，所以不同线程之间是不受影响的。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ThreadLocal</span> threadLocal <span>=</span> <span>new</span> <span>ThreadLocal</span><span>(</span><span>)</span><span>;</span>\n    <span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n        threadLocal<span>.</span><span>set</span><span>(</span><span>1</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>threadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        threadLocal<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n    <span>Thread</span> thread2 <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>\n        threadLocal<span>.</span><span>set</span><span>(</span><span>2</span><span>)</span><span>;</span>\n        threadLocal<span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n    thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    thread2<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><p>ThreadLocal 的内存泄漏</p>\n<p>每个 <code>Thread</code> 中都存在一个 <code>Map</code>，这个 <code>Map</code> 的类型是 <code>ThreadLocal.ThreadLocalMap</code>。<code>Map</code> 中的 <code>key</code> 为一个 <code>ThreadLocal</code> 实例，但是是这个实例的<strong>弱引用</strong>。当把 <code>ThreadLocal</code> 实例置为空以后，没有任何强引用指向它，所以 <code>ThreadLocal</code> 将会被 GC 回收，但是 <code>value</code> 却不能回收，因为存在<strong>一条从当前线程连接过来的强引用</strong>。只有当线程结束以后，强引用断开，<code>Map</code> 和其中未被回收的 <code>value</code> 才会被 GC 回收。出现内存泄漏的原因在于 <code>ThreadLocalMap</code> 的生命周期和 <code>Thread</code> 一样长，而不是因为使用了弱引用。\n由于现在基本都使用线程池的方式来管理线程，所以不可能等到线程结束再去释放内存，导致程序运行期间这块内存将永远无法回收。所以如果需要使用 <code>ThreadLocal</code> 记得及时 <code>remove()</code>。</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙉 进程和线程",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/process-thread/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/process-thread/",
      "content_html": "<h2 id=\"什么是进程\"> 什么是进程？</h2>\n<p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>\n<h2 id=\"什么是线程\"> 什么是线程？</h2>\n<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>\n<h2 id=\"在-java-中如何使用线程\"> 在 Java 中如何使用线程？<i>Not supported content</i></h2>\n<CodeGroup>\n<CodeGroupItem title=\"实现 Runnable 接口\">\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Runnable</span> runnable <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"i am running...\"</span><span>)</span><span>;</span>\n    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>runnable<span>)</span><span>;</span>\n    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"实现 Callable 接口\" active>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>Callable</span><span><span>&lt;</span><span>Integer</span><span>></span></span> callable <span>=</span> <span>(</span><span>)</span> <span>-></span> <span>10</span><span>;</span>\n    <span>FutureTask</span><span><span>&lt;</span><span>Integer</span><span>></span></span> task <span>=</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>></span></span><span>(</span>callable<span>)</span><span>;</span>\n    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>task<span>)</span><span>;</span>\n    thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>try</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>task<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>|</span> <span>ExecutionException</span> e<span>)</span> <span>{</span>\n        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<div><p>继承 Thread 类</p>\n<p>直接继承 <code>Thread</code> 类也可以实现相同的，但相比较而言，实现接口的方式更好，因为更加灵活。而 <code>Runnable</code> 和 <code>Callable</code> 接口的区别在于是否希望获得返回值。</p>\n</div>\n<h2 id=\"java-中的线程状态\"> Java 中的线程状态</h2>\n<p>根据枚举类 <code>Thread.State</code> 中定义的，在 Java 中线程状态可分为以下六种：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">NEW</td>\n<td style=\"text-align:center\">创建后尚未启动。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RUNNABLE</td>\n<td style=\"text-align:center\">正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BLOCKED</td>\n<td style=\"text-align:center\">请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以处于阻塞状态。要结束该状态并进入 RUNNABLE 状态需要其他线程释放 monitor lock。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">WAITING</td>\n<td style=\"text-align:center\">无限期等待直到其它线程将它唤醒。阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TIMED_WAITING</td>\n<td style=\"text-align:center\">有限期等待，在一定时间之后会被系统自动唤醒。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TERMINATED</td>\n<td style=\"text-align:center\">可以是线程结束任务之后自己结束，或者产生了异常而结束。</td>\n</tr>\n</tbody>\n</table>\n<p>线程状态转移图如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/1bXQPKWUMCN7HVh.png\" alt=\"线程状态转移图.jpg\" /></p>\n</div>\n<h2 id=\"线程间协作的方式有哪些\"> 线程间协作的方式有哪些？</h2>\n<p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p>\n<h3 id=\"join\"> join()</h3>\n<p>在线程中调用另一个线程的 <code>join()</code> 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。示例代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ThreadB</span> threadB <span>=</span> <span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>;</span>\n        threadB<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>ThreadA</span> <span>extends</span> <span>Thread</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"a running...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>ThreadB</span> <span>extends</span> <span>Thread</span> <span>{</span>\n    <span>@Override</span>\n    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>\n        <span>ThreadA</span> threadA <span>=</span> <span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            threadA<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>\n            threadA<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"b running...\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id=\"wait-notify-notifyall\"> wait()，notify()，notifyAll()</h3>\n<p>调用 <code>wait()</code> 使得线程进入无限等待状态直到被唤醒。线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 <code>notify()</code> 或者 <code>notifyAll()</code> 来唤醒挂起的线程。</p>\n<p>使用 <code>wait()</code> 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 <code>notify()</code> 或者 <code>notifyAll()</code> 来唤醒挂起的线程，造成死锁。</p>\n<p>它们都位于 <code>Object</code> 类中，而不属于 <code>Thread</code>。另外这些方法时只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 <code>IllegalMonitorStateException</code> 异常。示例代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n        <span>WaitNotifyExample</span> example <span>=</span> <span>new</span> <span>WaitNotifyExample</span><span>(</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> example<span>.</span><span>after</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> example<span>.</span><span>before</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>WaitNotifyExample</span> <span>{</span>\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n        <span>notifyAll</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>synchronized</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        <span>try</span> <span>{</span>\n            <span>wait</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><div><p>wait() 和 sleep() 的区别</p>\n<p><code>wait()</code> 是 <code>Object</code> 类中的方法，而 <code>sleep()</code> 是 <code>Thread</code> 的静态方法；<code>wait()</code> 会释放锁，<code>sleep()</code> 不会。</p>\n</div>\n<h3 id=\"await-signal-signalall\"> await()，signal()，signalAll()</h3>\n<p>J.U.C 包中提供了 <code>Condition</code> 类来实现线程之间的协调，可以在 <code>Condition</code> 上调用 <code>await()</code> 方法使线程等待，其它线程调用 <code>signal()</code> 或 <code>signalAll()</code> 方法唤醒等待的线程。\n相比于 <code>wait()</code> 这种等待方式，<code>await()</code> 可以指定等待的条件，因此更加灵活。</p>\n<p>示例代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>ExecutorService</span> executorService <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>\n        <span>AwaitSignalExample</span> example <span>=</span> <span>new</span> <span>AwaitSignalExample</span><span>(</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> example<span>.</span><span>after</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> example<span>.</span><span>before</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        executorService<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n\n<span>class</span> <span>AwaitSignalExample</span> <span>{</span>\n    <span>private</span> <span>final</span> <span>Lock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>\n    <span>private</span> <span>final</span> <span>Condition</span> condition <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>\n\n    <span>public</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"before\"</span><span>)</span><span>;</span>\n            condition<span>.</span><span>signalAll</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>public</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>\n        lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            condition<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"after\"</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span> <span>finally</span> <span>{</span>\n            lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div>",
      "image": "https://i.loli.net/2021/07/30/1bXQPKWUMCN7HVh.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 Java 并发 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/",
      "content_html": "<p>多线程开发是老生常谈的问题了，最重要的是如何保证多线程情况下数据的一致性。本部分包含以下几个内容：</p>\n<ol>\n<li><a href=\"/interview/java-multithread/jmm\">JMM</a>：JVM 定义的 Java 内存模型</li>\n<li><a href=\"/interview/java-multithread/process-thread\">进程和线程</a>：看看在 Java 中如何使用线程以及如何解决多线程之间的协作问题</li>\n<li><a href=\"/interview/java-multithread/thread-pool\">线程池</a>：频繁创建线程的开销太大，使用池化思想缓存线程</li>\n<li><a href=\"/interview/java-multithread/juc\">J.U.C</a>：JDK 提供的适用于并发编程的工具类</li>\n<li><a href=\"/interview/java-multithread/lock\">锁</a>：如何通过锁来保证线程安全以及锁的优化</li>\n<li><a href=\"/interview/java-multithread/non-lock\">无同步方案</a>：某些情况下不需使用锁也可以保证线程安全</li>\n</ol>\n<hr>\n<p>在实际开发过程中，提供一些建议：</p>\n<ul>\n<li>给线程起个有意义的名字，这样可以方便找日志</li>\n<li>缩小同步范围，从而减少锁争用，例如对于 <code>synchronized</code>，应该尽量同步代码块而不是同步方法</li>\n<li>多用同步工具少用 <code>wait()</code> 和 <code>notify()</code>。因为 <code>CountDownLatch</code>，<code>CyclicBarrier</code> 和 <code>Semaphore</code> 这些同步类简化了编码操作，而用 <code>wait()</code> 和 <code>notify()</code> 很难实现复杂控制流</li>\n<li>使用 <code>BlockingQueue</code> 实现生产者消费者问题</li>\n<li>多用并发集合少用同步集合，例如应该使用 <code>ConcurrentHashMap</code> 而不是 <code>Hashtable</code></li>\n<li>使用本地变量和不可变类来保证线程安全</li>\n<li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙊 线程池",
      "url": "https://blog.lixiangyu.xyz/interview/java-multithread/thread-pool/",
      "id": "https://blog.lixiangyu.xyz/interview/java-multithread/thread-pool/",
      "content_html": "<h2 id=\"什么是线程池\"> 什么是线程池？</h2>\n<p>线程池就是将一些线程保存在一个集合里，这个集合称为线程池。使用线程池可以很好地提高性能，线程池在系统启动时即创建大量空闲的线程，程序将一个任务传给线程池，线程池就会启动一条线程来执行这个任务，执行结束以后，该线程并不会死亡，而是再次返回线程池中成为空闲状态，等待执行下一个任务。</p>\n<div><p>使用线程池的好处</p>\n<ul>\n<li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>\n<li>提高响应速度：当任务到达时，任务可以不需要的等到线程创建就能立即执行</li>\n<li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>\n</ul>\n</div>\n<div><p>不要自行显式创建线程</p>\n<p>在阿里编程规范要求中指出：线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>\n<p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p>\n</div>\n<h2 id=\"如何创建一个线程池\"> 如何创建一个线程池？<i>Not supported content</i></h2>\n<p>通过 <code>ThreadPoolExecutor</code> 创建一个新的线程池：</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ThreadPoolExecutor</span> threadPoolExecutor <span>=</span>\n            <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>\n                    <span>10</span><span>,</span>\n                    <span>20</span><span>,</span>\n                    <span>10</span><span>,</span>\n                    <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>\n                    <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>int</span> value <span>=</span> i<span>;</span>\n        threadPoolExecutor<span>.</span><span>execute</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>\"running{\"</span> <span>+</span> value <span>+</span> <span>\"}\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n    threadPoolExecutor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><p>不要使用 Executors 创建线程池</p>\n<p>在阿里编程规范中明确表示：线程池不允许使用 <code>Executors</code> 去创建，而是应该通过 <code>ThreadPoolExecutor</code> 的方式来创建，这样的处理方式可以让开发人员更加明确线程池的运行规则，规避资源耗尽的风险。</p>\n<p>说明一下 <code>Executors</code> 各个方法的弊端：</p>\n<ol>\n<li><code>newFixedThreadPool</code> 和 <code>newSingleThreadExecutor</code></li>\n</ol>\n<p>主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至 OOM。</p>\n<ol start=\"2\">\n<li><code>newCachedThreadPool</code> 和 <code>newScheduledThreadPool</code></li>\n</ol>\n<p>主要问题是线程数最大数是 <code>Integer.MAX_VALUE</code>，可能会创建数量非常多的线程，甚至 OOM。</p>\n</div>\n<h2 id=\"介绍一下线程池的-7-个参数\"> 介绍一下线程池的 7 个参数？<i>Not supported content</i></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">名称</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">corePoolSize</td>\n<td style=\"text-align:center\">核心线程的线程数，定义了最小可以同时运行的线程数量。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maximumPoolSize</td>\n<td style=\"text-align:center\">当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">keepAliveTime</td>\n<td style=\"text-align:center\">当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">unit</td>\n<td style=\"text-align:center\">keepAliveTime 参数的时间单位。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">workQueue</td>\n<td style=\"text-align:center\">新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。可以使用 ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue、PriorityBlockingQueue 等。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">threadFactory</td>\n<td style=\"text-align:center\">创建一个新线程时使用的工厂，可以用来设定线程名、是否为守护线程等。默认使用 Executors.DefaultThreadFactory。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">handler</td>\n<td style=\"text-align:center\">拒绝策略，如果当前同时运行的线程数量达到最大线程数量并且队列也已经被填满，那么根据这个参数的不同取值，线程池将会采取不同的策略来处理新来的任务。包括：抛出异常拒绝任务、不抛出异常拒绝任务、在调用者线程中执行任务、抛弃最早进入队列的任务并将当前任务插入队列。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"submit-和-execute-方法有什么区别\"> submit 和 execute 方法有什么区别？</h2>\n<p>调用 <code>submit</code> 方法会返回一个 <code>Future</code> 类型的对象，通过这个对象可以获得运行结果。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n    <span>ThreadPoolExecutor</span> threadPoolExecutor <span>=</span>\n            <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>\n                    <span>10</span><span>,</span>\n                    <span>20</span><span>,</span>\n                    <span>10</span><span>,</span>\n                    <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>\n                    <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>\n    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>\n        <span>int</span> value <span>=</span> i<span>;</span>\n        <span>Future</span><span><span>&lt;</span><span>Object</span><span>></span></span> future <span>=</span> threadPoolExecutor<span>.</span><span>submit</span><span>(</span><span>(</span><span>)</span> <span>-></span> value<span>)</span><span>;</span>\n        <span>try</span> <span>{</span>\n            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>\n        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>|</span> <span>ExecutionException</span> e<span>)</span> <span>{</span>\n            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n    threadPoolExecutor<span>.</span><span>shutdown</span><span>(</span><span>)</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id=\"介绍一下任务调度的原理\"> 介绍一下任务调度的原理？<i>Not supported content</i></h2>\n<p>任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。了解这部分就相当于了解了线程池的核心运行机制。所有任务的调度都是由 <code>execute()</code> 方法完成的，这部分完成的工作是通过检查现在线程池的运行状态、运行线程数、运行策略来决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列中执行，亦或是直接拒绝该任务。</p>\n<p>具体的执行过程如下：</p>\n<ul>\n<li>如果要执行的任务为空，则抛出 <code>NPE</code></li>\n<li>如果 <code>workerCount</code> &lt; <code>corePoolSize</code>，则创建并启动一个线程来执行新提交的任务</li>\n<li>如果 <code>workerCount</code> &gt;= <code>corePoolSize</code>，且线程池内的阻塞队列未满，则将任务添加到阻塞队列中</li>\n<li>如果 <code>workerCount</code> &gt;= <code>corePoolSize</code> 并且 <code>workerCount</code> &lt; <code>maximumPoolSize</code>，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务</li>\n<li>如果 <code>workerCount</code> &gt;= <code>maximumPoolSize</code>，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常</li>\n</ul>\n<p>流程图如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/8yzHmhKQqcoJwSv.png\" alt=\"任务调度流程图.jpg\" /></p>\n</div>\n",
      "image": "https://i.loli.net/2021/07/30/8yzHmhKQqcoJwSv.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌙 垃圾回收机制",
      "url": "https://blog.lixiangyu.xyz/interview/jvm/gc/",
      "id": "https://blog.lixiangyu.xyz/interview/jvm/gc/",
      "content_html": "<h2 id=\"对象引用与回收\"> 对象引用与回收</h2>\n<p>垃圾收集主要是针对堆和方法区进行的，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>\n<h3 id=\"有哪几种引用类型\"> 有哪几种引用类型？</h3>\n<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型，按照顺序引用强度逐渐降低。</p>\n<h4 id=\"强引用\"> <strong>强引用</strong></h4>\n<p>被强引用关联的对象不会被回收，使用 <code>new</code> 关键字创建一个新对象时，就是创建了强引用。</p>\n<h4 id=\"软引用\"> <strong>软引用</strong></h4>\n<p>被软引用关联的对象只有在内存不够的情况下才会被回收，使用 <code>SoftReference</code> 类来创建软引用。</p>\n<h4 id=\"弱引用\"> <strong>弱引用</strong></h4>\n<p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前，使用 <code>WeakReference</code> 类来创建弱引用。</p>\n<h4 id=\"虚引用\"> <strong>虚引用</strong></h4>\n<p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知，需要和引用队列搭配起来使用，使用 <code>PhantomReference</code> 来创建虚引用。</p>\n<h3 id=\"如何判断对象是否可被回收\"> 如何判断对象是否可被回收？</h3>\n<p>可以使用引用计数法或者可达性分析算法来判断对象是否可被回收。</p>\n<h3 id=\"什么是引用计数算法\"> 什么是引用计数算法？</h3>\n<p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1，引用计数为 0 的对象表示可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。示例代码如下：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>\n    <span>public</span> <span>Object</span> instance <span>=</span> <span>null</span><span>;</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>Test</span> a <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>\n        <span>Test</span> b <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>\n        a<span>.</span>instance <span>=</span> b<span>;</span>\n        b<span>.</span>instance <span>=</span> a<span>;</span>\n        a <span>=</span> <span>null</span><span>;</span>\n        b <span>=</span> <span>null</span><span>;</span>\n        <span>doSomething</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id=\"什么是可达性分析算法\"> 什么是可达性分析算法？</h3>\n<p>以 GC Roots 为起始点进行搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。GC Roots 一般是以下内容：</p>\n<ul>\n<li>虚拟机栈中局部变量表中引用的对象</li>\n<li>本地方法栈中 JNI 中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中的常量引用的对象</li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/GpvU2nIrS4CjtD1.png\" alt=\"GC Root.jpg\" /></p>\n</div>\n<div><p>不要使用 finalize() 方法</p>\n<p>对象在被回收时，会调用 <code>Object</code> 类中的 <code>finalize()</code> 方法，如果调用该方法的时候能够重新使对象重新被引用，就可以实现自救，但自救的机会只有一次。</p>\n<p><strong>如无特殊情况不用使用这个方法。</strong></p>\n</div>\n<h3 id=\"如何判断一个类是否是无用的类\"> 如何判断一个类是否是无用的类？</h3>\n<p>类需要同时满足下面 3 个条件才能算是无用的类：</p>\n<ul>\n<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例</li>\n<li>加载该类的 <code>ClassLoader</code> 已经被回收</li>\n<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>\n</ul>\n<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是<strong>可以</strong>，而并不是和对象一样不使用了就会必然被回收。</p>\n<h2 id=\"内存分配与回收策略\"> 内存分配与回收策略</h2>\n<h3 id=\"什么是-minor-gc-和-full-gc\"> 什么是 Minor GC 和 Full GC？</h3>\n<h4 id=\"minor-gc\"> <strong>Minor GC</strong></h4>\n<p>回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。当 Eden 空间满时就会触发 Minor GC。</p>\n<h4 id=\"full-gc\"> <strong>Full GC</strong></h4>\n<p>回收新生代和老年代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</p>\n<p>Full GC 的触发条件：</p>\n<ol>\n<li>调用 <code>System.gc()</code></li>\n</ol>\n<p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p>\n<ol start=\"2\">\n<li>老年代空间不足</li>\n</ol>\n<p>老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 <code>-Xmn</code> 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p>\n<ol start=\"3\">\n<li>空间分配担保失败</li>\n</ol>\n<p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。</p>\n<ol start=\"4\">\n<li>JDK1.7 及以前的永久代空间不足</li>\n</ol>\n<p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 <code>java.lang.OutOfMemoryError</code>。为避免以上原因引起的 Full GC，可采用的方法为：增大永久代空间大小或转为使用 CMS GC。</p>\n<ol start=\"5\">\n<li>Concurrent Mode Failure</li>\n</ol>\n<p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p>\n<h3 id=\"jvm-的内存分配策略是什么\"> JVM 的内存分配策略是什么？</h3>\n<h4 id=\"对象优先在-eden-上分配\"> <strong>对象优先在 Eden 上分配</strong></h4>\n<p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p>\n<h4 id=\"大对象直接进入老年代\"> <strong>大对象直接进入老年代</strong></h4>\n<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。<code>-XX:PretenureSizeThreshold</code> 大于此参数值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p>\n<h4 id=\"长期存活的对象进入老年代\"> <strong>长期存活的对象进入老年代</strong></h4>\n<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。参数 <code>-XX:MaxTenuringThreshold</code> 用来定义年龄的阈值。</p>\n<h4 id=\"动态对象年龄判定\"> <strong>动态对象年龄判定</strong></h4>\n<p>虚拟机并不是永远要求对象的年龄必须达到 <code>MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 <code>MaxTenuringThreshold</code> 中要求的年龄。</p>\n<h4 id=\"空间分配担保\"> <strong>空间分配担保</strong></h4>\n<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 <code>HandlePromotionFailure</code> 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将会尝试着进行一次 Minor GC；如果小于或者 <code>HandlePromotionFailure</code> 的值不允许冒险，那么就要进行一次 Full GC。</p>\n<h2 id=\"垃圾回收算法\"> 垃圾回收算法<i>Not supported content</i></h2>\n<h3 id=\"什么是标记-清除算法\"> 什么是标记-清除算法？</h3>\n<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是针对它的不足进行改进得到的。这种垃圾收集算法会带来两个明显的问题：</p>\n<ul>\n<li>效率问题</li>\n<li>空间问题（标记清除后会产生大量不连续的碎片）</li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/SPvYVlhOpmgKwnJ.png\" alt=\"标记-清理.jpg\" /></p>\n</div>\n<h3 id=\"什么是标记-整理算法\"> 什么是标记-整理算法？</h3>\n<p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。相比较标记-清除算法而言，它不会产生内存碎片，但是需要移动大量对象，处理效率低。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/rK5dXPjukpSx4Hc.png\" alt=\"标记-整理.jpg\" /></p>\n</div>\n<h3 id=\"什么是复制算法\"> 什么是复制算法？</h3>\n<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。</p>\n<p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p>\n<p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/PGaUAmF2Txfq5Ss.png\" alt=\"复制.jpg\" /></p>\n</div>\n<h3 id=\"什么是分代收集\"> 什么是分代收集？</h3>\n<p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法，一般将堆分为新生代和老年代：</p>\n<ul>\n<li>新生代使用复制算法</li>\n<li>老年代使用标记-清除或者标记-整理算法</li>\n</ul>\n<h2 id=\"垃圾回收器\"> 垃圾回收器</h2>\n<h3 id=\"jvm-有哪些垃圾回收器\"> JVM 有哪些垃圾回收器？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/zQd3n6VFievBKtY.png\" alt=\"垃圾回收器.jpg\" /></p>\n</div>\n<p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p>\n<h4 id=\"单线程与多线程\"> <strong>单线程与多线程</strong></h4>\n<p>单线程指的是垃圾收集器只使用一个线程进行回收，多线程指的是垃圾收集器使用多个线程进行回收。</p>\n<h4 id=\"串行与并行\"> <strong>串行与并行</strong></h4>\n<p>串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行，除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</p>\n<h3 id=\"什么是-serial-收集器\"> 什么是 Serial 收集器？</h3>\n<p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。看名字就知道这个收集器是一个单线程收集器，它的单线程的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（&quot;Stop The World&quot;），直到它收集结束。</p>\n<p>Serial 收集器在新生代采用复制算法，在老年代采用标记-整理算法。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/fmjrMaopxuhbAIQ.png\" alt=\"Serial收集器.jpg\" /></p>\n</div>\n<h3 id=\"什么是-parnew-收集器\"> 什么是 ParNew 收集器？</h3>\n<p>ParNew 是 Serial 的多线程版本，除了使用多线程以外，与 Serial 收集器完全一致。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/Tzb4P7dEcjXQuGO.png\" alt=\"ParNew收集器.jpg\" /></p>\n</div>\n<h3 id=\"什么是-parallel-scavenge-收集器\"> 什么是 Parallel Scavenge 收集器？</h3>\n<p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。</p>\n<p>所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成就可以了。</p>\n<p>新生代采用复制算法，老年代采用标记-整理算法，是一个多线程的收集器。同时它是 JDK8 的默认收集器。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/Tzb4P7dEcjXQuGO.png\" alt=\"ParallelScavenge收集器.jpg\" /></p>\n</div>\n<h3 id=\"什么是-cms-收集器\"> 什么是 CMS 收集器？<i>Not supported content</i></h3>\n<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常适合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</p>\n<p>从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是使用“标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整体分为四个步骤：</p>\n<h4 id=\"初始标记\"> <strong>初始标记</strong></h4>\n<p>暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。</p>\n<h4 id=\"并发标记\"> <strong>并发标记</strong></h4>\n<p>同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p>\n<h4 id=\"重新标记\"> <strong>重新标记</strong></h4>\n<p>重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</p>\n<h4 id=\"并发清除\"> <strong>并发清除</strong></h4>\n<p>开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/cIWHRtZV2boTdL7.png\" alt=\"CMS收集器.jpg\" /></p>\n</div>\n<p>CMS 收集器的缺点是：</p>\n<h4 id=\"吞吐量低\"> <strong>吞吐量低</strong></h4>\n<p>低停顿时间是以牺牲吞吐量为代价的。</p>\n<h4 id=\"无法处理浮动垃圾\"> <strong>无法处理浮动垃圾</strong></h4>\n<p>可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</p>\n<h4 id=\"标记-清除算法导致的空间碎片\"> <strong>标记 - 清除算法导致的空间碎片</strong></h4>\n<p>“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</p>\n<h3 id=\"什么是-serial-old-收集器\"> 什么是 Serial Old 收集器？</h3>\n<p>Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：</p>\n<ul>\n<li>在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用</li>\n<li>作为 CMS 收集器的后备方案，在并发收集发生 Concurrent Mode Failure 时使用</li>\n</ul>\n<h3 id=\"什么是-parallel-old-收集器\"> 什么是 Parallel Old 收集器？</h3>\n<p>Parallel Scavenge 收集器的老年代版本，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p>\n<h3 id=\"什么是-g1-收集器\"> 什么是 G1 收集器？<i>Not supported content</i></h3>\n<p>G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。G1 把堆划分成多个大小相等的独立区域（Region），使新生代和老年代不再物理隔离。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/JvebfMrtipYwz8P.png\" alt=\"G1Region.jpg\" /></p>\n</div>\n<p>通过引入 Region 的概念，将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p>\n<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p>\n<p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p>\n<ol>\n<li>\n<p>初始标记</p>\n</li>\n<li>\n<p>并发标记</p>\n</li>\n<li>\n<p>最终标记</p>\n</li>\n</ol>\n<p>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</p>\n<ol start=\"4\">\n<li>筛选回收</li>\n</ol>\n<p>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</p>\n<p>G1 收集器的流程图如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/atSL548mrYAlR1T.png\" alt=\"G1垃圾回收器.jpg\" /></p>\n</div>\n<p>总结一下 G1 收集器的特点：</p>\n<ul>\n<li>并行与并发</li>\n</ul>\n<p>G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 的停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p>\n<ul>\n<li>分代收集</li>\n</ul>\n<p>虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</p>\n<ul>\n<li>空间整合</li>\n</ul>\n<p>与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。</p>\n<ul>\n<li>可预测的停顿</li>\n</ul>\n<p>这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</p>\n",
      "image": "https://i.loli.net/2021/07/30/GpvU2nIrS4CjtD1.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "☀️ 类加载机制",
      "url": "https://blog.lixiangyu.xyz/interview/jvm/classloader/",
      "id": "https://blog.lixiangyu.xyz/interview/jvm/classloader/",
      "content_html": "<h2 id=\"类的生命周期\"> 类的生命周期</h2>\n<h3 id=\"介绍一下类的生命周期\"> 介绍一下类的生命周期？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/EWL6m9ayd8rfe1z.png\" alt=\"类生命周期.jpg\" /></p>\n</div>\n<h4 id=\"加载\"> <strong>加载</strong></h4>\n<p>将字节码文件加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区数据的访问入口。</p>\n<h4 id=\"验证\"> <strong>验证</strong></h4>\n<p>确保字节码文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>\n<h4 id=\"准备\"> <strong>准备</strong></h4>\n<p>类变量是被 <code>static</code> 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。初始值一般为 0 值，例如下面的类变量 <code>value</code> 被初始化为 0 而不是 123。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>int</span> value <span>=</span> <span>123</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p>\n<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>int</span> value <span>=</span> <span>123</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><h4 id=\"解析\"> <strong>解析</strong></h4>\n<p>将常量池的符号引用替换为直接引用的过程。其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>\n<h4 id=\"初始化\"> <strong>初始化</strong></h4>\n<p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。<code>&lt;clinit&gt;()</code> 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>static</span> <span>{</span>\n        i <span>=</span> <span>0</span><span>;</span>\n        <span>// 提示非法前向引用</span>\n        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>i<span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>static</span> <span>int</span> i <span>=</span> <span>1</span><span>;</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>由于父类会优先加载，所以子类访问父类的静态变量是没有问题的。</p>\n<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>\n    <span>static</span> <span>class</span> <span>Parent</span> <span>{</span>\n        <span>public</span> <span>static</span> <span>int</span> parent <span>=</span> <span>1</span><span>;</span>\n        <span>static</span> <span>{</span>\n            parent <span>=</span> <span>2</span><span>;</span>\n        <span>}</span>\n    <span>}</span>\n\n    <span>static</span> <span>class</span> <span>Child</span> <span>extends</span> <span>Parent</span> <span>{</span>\n        <span>public</span> <span>static</span> <span>int</span> child <span>=</span> parent<span>;</span>\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>\n        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Child</span><span>.</span>child<span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其它线程都会阻塞等待，直到活动线程执行 <code>&lt;clinit&gt;()</code> 方法完毕。如果在一个类的 <code>&lt;clinit&gt;()</code> 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞可能很会隐蔽。</p>\n<h3 id=\"说一下类的初始化时机\"> 说一下类的初始化时机？<i>Not supported content</i></h3>\n<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>\n<h4 id=\"主动引用\"> <strong>主动引用</strong></h4>\n<p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p>\n<ul>\n<li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化，最常见的生成这 4 条指令的场景是：\n<ul>\n<li>使用 <code>new</code> 关键字实例化对象</li>\n<li>读取或设置一个类的静态字段（用 <code>final</code> 修饰，已在编译期把结果放入常量池的静态字段除外）</li>\n<li>调用一个类的静态方法</li>\n</ul>\n</li>\n<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化</li>\n<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</li>\n<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类</li>\n</ul>\n<h4 id=\"被动引用\"> <strong>被动引用</strong></h4>\n<p>除了上面提到的主动引用方式以外，剩下所有的方式都是被动引用，比如：</p>\n<ul>\n<li>通过子类引用父类的静态字段，不会导致子类初始化</li>\n<li>通过数组定义来引用类，不会触发此类的初始化，该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</li>\n<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li>\n</ul>\n<h3 id=\"new-关键字是如何实现的\"> new 关键字是如何实现的？<i>Not supported content</i></h3>\n<h4 id=\"校验\"> <strong>校验</strong></h4>\n<p>检查这个指令的参数是否能在常量池中定位到一个符号引用，并检查这个符号引用代表的类是否已经被虚拟机加载过、解析、和初始化过。如果没有，就必须先执行类的加载过程。如果有，则根据关键 <code>new</code> 后紧跟的构造方法去创建一个类的对象出来。</p>\n<h4 id=\"分配内存\"> <strong>分配内存</strong></h4>\n<p>为新生的对象分配内存。对象所需内存大小在类加载完成后就可以完全确定。为对象分配空间的任务等同于把一块大小确定的内存从 Java 堆中划分出来。除了划分可用空间以外还需要考虑并发状态下分配内存的冲突问题，这个时候有两种解决办法：一是采用 CAS + 失败重试，二是预先分配一小块的 TLAB 内存。</p>\n<h4 id=\"初始化-2\"> <strong>初始化</strong></h4>\n<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一操作保证了对象的实例字段在 Java 代码中可以不赋初始值就可以直接使用。</p>\n<h4 id=\"设置\"> <strong>设置</strong></h4>\n<p>接下来虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、GC 的对象分代年龄等信息。这新信息储存在对象头中之中</p>\n<h4 id=\"初始化赋值\"> <strong>初始化赋值</strong></h4>\n<p>在上面的工作都完成后，从虚拟机的角度来看，一个新的对象已经产生，但从 Java 的角度来看，对象的创建才刚刚开始，因为初始化方法还没有执行，所有的字段还都为零。因此在执行完 <code>new</code> 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算创建完成。所谓程序员的意愿，就是 <code>new</code> 对象的时候指定的构造方法。</p>\n<h3 id=\"除了使用-new-还有哪些方式能够创建对象\"> 除了使用 new 还有哪些方式能够创建对象？</h3>\n<ul>\n<li><code>Class.forName().newInstance()</code></li>\n<li><code>xx.class.getConstructor().newInstance()</code></li>\n<li>反序列化</li>\n<li><code>clone()</code></li>\n</ul>\n<h2 id=\"类加载器与双亲委派机制\"> 类加载器与双亲委派机制</h2>\n<h3 id=\"有哪些类加载器\"> 有哪些类加载器？<i>Not supported content</i></h3>\n<p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分</li>\n<li>所有其它类的加载器：使用 Java 实现，独立于虚拟机，继承自抽象类 <code>java.lang.ClassLoader</code></li>\n</ul>\n<p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p>\n<ul>\n<li>启动类加载器（Bootstrap ClassLoader）</li>\n</ul>\n<p>这个加载器负责将存放在 <code>&lt;JRE_HOME&gt;\\lib</code> 目录中的，或者被 <code>-Xbootclasspath</code> 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 <code>rt.jar</code>，名字不符合的类库即使放在 <code>lib</code> 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，开发人员在编写自定义的类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 <code>null</code> 代替即可。</p>\n<ul>\n<li>扩展类加载器（Extension ClassLoader）</li>\n</ul>\n<p>这个类加载器是由 <code>ExtClassLoader</code> 类实现的。它负责将 <code>&lt;JAVA_HOME&gt;/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。</p>\n<ul>\n<li>应用程序类加载器（Application ClassLoader）</li>\n</ul>\n<p>这个类加载器是由 <code>AppClassLoader</code> 类实现的。由于这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值，因此一般也称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发人员可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，那么一般情况下这个加载器就是程序中默认使用的类加载器。</p>\n<h3 id=\"什么是双亲委派机制\"> 什么是双亲委派机制？<i>Not supported content</i></h3>\n<p>双亲委派机制是 JVM 在加载类时默认使用的机制。当一个类加载器接收到类加载任务时，会交给自己的父加载器去完成，所以最终所有的加载任务都会传递到最顶层的 <code>BootstrapClassLoader</code> 上。只有父加载器无法完成加载任务时，才会尝试自己来加载。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/rOyfzTB1xecZ3Sp.png\" alt=\"双亲委派机制.jpg\" /></p>\n</div>\n<h3 id=\"为什么需要打破双亲委派机制\"> 为什么需要打破双亲委派机制？</h3>\n<p>以 MySQL 驱动为例：</p>\n<div><pre><code><span>Class</span><span>.</span><span>forName</span><span>(</span><span>\"com.mysql.cj.jdbc.Driver\"</span><span>)</span><span>;</span>\n<span>Connection</span> conn <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span><span>\"url\"</span><span>,</span> <span>\"root\"</span><span>,</span> <span>\"password\"</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><p><code>Driver</code> 接口（较早的 MySQL 驱动中提供的是 <code>com.mysql.jdbc.Driver</code>），定义在 <code>java.sql</code> 包中，包所在的位置是：<code>jdk\\jre\\lib\\rt.jar</code>。<code>java.sql</code> 包中还提供了其它相应的类和接口比如管理驱动的类：<code>DriverManager</code> 类。</p>\n<p>很明显 <code>java.sql</code> 包是由 BootstrapClassloader 加载器加载的，而接口的实现类是由第三方实现的，由 ApplicationClassLoader 加载器进行加载的，现在的问题是 <code>DriverManager</code> 在获取链接的时候必然要加载到 <code>com.mysql.jdbc.Driver</code> 类。也就是说由 BootstrapClassloader 加载的类使用了由 ApplicationClassLoader 加载的类，很明显和双亲委托机制的原理相悖。所以需要打破双亲委派机制对类进行加载。</p>\n<h3 id=\"怎么打破双亲委派机制\"> 怎么打破双亲委派机制？</h3>\n<h4 id=\"实现自定义的类加载器\"> <strong>实现自定义的类加载器</strong></h4>\n<p>Tomcat 在打破双亲委派机制时使用的就是这种方式。实现 <code>ClassLoader</code> 接口，重写 <code>loadClass()</code> 和 <code>findClass()</code> 方法，重点是重写 <code>loadClass()</code> 方法。如果是希望在不打破双亲委派机制的情况下实现类加载器，那么只重写 <code>findClass()</code> 就可以了。</p>\n<div><p>为什么要重写 loadClass() 方法</p>\n<p>查看 <code>loadClass()</code> 方法的源码，发现它会通过 <code>parent.loadClass()</code> 去请求父加载器加载类，如果父加载器加载不了，那么再通过自身的 <code>findClass()</code> 对类进行加载。\n由于 <code>ClassLoader</code> 接口中对 <code>loadClass()</code> 提供了默认实现，即使用双亲委派机制来加载类，因此如果希望打破双亲委派机制，那么必须重写这个方法。</p>\n</div>\n<h4 id=\"serviceloader\"> <strong>ServiceLoader</strong></h4>\n<p>首先先介绍一下 SPI，SPI 指的是 Service Provider Interface，主要是应用于厂商自定义组件或插件中。在 <code>java.util.ServiceLoader</code> 的文档里有比较详细的介绍。</p>\n<p>简单的说一下 Java SPI 机制的思想：系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块、XML 解析模块、JDBC 模块等。面向对象的设计里，一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<strong>Java SPI 就是提供了这样的一种机制：为某个接口寻找服务实现的机制。</strong></p>\n<p>SPI 规定：当服务的提供者提供了服务接口的一种实现之后，在 jar 包的 <code>META-INF/services/</code> 目录里同时创建一个以服务接口命名的文件。这个文件里所指的就是实现该服务接口的具体实现类，当外部程序装配这个模块的时候，就能通过该 jar 包的 <code>META-INF/services/</code> 里的配置文件找到具体的实现类名，并进行实例化以完成模块的注入。</p>\n<p>在 MySQL 驱动 jar 包的 <code>META-INF/services</code> 目录中可以看到一个名为 <code>java.sql.Driver</code> 的文件，在其中配置了 <code>Driver</code> 接口的实现类 <code>com.mysql.cj.jdbc.Driver</code>。</p>\n",
      "image": "https://i.loli.net/2021/07/30/EWL6m9ayd8rfe1z.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 JVM - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/jvm/",
      "id": "https://blog.lixiangyu.xyz/interview/jvm/",
      "content_html": "<p>JVM 是 Java 能够实现跨平台运行的基础，这部分的内容也是面试必问的。本部分包含以下几个内容：</p>\n<ol>\n<li><a href=\"/interview/jvm/memory-partition\">内存区域划分</a>：看看对于 JVM 而言，内存区域是如何划分的</li>\n<li><a href=\"/interview/jvm/classloader\">类加载机制</a>：JVM 的类加载机制</li>\n<li><a href=\"/interview/jvm/gc\">垃圾回收机制</a>：JVM 提供的垃圾回收算法与垃圾回收器</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "✈️ Kafka",
      "url": "https://blog.lixiangyu.xyz/interview/middleware/kafka/",
      "id": "https://blog.lixiangyu.xyz/interview/middleware/kafka/",
      "content_html": "<h2 id=\"kafka-是什么-它有哪些应用场景\"> Kafka 是什么？它有哪些应用场景？</h2>\n<p>Kafka 是一个分布式流式处理平台，具有三个关键功能：</p>\n<ul>\n<li>消息队列：发布和订阅消息流，这个功能类似于消息队列，这就是 Kafka 也被归类为消息队列的原因</li>\n<li>容错的持久方式存储记录消息流：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险</li>\n<li>流式处理平台：在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库</li>\n</ul>\n<p>Kafka 主要有两大应用场景：</p>\n<ul>\n<li>消息队列：建立实时流数据管道，从而可靠地在系统或应用程序之间获取数据</li>\n<li>数据处理：构建实时的流数据处理程序来转换或处理数据流</li>\n</ul>\n<h2 id=\"kafka-的优势\"> Kafka 的优势？</h2>\n<p>Kafka 相比其他消息队列主要的优势如下：</p>\n<ul>\n<li>极致的性能：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息</li>\n<li>生态系统兼容性无可匹敌 ：Kafka 与周边生态系统的兼容性很好，尤其在大数据和流计算领域</li>\n</ul>\n<h2 id=\"介绍一下-kafka-的发布-订阅模型\"> 介绍一下 Kafka 的发布-订阅模型？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Vg5CxKd7vTAR9hz.png\" alt=\"kafka发布订阅.png\" /></p>\n</div>\n<p>发布-订阅模型（Pub-Sub）使用主题（Topic）作为消息通信载体，类似于广播模式。发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。在发布-订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说发布-订阅模型在功能层面上是可以兼容队列模型的。</p>\n<h2 id=\"什么是-producer-consumer-broker-topic-partition\"> 什么是 Producer，Consumer，Broker，Topic，Partition？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/9wXLUKRDdFWfSng.png\" alt=\"kafka角色.png\" /></p>\n</div>\n<ul>\n<li>Producer：生产者，产生消息的一方</li>\n<li>Consumer：消费者，消费消息的一方</li>\n<li>Broker：代理，可以看作是一个独立的 Kafka 实例，多个 Kafka Broker 会组成集群</li>\n<li>Topic：主题，Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic 来消费消息</li>\n<li>Partition：分区是属于 Topic 的一部分，一个 Topic 可以有多个 Partition，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上</li>\n</ul>\n<div><p>Partition 与队列</p>\n<p>Kafka 中的 Partition（分区） 实际上可以对应消息队列中的队列。</p>\n</div>\n<h2 id=\"kafka-的多副本机制\"> Kafka 的多副本机制？</h2>\n<p>Kafka 为分区引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个 leader，其他副本称为 follower。发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p>\n<p>这样生产者和消费者只与 leader 副本交互，其他副本的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时，会从 follower 中选举出一个 leader，但是 follower 中如果有和 leader 同步程度达不到要求的是参加不了竞选的。</p>\n<p>Kafka 采用这种机制的好处：</p>\n<ul>\n<li>各个 Partition 可以分布在不同的 Broker 上，能提供比较好的并发能力（负载均衡）</li>\n<li>Partition 可以指定所需的 Replica 的数量，这极大地提高了消息存储的安全性，提高了容灾能力，不过也会增加所需要的存储空间</li>\n</ul>\n<h2 id=\"zookeeper-在-kafka-中的作用是什么\"> ZooKeeper 在 Kafka 中的作用是什么？</h2>\n<h3 id=\"broker-注册\"> Broker 注册</h3>\n<p>在 Zookeeper 上会有一个专门用来进行 Broker 服务器列表记录的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即 <code>/brokers/ids</code> 目录下创建并保存属于自己节点的节点信息。</p>\n<h3 id=\"topic-注册\"> Topic 注册</h3>\n<p>在 Kafka 中，同一个 Topic 的消息会被分成多个分区并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护，比如创建一个名为 my-topic 的主题并且它有两个分区，那么在 ZooKeeper 中会创建这些目录：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code>。</p>\n<h3 id=\"负载均衡\"> 负载均衡</h3>\n<p>对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上，当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，ZooKeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p>\n<h2 id=\"kafka-如何保证消息的消费顺序\"> Kafka 如何保证消息的消费顺序？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/cJOGZNY9UIB4q8K.png\" alt=\"kafka-partition.png\" /></p>\n</div>\n<p>每次添加消息到 Partition 的时候都会采用尾加法，并为其分配一个特定的偏移量（offset），通过这个偏移量 Kafka 可以保证消息在分区中的顺序性，但不能保证 Topic 中 Partition 的有序。保证消费有序的方式有：</p>\n<ul>\n<li>一个 Topic 对应一个 Partition，但这种做法违背了 Kafka 的设计初衷</li>\n<li>在发送消息时指定要发送到哪个 Partition</li>\n</ul>\n<h2 id=\"发送方如何保证消息不丢失\"> 发送方如何保证消息不丢失？</h2>\n<p>生产者调用 send 方法发送消息之后，消息可能因为网络问题并没有发送过去。所以不能默认在调用 send 方法发送消息之后，消息就一定发送成功了。可以通过回调函数来确认消息是否发送成功：</p>\n<div><pre><code><span>ListenableFuture</span><span><span>&lt;</span><span>SendResult</span><span>&lt;</span><span>String</span><span>,</span> <span>Object</span><span>></span><span>></span></span> future <span>=</span> kafkaTemplate<span>.</span><span>send</span><span>(</span>topic<span>,</span> o<span>)</span><span>;</span>\nfuture<span>.</span><span>addCallback</span><span>(</span>\n    result <span>-></span> logger<span>.</span><span>info</span><span>(</span><span>\"生产者成功发送消息到topic:{} partition:{}的消息\"</span><span>,</span> \n                          result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>topic</span><span>(</span><span>)</span><span>,</span> \n                          result<span>.</span><span>getRecordMetadata</span><span>(</span><span>)</span><span>.</span><span>partition</span><span>(</span><span>)</span><span>)</span><span>,</span>\n    ex <span>-></span> logger<span>.</span><span>error</span><span>(</span><span>\"生产者发送消失败，原因：{}\"</span><span>,</span> ex<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id=\"消费者如何保证消息不丢失\"> 消费者如何保证消息不丢失？</h2>\n<p>消息在被追加到 Partition 的时候都会分配一个特定的偏移量，偏移量表示 Consumer 当前消费到的 Partition 的所在的位置。Kafka 通过偏移量可以保证消息在分区内的顺序性。</p>\n<p>当消费者拉取到了分区的某个消息之后，消费者会自动提交 offset。自动提交的话会有一个问题：当消费者刚拿到消息准备进行消费的时候，消费者突然挂掉了，消息实际上并没有被消费，但是 offset  却被自动提交了。这个问题可以通过关闭自动提交并使用手动提交来解决。</p>\n<p>但是如果使用手动提交又会引发另一个问题：消费者在消费后挂掉了，此时没有进行提交，那么在重启后就会进行重复消费。</p>\n<h2 id=\"kafka-如何保证消息不丢失\"> Kafka 如何保证消息不丢失？</h2>\n<p>如上面所提到的，Kafka 为分区引入了多副本机制，发送的信息是到 leader，然后 follower 才开始拉取同步。如果 leader 副本在同步完成前挂了就会导致数据丢失。解决方案是修改 Kafka 的配置项：</p>\n<h3 id=\"设置-acks-all\"> 设置 acks = all</h3>\n<p><code>acks</code> 的默认值是 1，代表消息被 leader 副本接收之后就认为是成功发送，当配置 <code>acks = all</code> 时代表所有副本都要接收到该消息之后该消息才算真正发送成功。</p>\n<h3 id=\"设置-replication-factor-3\"> 设置 replication.factor &gt;= 3</h3>\n<p>通过这个参数可以保证每个分区至少有 3 个副本，虽然造成了数据冗余，但是带来了数据的安全性。</p>\n<h3 id=\"设置-min-insync-replicas-1\"> 设置 min.insync.replicas &gt; 1</h3>\n<p>一般情况下还需要设置 <code>min.insync.replicas &gt; 1</code>，这样配置代表消息至少要被写入到 2 个副本才算是成功发送。<code>min.insync.replicas</code> 的默认值为 1，在实际生产中应尽量避免使用默认值 1。</p>\n<h2 id=\"设置-unclean-leader-election-enable-false\"> 设置 unclean.leader.election.enable = false</h2>\n<p>这个参数配置为 false 并且 leader 发生故障时，达不到同步要求的 follower 将不会参与竞选。</p>\n<h2 id=\"kafka-如何保证消息不重复消费\"> Kafka 如何保证消息不重复消费？</h2>\n<p>主要需要结合实际业务来操作:</p>\n<ul>\n<li>如果需要写库，那可以根据主键先查一下，如果数据已经有了，则进行更新</li>\n<li>如果用到了 Redis，每次都是 set，天然支持幂等性</li>\n<li>如果是其他的场景，那么可以让生产者在发送每条数据的时候，在里面加一个全局唯一的 id，消费者在消费前先查一下缓存，如果存在则拒绝</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/08/01/Vg5CxKd7vTAR9hz.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "⭐ 内存区域划分",
      "url": "https://blog.lixiangyu.xyz/interview/jvm/memory-partition/",
      "id": "https://blog.lixiangyu.xyz/interview/jvm/memory-partition/",
      "content_html": "<h2 id=\"介绍一下-jvm-是怎么划分的内存区域\"> 介绍一下 JVM 是怎么划分的内存区域？<i>Not supported content</i></h2>\n<p>不同的 JDK 版本对于内存区域的实现不尽相同，下图中的左侧区域为 JDK 1.6 版本的内存区域划分，右侧为 JDK 1.8 版本的内存区域划分。在 JDK8 中移除了方法区，替代的是元空间（Metaspace）。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/pFHz9cBLidmeZWI.png\" alt=\"JVM内存划分.jpg\" /></p>\n</div>\n<h2 id=\"线程共享区域\"> 线程共享区域</h2>\n<h3 id=\"什么是堆\"> 什么是堆？</h3>\n<p>堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。Java  中几乎所有的对象都在堆中分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了。从 JDK7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>\n<p>堆是垃圾收集器管理的主要区域，因此也被称作 GC 堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代。再细致一点会有：Eden、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p>\n<p>在 JDK7 之前，堆内存分为以下三个部分：</p>\n<ul>\n<li>新生代内存(Young Generation)</li>\n<li>老年代(Old Generation)</li>\n<li><strong>永生代(Permanent Generation)</strong></li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/pfl9b7PGLhXxaOs.png\" alt=\"JDK7区域划分.jpg\" /></p>\n</div>\n<p>在 JDK8 之后，<strong>方法区/永生代被移除</strong>，取而代之的是<strong>元空间</strong>，元空间使用直接内存。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/fiuUV7ndOxqR19a.png\" alt=\"JDK8区域划分.jpg\" /></p>\n</div>\n<p>Eden 区、两个 Survivor 区都属于新生代，中间一层属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 Survivor 区，并且对象的年龄还会加 1（Eden 区移动到 Survivor 区后对象的初始年龄变为 1），当它的年龄增加到一定程度，就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>\n<div><p>动态年龄计算</p>\n<p>Hotspot 采用动态年龄计算，遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 Survivor 区的一半时，取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值。</p>\n</div>\n<div><p>OOM</p>\n<p>堆最容易出现的是 <code>OutOfMemoryError</code>，比如：</p>\n<ol>\n<li><code>OutOfMemoryError: GC Overhead Limit Exceeded</code>：当 JVM 花太多时间执行垃圾回收但只能回收很少的堆空间时，就会发生此错误</li>\n<li><code>OutOfMemoryError: Java heap space</code>：假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象，就会引发这个错误</li>\n</ol>\n<p>通过 <code>-Xms</code> 和 <code>-Xmx</code> 这两个 VM 参数可以指定堆内存的大小，第一个参数设置初始值，第二个参数设置最大值。</p>\n</div>\n<h3 id=\"什么是方法区\"> 什么是方法区？</h3>\n<p>方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。通过下面的参数可以对元空间进行设置：</p>\n<ul>\n<li>-XX:MetaspaceSize=N，表示元空间首次空间不足而触发 FullGC 的阈值</li>\n<li>-XX:MaxMetaspaceSize=N，表示元空间的最大大小</li>\n</ul>\n<div><p>方法区和永久代之间的关系</p>\n<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它，因此在不同的 JVM 上方法区的实现肯定是不同的了。方法区和永久代的关系很像 Java 中接口和类的关系，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现。</p>\n<p>也就是说，永久代是 HotSpot 虚拟机中的概念，方法区是 Java 虚拟机规范中的定义，一个是标准，一个是实现，其他的虚拟机实现中并没有永久代这一说法。</p>\n</div>\n<div><p>为什么要将方法区替换为元空间</p>\n<ol>\n<li>永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小，当元空间溢出时，报错 <code>java.lang.OutOfMemoryError: MetaSpace</code></li>\n<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code>（VM 参数，表示永久代的最大大小） 控制了，而由系统的实际可用空间来控制，能加载的类就更多了</li>\n<li>在 JDK8 中合并 HotSpot 和 JRockit（Oracle JVM）的代码时，JRockit 并没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了</li>\n</ol>\n</div>\n<h3 id=\"什么是运行时常量池\"> 什么是运行时常量池？</h3>\n<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译器生成的各种字面量和符号引用）。</p>\n<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。JDK8 Hotspot 虚拟机移除了永久代转而使用元空间，<strong>字符串常量池在堆中，运行时常量池在元空间</strong>。</p>\n<h3 id=\"什么是直接内存\"> 什么是直接内存？</h3>\n<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误的出现。</p>\n<p>JDK1.4 中新加入的 NIO（Non-blocking IO) 类，引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库分配堆外内存，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为它避免了在 Java 堆和 Native 堆之间来回复制数据。本机直接内存的分配不会受到 Java 堆的限制，但是既然是内存就肯定会受到本机总内存大小以及处理器寻址空间的限制。</p>\n<h2 id=\"线程私有区域\"> 线程私有区域</h2>\n<h3 id=\"什么是虚拟机栈\"> 什么是虚拟机栈？</h3>\n<p>Java 虚拟机栈是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/f6FXDZAvkqs4z7B.png\" alt=\"栈帧.jpg\" /></p>\n</div>\n<p>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p>\n<ul>\n<li><code>StackOverFlowError</code>：若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code>，比如无限递归</li>\n<li><code>OutOfMemoryError</code>：若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话，就会抛出 <code>OutOfMemoryError</code></li>\n</ul>\n<h3 id=\"什么是本地方法栈\"> 什么是本地方法栈？</h3>\n<p>和虚拟机栈所发挥的作用非常相似，区别在于虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中将虚拟机栈和本地方法栈合二为一了。</p>\n<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p>\n<h3 id=\"什么是程序计数器\"> 什么是程序计数器？</h3>\n<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。另外为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储。</p>\n",
      "image": "https://i.loli.net/2021/07/30/pFHz9cBLidmeZWI.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 中间件 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/middleware/",
      "id": "https://blog.lixiangyu.xyz/interview/middleware/",
      "content_html": "<p>介绍一些常用的中间件：</p>\n<ol>\n<li><a href=\"/interview/middleware/kafka/\">Kafka</a>：一个非常快的消息队列</li>\n<li><a href=\"/interview/middleware/zookeeper/\">ZooKeeper</a>：一个用于分布式系统的集群管理者</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🚥 ZooKeeper",
      "url": "https://blog.lixiangyu.xyz/interview/middleware/zookeeper/",
      "id": "https://blog.lixiangyu.xyz/interview/middleware/zookeeper/",
      "content_html": "<h2 id=\"介绍一下-cap-理论\"> 介绍一下 CAP 理论？</h2>\n<p>CAP理论作为分布式系统的基础理论，它描述的是一个分布式系统在以下三个特性中最多同时满足其中两个。分布式系统要么满足 CA，要么满足 CP，要么满足 AP，无法同时满足 CAP。</p>\n<h3 id=\"一致性-consistency\"> 一致性（Consistency）</h3>\n<p>在分布式系统完成某写操作后，对于任意的读操作都应该获取到该写操作写入的那个最新的值，相当于要求分布式系统中的各节点时时刻刻保持数据的一致性。</p>\n<h3 id=\"可用性-availability\"> 可用性（Availability）</h3>\n<p>可用性指可以进行正常的做读写操作，简单而言就是客户端一直可以正常访问并得到系统的正常响应，从用户角度来看就是不会出现系统操作失败或者访问超时等问题。</p>\n<h3 id=\"分区容错性-partition-tolerance\"> 分区容错性（Partition tolerance）</h3>\n<p>分区容错性指分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍然能对外提供满足一致性和可用性的服务，也就是说部分故障不影响整体使用。</p>\n<div><p>CAP 的两两组合</p>\n<ul>\n<li>CA：优先保证一致性和可用性，放弃分区容错。这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。</li>\n<li>CP：优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合（比如 ZooKeeper、Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。</li>\n<li>AP：优先保证可用性和分区容错性，放弃一致性。NoSQL 中的 Cassandra 就是这种架构。跟 CP 一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。</li>\n</ul>\n</div>\n<h2 id=\"什么是-zookeeper\"> 什么是 ZooKeeper？</h2>\n<p>ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终将简单易用的接口和性能高效、功能稳定的系统提供给用户。</p>\n<p>分布式应用程序可以基于 ZooKeeper 实现：数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>\n<p>Zookeeper保证了如下的分布式一致性特性：</p>\n<ul>\n<li>顺序一致性</li>\n<li>原子性</li>\n<li>单一视图</li>\n<li>可靠性</li>\n<li>实时性（最终一致性）</li>\n</ul>\n<p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 ZooKeeper 机器来处理。对于写请求，这些请求会同时发给其他 ZooKeeper 机器并且达成一致后，请求才会返回成功。因此随着 ZooKeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。</p>\n<p>有序性是 ZooKeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 <code>zxid</code>（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 ZooKeeper 最新的 <code>zxid</code>。</p>\n<h2 id=\"介绍一下-zookeeper-的文件系统\"> 介绍一下 ZooKeeper 的文件系统？</h2>\n<p>ZooKeeper 提供一个多层级的节点命名空间（节点称为 Znode），与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。ZooKeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 ZooKeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M。</p>\n<h2 id=\"znode-有哪四种类型\"> ZNode 有哪四种类型？</h2>\n<h3 id=\"persistent-持久节点\"> PERSISTENT-持久节点</h3>\n<p>除非手动删除，否则节点一直存在于 ZooKeeper 上。</p>\n<h3 id=\"ephemeral-临时节点\"> EPHEMERAL-临时节点</h3>\n<p>临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 ZooKeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</p>\n<h3 id=\"persistent-sequential-持久顺序节点\"> PERSISTENT_SEQUENTIAL-持久顺序节点</h3>\n<p>基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>\n<h3 id=\"ephemeral-sequential-临时顺序节点\"> EPHEMERAL_SEQUENTIAL-临时顺序节点</h3>\n<p>基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</p>\n<h2 id=\"什么是-zab-协议\"> 什么是 ZAB 协议？</h2>\n<p>ZAB 协议一种支持崩溃恢复的原子广播协议，它包括两种基本的模式：崩溃恢复和消息广播。在 ZooKeeper 集群刚刚启动或者 leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式：</p>\n<p>首先选举产生新的 leader 服务器，然后集群中 follower 服务器开始与新的 leader 服务器进行数据同步，当集群中超过半数机器与该 leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，leader 服务器开始接收客户端的事务请求生成事务提案来进行事务请求处理。</p>\n<h2 id=\"什么是-zookeeper-watcher-机制\"> 什么是 ZooKeeper Watcher 机制？</h2>\n<p>ZooKeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。</p>\n<p>工作机制：</p>\n<ul>\n<li>客户端注册 Watcher</li>\n<li>服务端处理 Watcher</li>\n<li>客户端回调 Watcher</li>\n</ul>\n<h2 id=\"watcher-机制的特性有哪些\"> Watcher 机制的特性有哪些？</h2>\n<h3 id=\"一次性\"> 一次性</h3>\n<p>无论是服务端还是客户端，一旦一个 Watcher 被触发，ZooKeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，对于网络以及服务端的压力都非常大。</p>\n<h3 id=\"客户端串行执行\"> 客户端串行执行</h3>\n<p>客户端 Watcher 回调的过程是一个串行同步的过程。</p>\n<h3 id=\"轻量\"> 轻量</h3>\n<ul>\n<li>Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容</li>\n<li>客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记</li>\n</ul>\n<h3 id=\"watcher-event-异步发送-watcher-的通知事件\"> Watcher Event 异步发送 Watcher 的通知事件</h3>\n<p>ZooKeeper 不能保证监控到节点每次的变化，Zookeeper只能保证最终的一致性，而无法保证强一致性。</p>\n<h3 id=\"注册-watcher-的方式\"> 注册 Watcher 的方式</h3>\n<p>调用 <code>getData()</code>、<code>exists()</code>、<code>getChildren()</code> 这三个方法传入 Watcher 对象。</p>\n<h3 id=\"触发-watcher-的方式\"> 触发 Watcher 的方式</h3>\n<p><code>create()</code>、<code>delete()</code>、<code>setData()</code>。</p>\n<h2 id=\"server-的状态的有哪些\"> Server 的状态的有哪些？</h2>\n<ul>\n<li>LOOKING：当服务器处于该状态时，它会认为当前集群中没有 leader，因此需要进入 leader 选举状态</li>\n<li>FOLLOWING：跟随者状态，表明当前服务器角色是 follower</li>\n<li>LEADING：领导者状态，表明当前服务器角色是 leader</li>\n<li>OBSERVING：观察者状态，表明当前服务器角色是 observer。</li>\n</ul>\n<div><p>观察者</p>\n<p>观察者是 ZooKeeper 3.3.0 版本后引入的一种角色，旨在不影响集群事务处理能力的基础上提升集群的非事务处理能力：</p>\n<ul>\n<li>处理客户端的非事务请求，转发事务请求 leader 服务器</li>\n<li>不参与任何形式的投票</li>\n</ul>\n</div>\n<h2 id=\"介绍一下-zookeeper-的选举机制\"> 介绍一下 ZooKeeper 的选举机制？</h2>\n<ol>\n<li>每个 Server 发出一个投票，投票信息包括：id 和 ZXID，使用（id，ZXID）来表示</li>\n<li>接受来自各个服务器的投票，首先判断检查投票的合法性（是否是本轮的投票、是否来自 LOOKING 状态的服务器）</li>\n<li>每个服务器都会处理投票：\n<ul>\n<li>优先检查 ZXID，ZXID 较大的会作为 leader</li>\n<li>当 ZXID 相同时，id 较大的会作为 leader</li>\n</ul>\n</li>\n<li>服务器会统计投票信息，判断当前是否已经有过半的服务器接收到相同的投票信息就认为已经选出了 leader</li>\n<li>一旦确定了 leader，每个服务器就会更新自己的状态为 LEADING/FOLLOWING</li>\n</ol>\n<p>上述步骤中第二步至第四步会反复执行直到选出 leader。</p>\n<h2 id=\"数据同步的流程是什么\"> 数据同步的流程是什么？</h2>\n<p>集群在完成 leader 选举之后，learner（follower 和 observer 的统称）会向 leader 服务器进行注册。当 learner 服务器向 leader 服务器完成注册后，进入数据同步环节。</p>\n<p>数据同步流程：（均以消息传递的方式进行）</p>\n<ul>\n<li>learner 向 leader 注册</li>\n<li>数据同步</li>\n<li>同步确认</li>\n</ul>\n<p>数据同步的方式通常分为以下四类：</p>\n<ul>\n<li>直接差异化同步（DIFF 同步）</li>\n<li>先回滚再差异化同步（TRUNC + DIFF 同步）</li>\n<li>仅回滚同步（TRUNC 同步）</li>\n<li>全量同步（SNAP 同步）</li>\n</ul>\n<h2 id=\"zookeeper-如何保证事务的顺序一致性\"> ZooKeeper 如何保证事务的顺序一致性？</h2>\n<p>ZooKeeper 采用了全局递增的事务 Id 来标识，所有的 Proposal（提议）都在被提出的时候加上了 ZXID。ZXID 实际上是一个 64 位的数字，高 32 位是 epoch 用来标识 leader 的周期，如果有新的 leader 产生出来，epoch 会自增；低 32 位用来递增计数。当新产生 Proposal 的时候，会向其他的 Server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。</p>\n<h2 id=\"zookeeper-节点宕机怎么处理\"> ZooKeeper 节点宕机怎么处理？</h2>\n<p>ZooKeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZooKeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。</p>\n<h2 id=\"为什么集群数量是奇数\"> 为什么集群数量是奇数？</h2>\n<h3 id=\"防止由脑裂造成的集群不可用\"> 防止由脑裂造成的集群不可用</h3>\n<p>集群的脑裂通常是发生在节点之间通信不可达的情况下，这时集群会分裂成不同的小集群，小集群各自选出自己的 master 节点，导致原有的集群出现多个 master 节点，这就是脑裂。假如 ZooKeeper 集群有 4 个节点，脑裂成了 A、B 两个小集群：</p>\n<ol>\n<li>A：1个节点， B：3个节点</li>\n<li>A：2个节点， B：2个节点</li>\n</ol>\n<p>情况 1 是满足选举条件的，但是情况 2 就不同了，因为 A 和 B 都是 2 个节点，都不满足可用节点数量 &gt; 总节点数量一半的选举条件，所以此时 ZooKeeper 就彻底不能提供服务了。</p>\n<h3 id=\"在容错能力相同的情况下-奇数台更节省资源\"> 在容错能力相同的情况下，奇数台更节省资源</h3>\n<p>有 3 个节点的集群，至少需要 2 个节点是正常的。有 4 个节点的集群，至少需要 3 个节点是正常的。这两个集群都只允许一个节点宕机，但后一个集群所需要的节点数量还更多。所以使用奇数个更好。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤝 集群",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/cluster/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/cluster/",
      "content_html": "<h2 id=\"mysql-集群有哪几种方式-分别适用于什么场景\"> MySQL 集群有哪几种方式，分别适用于什么场景？</h2>\n<p>组建 MySQL 集群的方式：</p>\n<ul>\n<li>LVS + Keepalived + MySQL</li>\n<li>DRBD + Heartbeat + MySQL</li>\n<li>MySQL + Proxy</li>\n<li>MySQL Cluster</li>\n<li>MySQL + MHA</li>\n<li>MySQL + MMM</li>\n</ul>\n<p>使用场景：</p>\n<ul>\n<li>如果是双主复制，不需要数据拆分，可以使用 MHA 或 Keepalived 或 Heartbeat</li>\n<li>如果是双主复制，需要数据拆分，采用 Cobar</li>\n<li>如果是双主复制 + Slave，还做了数据拆分，需要读写分离，采用 Amoeba</li>\n</ul>\n<h2 id=\"mysql-集群如何保证主从可用性\"> MySQL 集群如何保证主从可用性？</h2>\n<p>使用 HA（High Availability） 检测工具。HA 工具部署在第三台服务器上，同时连接主从，检测主从是否存活。如果主库宕机则及时将从库升级为主库，将原来的主库降级为从库。</p>\n<h2 id=\"mysql-主从复制的原理\"> MySQL 主从复制的原理？<i>Not supported content</i></h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/cwYKFULqp7zToQ8.png\" alt=\"MySQL主从.png\" /></p>\n</div>\n<h2 id=\"mysql-主从模式如何保证主从强一致性\"> MySQL 主从模式如何保证主从强一致性？</h2>\n<p>主从复制的原理是：主服务器写数据留下写入日志（Binary log），从服务器根据主服务器留下的日志（Relay log）模仿数据执行过程写入。所以有两个步骤可能导致主从复制不一致：</p>\n<ul>\n<li>主服务器写日志不成功</li>\n<li>从服务器根据日志恢复不成功</li>\n</ul>\n<h3 id=\"主服务器\"> 主服务器</h3>\n<p>修改配置，保证每次事务提交后，都能实时刷新到磁盘中，尤其是确保每次事务对应的 binlog 都能及时刷新到磁盘中：</p>\n<div><pre><code>innodb_flush_log_at_trx_commit = 1\nsync_binlog = 1\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h3 id=\"从服务器\"> 从服务器</h3>\n<p>修改配置，确保在从服务器上和复制相关的元数据表也采用 InnoDB 引擎，受到 InnoDB 事务安全的保护。后一个选项的作用是开启 relay log 自动修复机制，发生 crash 时，会自动判断哪些 relay log 需要重新从主服务器上抓取回来再次应用，以此避免部分数据丢失的可能性：</p>\n<div><pre><code>master_info_repository = &quot;TABLE&quot;\nrelay_log_info_repository = &quot;TABLE&quot;\nrelay_log_recovery = 1\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id=\"mysql-读写分离有哪些解决办法\"> MySQL 读写分离有哪些解决办法？</h2>\n<ul>\n<li>配置多数据源</li>\n<li>使用中间件代理</li>\n</ul>\n<div><p>独写分离的目的</p>\n<ul>\n<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用</li>\n<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</li>\n<li>增加冗余，提高可用性</li>\n</ul>\n</div>\n",
      "image": "https://i.loli.net/2021/07/30/cwYKFULqp7zToQ8.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👋 数据类型",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/datatype/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/datatype/",
      "content_html": "<h2 id=\"mysql-有哪些数据类型-使用的时候有没有什么注意点\"> Mysql 有哪些数据类型，使用的时候有没有什么注意点？</h2>\n<ul>\n<li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、INT、BIG INT</li>\n<li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li>\n<li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、MEDIUM BLOB、LONG BLOB</li>\n<li>日期类型：Date、DateTime、TIMESTAMP、TIME、YEAR</li>\n</ul>\n<div><p>使用建议</p>\n<p>使用的时候建议遵循从小原则。另外：</p>\n<ul>\n<li>使用 <code>char</code> 和 <code>varchar</code> 的时候，需要注意 <code>char</code> 会去掉字符串末尾的空格</li>\n<li>使用 <code>text</code> 和 <code>blob</code> 的时候，注意定期清理碎片空间，使用 <code>OPTIMIZE TABLE</code> 命令</li>\n<li>浮点数会造成精度丢失，尽量使用定点数 <code>DECIMAL</code></li>\n</ul>\n</div>\n<h2 id=\"mysql-中-varchar-和-char-的区别\"> Mysql 中 varchar 和 char 的区别？</h2>\n<p><code>varchar</code> 会根据存储的内容改变长度，<code>char</code> 是定长，如果长度不够，则使用空格补齐。使用空格补齐仅是在插入的时候，检索的时候会将末尾的空格删掉。</p>\n<h2 id=\"mysql-中插入数据使用自增-id-好还是使用-uuid-为什么\"> Mysql 中插入数据使用自增 id 好还是使用 uuid，为什么？</h2>\n<ul>\n<li>单实例或单节点组，不担心网络爬虫获取数据量，推荐使用自增id，性能更好</li>\n<li>分布式场景，20 个节点下的小规模分布式场景，推荐 uuid；20~200 个节点的中规模分布式场景，推荐自增 id + 步长的策略；200 以上节点，推荐雪花算法的全局自增 id</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🖖 DDL",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/ddl/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/ddl/",
      "content_html": "<h2 id=\"如何高效处理大库-ddl\"> 如何高效处理大库 DDL？</h2>\n<p>有时希望在不停机的情况下在某张表中添加或删除某个字段，大多数的 <code>alter table</code> 操作都会涉及 <code>lock --&gt; copy to new table --&gt; rename --&gt; unlock</code> 的过程，数据量太大的情况下，锁表的时间会很长，而且 <code>alter table</code> 的进程不可以被杀死，一旦执行就不可回退。</p>\n<p>从 MySQL 5.6 开始，Online DDL 特性被引进，它增强了很多种类的 <code>alter table</code> 操作避免拷贝表和锁表，在运行 <code>alter</code> 操作的同时允许运行 <code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 语句。但是仍然有一些 <code>alter</code> 操作（比如：增加/删除列，增加/删除主键，改变数据类型等）需要重建表。并不建议直接在线上使用 <code>alter table</code>。建议使用以下两种方式：</p>\n<h3 id=\"主从架构轮询修改\"> 主从架构轮询修改</h3>\n<p>这种方式使用的前提是使用了集群，修改的原理就是利用主从服务，在应用无感知的情况下，得到停机窗口，进行修改。</p>\n<h3 id=\"利用已有的工具\"> 利用已有的工具</h3>\n<p>可以使用 online-schema-change 工具来进行 DDL。它会创建一个和要执行 <code>alter</code> 操作的表一样的空表，执行表结构修改，然后从原表中复制原始数据到新表中。当数据复制完成以后就会用新表代替原表，默认动作是将原表 <code>drop</code>。在复制数据的过程中，任何在原表的更新操作都会同步更新到新表，因为这个工具会在原表上创建了触发器。</p>\n<h2 id=\"mysql-有哪些约束\"> MySQL 有哪些约束？</h2>\n<ul>\n<li>非空约束：<code>not null</code></li>\n<li>唯一性约束：<code>unique</code>，表示具备唯一性，可为 <code>null</code></li>\n<li>主键约束：<code>primary key</code></li>\n<li>外键约束：<code>foreign key</code></li>\n<li>检查约束：<code>check</code>，MySQL 不支持</li>\n<li>默认约束：<code>default</code>，保证字段会有一个默认值</li>\n</ul>\n<h2 id=\"数据库外键的优缺点\"> 数据库外键的优缺点？</h2>\n<ul>\n<li>优点\n<ul>\n<li>能最大限度的保证数据的一致性和完整性</li>\n<li>增加 ER 图的可读性</li>\n</ul>\n</li>\n<li>缺点\n<ul>\n<li>影响数据操作的效率</li>\n<li>增加开发难度，导致表过多</li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤞 锁",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/lock/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/lock/",
      "content_html": "<h2 id=\"什么是共享锁和排他锁\"> 什么是共享锁和排他锁？</h2>\n<h3 id=\"共享锁\"> 共享锁</h3>\n<p>使用方式为：<code>select * from table lock in share mode</code>，表示自身可以读，其他事务也可以读（也可以继续加共享锁），但是其他事务无法修改。</p>\n<h3 id=\"排它锁\"> 排它锁</h3>\n<p>使用方式为：<code>select * from table for update</code>，表示自身可以进行增删改查，其他事务无法进行任何操作。排它锁是一种悲观锁，更新、插入、删除默认加排它锁，查询默认不加锁。</p>\n<h2 id=\"什么是-next-key-lock\"> 什么是 Next-Key Lock？<i>Not supported content</i></h2>\n<p>InnoDB 有三种锁的方式：</p>\n<ul>\n<li>Record Lock：对某一行上锁</li>\n<li>Gap Lock：间隙锁，锁定一个范围，但不包括记录本身，目的在于防止同一事务的两次读出现幻读</li>\n<li>Next-Key Lock：上面两种锁的组合，它会锁定一个范围，并且锁定记录本身，主要目的是为了解决幻读</li>\n</ul>\n<p>假设某一个时刻，某张表的 id 只有两个值，分别为 10 和 14。如果查询条件为 id &gt; 9，并且某个事务新插入了一条 id = 12 的数据，使用前两种锁将导致幻读。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🖐️ 存储引擎",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/engine/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/engine/",
      "content_html": "<h2 id=\"innodb-和-myisam-的区别\"> InnoDB 和 MyISAM 的区别？</h2>\n<ul>\n<li>Innodb 支持事务，MyISAM 不支持</li>\n<li>Innodb 支持外键，MyISAM 不支持</li>\n<li>Innodb 主键索引的叶子节点是数据文件，辅助索引的叶子节点是主键的值；MyISAM 的主键索引和辅助索引的叶子节点都是数据文件的指针</li>\n<li>Innodb 不保存表的行数，执行 <code>select count(*) from table</code> 需要全表扫描；MyISAM 用一个变量保存了整个表的行数，执行上述语句只需要读取该变量，速度很快</li>\n<li>Innodb 所有的表在磁盘上保存在一个文件中；MyISAM 存储成三个文件</li>\n<li>Innodb 需要更多的内存和存储；MyISAM 可被压缩，存储空间较小</li>\n<li>Innodb 移植方案拷贝文件、备份 binlog，或者用 mysqldump，移植较困难；MyISAM 数据以文件形式存储，在备份和回复时可以单独针对表进行操作</li>\n<li>Innodb 支持行锁、表锁；MyISAM 支持表锁</li>\n<li>Innodb 在 5.7 版本之前不支持全文索引；MyISAM 支持全文索引</li>\n</ul>\n<h2 id=\"innodb-的默认加锁方式-怎么实现的\"> InnoDB 的默认加锁方式，怎么实现的？</h2>\n<p>InnoDB 默认加锁方式是行级锁，通过给索引上的索引项加锁来实现的。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "✌️ 索引",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/m-index/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/m-index/",
      "content_html": "<h2 id=\"为什么使用数据库索引可以提高效率\"> 为什么使用数据库索引可以提高效率？</h2>\n<p>默认执行 SQL 语句时是进行全表扫描的，遇到匹配条件的就加入结果集。如果有索引，就会先去索引表中一次定位到特定值的行数，减少遍历匹配的行数。索引把无序的数据变成了相对有序的数据结构。</p>\n<h2 id=\"索引的底层数据结构是什么\"> 索引的底层数据结构是什么？<i>Not supported content</i></h2>\n<p>B+ 树。</p>\n<h2 id=\"什么是-b-树\"> 什么是 B+ 树？<i>Not supported content</i></h2>\n<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>\n<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现的，它具有 B Tree 的平衡性，并且可以通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 <code>key</code> 从左到右非递减排列，如果某个指针的左右相邻 <code>key</code> 分别是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span>e</span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 和 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span>e</span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>i</span><span>+</span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>，且不为 <code>null</code>，则该指针指向节点的所有 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span style=\"margin-right:0.03588em;\">ey</span></span></span></span> 大于等于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span>e</span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 且小于等于 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.902771em;vertical-align:-0.208331em;\"></span><span style=\"margin-right:0.03148em;\">k</span><span>e</span><span><span style=\"margin-right:0.03588em;\">y</span><span><span><span><span style=\"height:0.311664em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>i</span><span>+</span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.208331em;\"><span></span></span></span></span></span></span></span></span></span>。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/30/xu6AGHYJw5NvXC9.png\" alt=\"B+_树.jpg\" /></p>\n</div>\n<h2 id=\"为什么采用-b-树而不是-b-树\"> 为什么采用 B+ 树而不是 B 树？<i>Not supported content</i></h2>\n<p>B+ 树和 B 树的区别：</p>\n<ul>\n<li>B+ 树非叶子节点只存储关键字和指向子节点的指针，而 B 树还存储了数据，在同样大小的情况下，B+ 树可以存储更多的关键字</li>\n<li>B+ 树叶子节点存储了所有关键字和数据，并且多个节点用链表连接，可以快速进行范围查找</li>\n<li>B+ 树非叶子节点不存储数据，所以查询时间复杂度固定为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.10903em;\">N</span><span>)</span></span></span></span>，B 树查询时间复杂度不固定，最好是 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>1</span><span>)</span></span></span></span></li>\n</ul>\n<h2 id=\"为什么采用-b-树而不是红黑树\"> 为什么采用 B+ 树而不是红黑树？<i>Not supported content</i></h2>\n<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ 树作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p>\n<h3 id=\"b-树有更低的树高\"> B+ 树有更低的树高</h3>\n<p>平衡树的树高 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>h</span><span>)</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span> </span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span><span>lo<span style=\"margin-right:0.01389em;\">g</span></span><span><span><span><span style=\"height:0.24196799999999993em;\"><span style=\"top:-2.4558600000000004em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>d</span></span></span></span><span>​</span></span><span><span style=\"height:0.24414em;\"><span></span></span></span></span></span></span><span style=\"margin-right:0.16666666666666666em;\"></span><span style=\"margin-right:0.10903em;\">N</span><span>)</span></span></span></span>，其中 <code>d</code> 为每个节点的出度。红黑树的出度为 <code>2</code>，而 B+ 树的出度一般都非常大，所以红黑树的树高 <code>h</code> 很明显比 B+ 树大非常多。</p>\n<h3 id=\"磁盘访问原理\"> 磁盘访问原理</h3>\n<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p>\n<p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>\n<h3 id=\"磁盘预读特性\"> 磁盘预读特性</h3>\n<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>\n<h2 id=\"什么是聚簇和非聚簇索引\"> 什么是聚簇和非聚簇索引？<i>Not supported content</i></h2>\n<ul>\n<li>聚簇索引，又叫主键索引，每个表只有一个主键索引，即每张表按照主键构造一颗 B+ 树，叶子节点中存放的就是整张表的记录数据</li>\n<li>非聚簇索引，又叫辅助索引，叶子节点保存相应行数据的主键索引值</li>\n</ul>\n<h2 id=\"什么是前缀索引\"> 什么是前缀索引？</h2>\n<p>如果列的值较长，比如 <code>blob</code>、<code>text</code>、<code>varchar</code> 就必须建立前缀索引，即将值的前一部分（或后一部分）作为索引。这样既可以节约空间，又可以提高查询效率。但无法使用前缀索引做 <code>order by</code> 和 <code>group by</code>，也无法使用前缀索引做覆盖扫描。</p>\n<h2 id=\"什么是覆盖索引\"> 什么是覆盖索引？<i>Not supported content</i></h2>\n<p>覆盖索引是指 <code>select</code> 语句所查找的数据列从索引中就能获得，不必再从数据表中读取。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。当发起一个被索引覆盖的查询（也叫作索引覆盖查询）时，在解释方案的 Extra 列会提示 Using index。</p>\n<div><p>回表查询</p>\n<p>如果通过一个索引树不能拿到所有的数据，那么就会根据辅助索引中叶子节点所对应的主键去主键索引树种查询需要的信息，这种方式叫做回表查询。由于需要查多棵树，所以效率肯定会降低。举个例子：</p>\n<p>假设用户表（user）需要保存用户 id，用户姓名（name），用户性别（sex）。主键是 id，在 name 列上建了一个索引。如果使用下面的 sql 进行查询就使用到了覆盖索引，因为通过 name 索引树可以获得 name 和对应的 id（name 索引树的叶子节点保存会保存主键）：</p>\n<div><pre><code><span>select</span> id<span>,</span> name <span>from</span> <span>user</span> <span>where</span> name <span>=</span> ?<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>相反如果使用下面的 sql 进行查询，将导致回表查询，因为 name 索引树种不包含 sex 的信息，这个信息必须通过主键索引树进行获取：</p>\n<div><pre><code><span>select</span> id<span>,</span> name<span>,</span> sex <span>from</span> <span>user</span> <span>where</span> name <span>=</span> ?<span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div></div>\n<h2 id=\"什么情况会导致索引失效\"> 什么情况会导致索引失效？<i>Not supported content</i></h2>\n<p>对于以下情况，索引会失效：</p>\n<ul>\n<li><code>like</code> 以 % 开头</li>\n<li><code>or</code> 查询，必须左右字段都是索引，否则索引失效</li>\n<li>联合索引，遵从最左匹配原则，如果不是使用第一列索引，索引失效</li>\n<li>数据出现隐形转换，如 <code>varchar</code> 字段没加单引号，自动转为 <code>int</code> 类型，会使索引失效</li>\n<li>索引字段使用 <code>not</code>、<code>&lt;&gt;</code>、<code>!=</code> 会使索引失效</li>\n<li>索引字段使用函数，索引无效</li>\n</ul>\n<h2 id=\"什么是最左匹配原则\"> 什么是最左匹配原则？<i>Not supported content</i></h2>\n<p>对于联合索引，这些值在 B+ 树中存储时，是按照第一个值升序、第二个值升序...第 n 个值升序的方式来排列的（如果某个值相同，那么会比较下一个值）。举个例子：假设索引列是 a、b、c，那么索引中保存的结构可能是：</p>\n<p>（1，1，1），（1，1，2），（1，2，1），（1，2，2），（2，1，1）......</p>\n<p>因此，如果查询时未指定最左侧的列，那么将不能快速定位数据的范围，导致 MySQL 需要进行全表（或范围）扫描。 还是以上面的内容举例，比如我用使用这个语句来搜索：</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> tableName <span>where</span> b <span>=</span> <span>2</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>由于没有指定 a 的值，那么只能挨个访问记录，看一下 b 是不是等于 2。相反，如果我用这个语句来搜索：</p>\n<div><pre><code><span>select</span> <span>*</span> <span>from</span> tableName <span>where</span> a <span>=</span> <span>1</span> <span>and</span> b <span>=</span> <span>2</span><span>;</span>\n</code></pre>\n<div><span>1</span><br></div></div><p>由于指定了 a = 1，那么只需要在有限的集合中进行查找就可以了。通过 <code>explain</code> 也可以看到上述两条语句的区别。</p>\n<h2 id=\"什么是-mysql-索引重建-为什么需要索引重建\"> 什么是 Mysql 索引重建，为什么需要索引重建？</h2>\n<p>数据库在删除数据时只是将原始数据标记为已删除，实际上并没有释放空间，这会造成页面中有很多空洞，所以需要重建索引提高页面页面利用率。索引重建的过程会创建一个新的索引，把数据按顺序插入，使索引更紧凑、更省空间。重建索引的方式包括：</p>\n<ul>\n<li><code>mysqldump</code> 导出然后重新导入</li>\n<li><code>alter table tableName ENGINE = InnoDB</code></li>\n<li><code>alter table tableName drop/add index k</code></li>\n<li><code>alter table tableName drop/add primary key</code></li>\n</ul>\n<h2 id=\"解释方案中关键的字段有哪些\"> 解释方案中关键的字段有哪些？<i>Not supported content</i></h2>\n<p>在一个语句的前面添加 <code>explain</code> 就可以获得这个语句的执行方案。在执行方案中有几个比较关键的字段（以下内容只列举了一部分，实际上内容很多）：</p>\n<table>\n   <tr>\n      <th>字段</th>\n      <th>字段含义</th>\n      <th>可能的取值</th>\n      <th>这个取值的含义</th>\n   </tr>\n   <tr>\n      <th rowspan=\"3\">type</th>\n      <td rowspan=\"3\">查找类型</td>\n      <td>all</td>\n      <td>表示此次查询进行了全表扫描</td>\n   </tr>\n   <tr>\n      <td>const</td>\n      <td>表示表中有多条记录，但只从表中查询一条记录</td>\n   </tr>\n   <tr>\n      <td>index</td>\n      <td>表示对表中的索引进行了完整的扫描</td>\n   </tr>\n   <tr>\n      <th>possible_keys</th>\n      <td>查询可能使用到的索引都会在这里列出来，如果为空说明没有可用的索引</td>\n      <td></td>\n      <td></td>\n   </tr>\n   <tr>\n      <th>key</th>\n      <td>实际使用的索引</td>\n      <td></td>\n      <td></td>\n   </tr>\n   <tr>\n      <th>rows</th>\n      <td>表示查询的行数，这个值是一个估计值</td>\n      <td></td>\n      <td></td>\n   </tr>\n   <tr>\n      <th>extra</th>\n      <td>额外的信息说明</td>\n      <td>using_index</td>\n      <td>表示此次查询利用了覆盖索引</td>\n   </tr>\n</table>\n",
      "image": "https://i.loli.net/2021/07/30/xu6AGHYJw5NvXC9.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤚 范式",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/normal-form/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/normal-form/",
      "content_html": "<h2 id=\"什么是三范式\"> 什么是三范式？</h2>\n<ul>\n<li>第一范式：确保每列的原子性，每列都是不可分割的最小数据单元</li>\n<li>第二范式：在第一范式的基础上，要求每列都和主键相关</li>\n<li>第三范式：在第二范式的基础上，要求其他列和主键是直接相关，而不是间接相关（消除传递依赖）</li>\n</ul>\n<h2 id=\"范式和反范式的优缺点\"> 范式和反范式的优缺点？</h2>\n<h3 id=\"范式化\"> 范式化</h3>\n<h4 id=\"优点\"> <strong>优点</strong></h4>\n<ul>\n<li>减少数据冗余</li>\n<li>表中重复数据较少，更新操作比较快</li>\n<li>范式化的表通常比反范式化的表小</li>\n</ul>\n<h4 id=\"缺点\"> <strong>缺点</strong></h4>\n<ul>\n<li>在查询的时候通常需要很多的关联，降低性能</li>\n<li>增加了索引优化的难度</li>\n</ul>\n<h3 id=\"反范式化\"> 反范式化</h3>\n<h4 id=\"优点-2\"> <strong>优点</strong></h4>\n<ul>\n<li>可以减少表的关联</li>\n<li>更好的进行索引优化</li>\n</ul>\n<h4 id=\"缺点-2\"> <strong>缺点</strong></h4>\n<ul>\n<li>数据重复冗余</li>\n<li>对数据表的修改需要更多的成本</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 MySQL - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/",
      "content_html": "<p>目前主流的关系型数据库就是 MySQL，其他的数据库如果没时间就不建议去看了，直接看 MySQL 就行了：</p>\n<ol>\n<li><a href=\"/interview/mysql/normal-form/\">范式</a>：数据库表结构设计标准，但实际上并不一定会按照这个来</li>\n<li><a href=\"/interview/mysql/datatype/\">数据类型</a>：MySQL 提供的数据类型</li>\n<li><a href=\"/interview/mysql/engine/\">存储引擎</a>：MySQL 提供的存储引擎，主要使用 InnoDB</li>\n<li><a href=\"/interview/mysql/ddl/\">DDL</a>：DDL 操作</li>\n<li><a href=\"/interview/mysql/transcation/\">事务</a>：MySQL 怎么处理事务</li>\n<li><a href=\"/interview/mysql/m-index/\">索引</a>：MySQL 怎么设计的索引</li>\n<li><a href=\"/interview/mysql/lock/\">锁</a>：MySQL 都有哪些锁</li>\n<li><a href=\"/interview/mysql/slow-query/\">慢查询</a>：怎么排查慢查询</li>\n<li><a href=\"/interview/mysql/view/\">视图</a>：如果创建与使用视图</li>\n<li><a href=\"/interview/mysql/cluster/\">集群</a>：MySQL 集群如何使用</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👎 慢查询",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/slow-query/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/slow-query/",
      "content_html": "<h2 id=\"mysql-什么情况会造成慢查询-如何查看慢查询日志\"> Mysql 什么情况会造成慢查询，如何查看慢查询日志？</h2>\n<p>响应时间超过阈值会产生慢查询日志，一般以下情况会造成查询慢：</p>\n<ul>\n<li>没有设置索引，或查询没有用到索引</li>\n<li>I/O 吞吐量过小</li>\n<li>内存不足</li>\n<li>网络速度慢</li>\n<li>查询的数据量过大</li>\n<li>锁或者死锁</li>\n<li>返回了不必要的行或列</li>\n<li>查询语句存在问题，需要优化</li>\n</ul>\n<p>慢查询日志默认是关闭的，如果非必要，不要开启，会影响性能。使用 <code>SHOW VARIABLES LIKE 'slow_query%'</code> 查询得到：</p>\n<ul>\n<li>slow_query_log：是否开启慢查询日志</li>\n<li>slow_query_log_file：慢查询日志存储位置</li>\n</ul>\n<h2 id=\"如何解决慢查询\"> 如何解决慢查询？</h2>\n<ul>\n<li>把数据、日志、索引放到不同的 I/O 设备上，增加读取速度</li>\n<li>纵向、横向分割表，减少表的尺寸</li>\n<li>升级硬件</li>\n<li>根据查询条件，建立索引，索引优化</li>\n<li>提高网速</li>\n<li>扩大服务器内存</li>\n<li>分库分表</li>\n</ul>\n<h2 id=\"数据库优化的方式有哪些\"> 数据库优化的方式有哪些？</h2>\n<ul>\n<li>排除缓存的干扰</li>\n<li>通过 explain 获取执行计划</li>\n<li>使用覆盖索引</li>\n<li>使用联合索引</li>\n<li>最左匹配原则\n在模糊查询中如果使用 xx% 的形式还是能够利用索引的。</li>\n<li>使用前缀索引</li>\n<li>不要在条件中使用函数</li>\n<li>不要使用隐式类型转换</li>\n</ul>\n<div><p>MySQL 的缓存</p>\n<p>MySQL 8 之前版本的数据库是存在缓存的，如果当前的 MySQL 支持缓存同时也开启了缓存，那每次请求的查询语句和结果都会以 key-value 的形式进行缓存，在查询时会优先查找缓存，但只要数据一更新，缓存就会失效，所以缓存的用处并不大。在 <code>select</code> 语句上添加 <code>sql_no_cache</code> 可以避免使用缓存。</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👍 事务",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/transcation/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/transcation/",
      "content_html": "<h2 id=\"什么是事务\"> 什么是事务？</h2>\n<p>事务是一个操作序列，这些操作要么全部执行，要么都不执行。</p>\n<h2 id=\"事务的四大特性\"> 事务的四大特性？</h2>\n<p>事务具有四大特性：</p>\n<ul>\n<li>原子性：事务是最小的执行单位，不允许分割，事务的原子性确保动作要么全部完成，要么完全不起作用</li>\n<li>一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的</li>\n<li>隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，多个并发事务之间相互隔离，防止出现脏读、不可重复读、幻读</li>\n<li>持久性：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li>\n</ul>\n<h2 id=\"mysql-是如何实现事务的\"> MySQL 是如何实现事务的？<i>Not supported content</i></h2>\n<p>事务是通过如下方式实现的：</p>\n<ul>\n<li>原子性：通过 undo log 实现，每条数据变更都伴随一条 undo log 日志的生成，当系统发生错误或执行回滚根据 undo log 做逆向操作</li>\n<li>持久性：通过 redo log 实现的，redo log 记录了数据的修改日志。数据持久化到磁盘，先是储存到缓冲池里，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢失数据，系统重启后会读取redo log恢复数据</li>\n<li>隔离性：MySQL 数据库通过 MVCC + next-key 机制实现了隔离性</li>\n<li>一致性：通过以上三大特性，保障了事务的一致性</li>\n</ul>\n<div><p>binlog 和 redolog</p>\n<p>binlog 是二进制文件，记录了对数据库执行更改的所有操作，不包括 <code>select</code>、<code>show</code>，因为这两个操作没有对数据本身做修改。但是如果操作了数据，但是数据没有发生变化，也会记录到 binlog。常用来数据恢复，数据备份。</p>\n<p>redo log 又叫做重做日志文件，记录了事务的修改，不管事务是否提交都记录下来。在实例和介质失败时，InnoDB 存储引擎会使用 redo log 恢复到之前的状态，保证数据的完整性。</p>\n</div>\n<h2 id=\"mysql-的隔离级别都有哪些\"> MySQL 的隔离级别都有哪些？<i>Not supported content</i></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">READ-UNCOMMITTED 读未提交</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">READ-COMMITTED 读已提交</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:center\">✔</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">REPEATABLE-READ 可重复读</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">✔</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SERIALIZABLE 可串行化</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n<td style=\"text-align:center\">❌</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"什么情况会造成脏读、不可重复读、幻读-如何解决\"> 什么情况会造成脏读、不可重复读、幻读？如何解决？<i>Not supported content</i></h2>\n<ul>\n<li>脏读（<strong>一个事务读取到另一个事务未提交的数据</strong>）：有两个事务 A 和 B，A 读取已经被 B 修改但未提交的字段，此时 B 回滚，那么 A 读取的字段就是临时且无效的，可以提高隔离级别，改成读已提交</li>\n<li>不可重复读（<strong>一个事务读取到另一个事务提交的数据</strong>）： 有两个事务 A 和 B，A 读取了一个字段值，然后 B 更新并且提交事务，A 再重新读取这个字段，就和之前不相等了，可以提高隔离级别，改成可重复读</li>\n<li>幻读（<strong>一个事务读取到另一个事务提交的数据</strong>）： 有两个事务 A 和 B，A 读取某个范围内的记录时，B 又在该范围内插入了新的记录并提交，当事务 A 再次读取该范围的记录时，会产生幻行</li>\n</ul>\n<div><p>不可重复读和幻读的区别</p>\n<ul>\n<li>不可重复读的重点是修改，比如多次读取一条记录发现其中某些列的值被修改</li>\n<li>幻读的重点在于新增或者删除，比如多次读取一条记录发现记录增多或减少了</li>\n</ul>\n</div>\n<h2 id=\"mvcc-的实现原理\"> MVCC 的实现原理？<i>Not supported content</i></h2>\n<p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number)。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>\n<h3 id=\"select\"> SELECT</h3>\n<p>InnoDB 会根据以下两个条件检查每行记录，只有符合下面两个条件的记录，才能返回作为查询结果：</p>\n<ul>\n<li>对于创建版本，只查找早于当前事务版本的数据行（行的系统版本号小于或等于事务版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的</li>\n<li>对于删除版本，只查找早于当前事务版本的数据行（删除版本可以没有定义），这样可以确保事务读取到的行，在事务开始之前未被删除</li>\n</ul>\n<h3 id=\"insert\"> INSERT</h3>\n<p>对新插入的每一行保存当前系统版本号作为行版本号。</p>\n<h3 id=\"delete\"> DELETE</h3>\n<p>对删除的每一行保存当前系统版本号作为行删除标识。</p>\n<h3 id=\"update\"> UPDATE</h3>\n<p>插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👂 视图",
      "url": "https://blog.lixiangyu.xyz/interview/mysql/view/",
      "id": "https://blog.lixiangyu.xyz/interview/mysql/view/",
      "content_html": "<h2 id=\"如何使用数据库的视图\"> 如何使用数据库的视图？</h2>\n<p>使用 <code>create view view_name as select * from tb</code> 创建视图，使用 <code>select * from view_name</code> 可查询视图。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧥 HTTP 协议基础",
      "url": "https://blog.lixiangyu.xyz/interview/network/http/http-basic/",
      "id": "https://blog.lixiangyu.xyz/interview/network/http/http-basic/",
      "content_html": "<h2 id=\"http-是什么\"> HTTP 是什么？</h2>\n<p>HTTP 是超文本传输协议，也就是 HyperText Transfer Protocol。</p>\n<h2 id=\"能否详细解释一下超文本传输协议\"> 能否详细解释一下超文本传输协议？</h2>\n<p>HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p>\n<h2 id=\"http-的优点\"> HTTP 的优点？</h2>\n<h3 id=\"简单\"> 简单</h3>\n<p>HTTP 基本的报文格式就是 header + body，头部信息也是 key-value 简单文本的形式，易于理解，降低了学习和使用的门槛。</p>\n<h3 id=\"灵活和易于扩展\"> 灵活和易于扩展</h3>\n<p>HTTP协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。同时 HTTP 由于是工作在应用层（ OSI 第七层），则它的下层可以随意变化。HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</p>\n<h3 id=\"应用广泛和跨平台\"> 应用广泛和跨平台</h3>\n<p>互联网发展至今，HTTP 的应用范围非常的广泛，天然具有跨平台的优越性。</p>\n<h2 id=\"http-的缺点\"> HTTP 的缺点？</h2>\n<h3 id=\"无状态\"> 无状态</h3>\n<ul>\n<li>无状态的好处：因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</li>\n<li>无状态的坏处：既然服务器没有记忆能力，它在完成有关联性的操作时（比如登录、评论、购买等）会非常麻烦。</li>\n</ul>\n<h3 id=\"明文传输\"> 明文传输</h3>\n<p>明文意味着在传输过程中的信息都可以直接获取到，信息的内容都毫无隐私可言，很容易就能被窃取。</p>\n<ul>\n<li>通信使用明文（不加密），内容可能会被窃听</li>\n<li>不验证通信方的身份，因此有可能遭遇伪装</li>\n<li>无法证明报文的完整性，所以有可能已遭篡改</li>\n</ul>\n<h2 id=\"常见的状态码有哪些\"> 常见的状态码有哪些？</h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">状态码</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">举例</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">1xx</td>\n<td style=\"text-align:center\">提示信息，表示目前是协议处理的中间装填，还需要后续操作</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">2xx</td>\n<td style=\"text-align:center\">成功，报文已经收到并被正确处理</td>\n<td style=\"text-align:center\">200、204、206</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">3xx</td>\n<td style=\"text-align:center\">重定向，资源发生变动，需要客户端重新发信请求</td>\n<td style=\"text-align:center\">301、302、304</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">4xx</td>\n<td style=\"text-align:center\">客户端错误，请求报文有误，服务器无法处理</td>\n<td style=\"text-align:center\">400、403、404</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">5xx</td>\n<td style=\"text-align:center\">服务器错误，服务器在处理请求时内部发生了错误</td>\n<td style=\"text-align:center\">500、501、502、503</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"http-协议中常见的字段有哪些\"> HTTP 协议中常见的字段有哪些？</h2>\n<ul>\n<li>Host 字段：用来指定服务器的域名</li>\n<li>Content-Length 字段：服务器在返回数据时会有 Content-Length 字段，表明本次回应的数据长度</li>\n<li>Connection 字段：Connection 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用，HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 Connection 首部字段的值为 Keep-Alive</li>\n<li>Content-Type 字段：Content-Type 字段用于服务器回应时，告诉客户端本次数据是什么格式，比如：application/json、text/html，客户端请求的时候，可以使用 Accept 字段声明自己可以接受哪些数据格式</li>\n<li>Content-Encoding 字段：Content-Encoding 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式，客户端在请求时，用 Accept-Encoding 字段说明自己可以接受哪些压缩方法</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "💍 HTTP 协议的改进",
      "url": "https://blog.lixiangyu.xyz/interview/network/http/http-improve/",
      "id": "https://blog.lixiangyu.xyz/interview/network/http/http-improve/",
      "content_html": "<h2 id=\"http-1-1-做了什么优化\"> HTTP/1.1 做了什么优化？</h2>\n<h3 id=\"长连接\"> 长连接</h3>\n<p>早期 HTTP/1.0 性能上的一个很大的问题，就是每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了很多无谓的 TCP 连接建立和断开，增加了通信开销。为了解决上述 TCP 连接问题，HTTP/1.1 提出了长连接的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</p>\n<p>持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。</p>\n<h3 id=\"管道网络传输\"> 管道网络传输</h3>\n<p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p>\n<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求。但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p>\n<h3 id=\"队头阻塞\"> 队头阻塞</h3>\n<p>请求 - 应答的模式加剧了 HTTP 的性能问题。因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是队头阻塞，好比上班的路上堵车。</p>\n<h2 id=\"http-2-做了什么优化\"> HTTP/2 做了什么优化？</h2>\n<p>HTTP/2 是基于 HTTPS 的，在安全性上是有保障的。相比 HTTP/1.1，改进的地方包括：</p>\n<h3 id=\"头部压缩\"> 头部压缩</h3>\n<p>HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。这就是所谓的 HPACK 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n<h3 id=\"二进制格式\"> 二进制格式</h3>\n<p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧和数据帧。增加了数据传输的效率。</p>\n<h3 id=\"数据流\"> 数据流</h3>\n<p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数。客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p>\n<h3 id=\"多路复用\"> 多路复用</h3>\n<p>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现队头阻塞问题，降低了延迟，大幅度提高了连接的利用率。举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p>\n<h3 id=\"服务器推送\"> 服务器推送</h3>\n<p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。</p>\n<h2 id=\"http-3-做了什么优化\"> HTTP/3 做了什么优化？</h2>\n<p>HTTP/2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p>\n<p>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Q2E8cSMpi7tfD4P.png\" alt=\"http3.png\" /></p>\n</div>\n<p>虽然 UDP 协议不可靠，但基于 UDP 协议的 QUIC 协议可以实现类似 TCP 协议的可靠传输。</p>\n<ul>\n<li>QUIC 有自己的一套机制可以保证传输的可靠性的，当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响</li>\n<li>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack</li>\n<li>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手，QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数</li>\n</ul>\n<p>所以 QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复用的协议。另外 QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢。</p>\n",
      "image": "https://i.loli.net/2021/08/01/Q2E8cSMpi7tfD4P.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "⛑️ HTTPS 协议",
      "url": "https://blog.lixiangyu.xyz/interview/network/http/https/",
      "id": "https://blog.lixiangyu.xyz/interview/network/http/https/",
      "content_html": "<h2 id=\"http-与-https-相比有哪些区别\"> HTTP 与 HTTPS 相比有哪些区别？</h2>\n<ul>\n<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输</li>\n<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输</li>\n<li>HTTP 的端口号是 80，HTTPS 的端口号是 443</li>\n<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li>\n</ul>\n<h2 id=\"https-是如何保证安全性的\"> HTTPS 是如何保证安全性的？</h2>\n<ul>\n<li>混合加密的方式实现信息的机密性，解决了窃听的风险</li>\n<li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的指纹，指纹用于校验数据的完整性，解决了篡改的风险</li>\n<li>将服务器公钥放入到数字证书中，解决了冒充的风险</li>\n</ul>\n<h2 id=\"https-是如何建立连接的\"> HTTPS 是如何建立连接的？</h2>\n<p>SSL/TLS 协议基本流程：</p>\n<ul>\n<li>客户端向服务器索要并验证服务器的公钥</li>\n<li>双方协商生产会话密钥</li>\n<li>双方采用会话密钥进行加密通信</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "💼 HTTP 协议的请求方法",
      "url": "https://blog.lixiangyu.xyz/interview/network/http/http-method/",
      "id": "https://blog.lixiangyu.xyz/interview/network/http/http-method/",
      "content_html": "<h2 id=\"get-和-post-请求的区别\"> Get 和 Post 请求的区别？</h2>\n<p>Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。而 POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。</p>\n<h2 id=\"get-和-post-请求都是安全和幂等的吗\"> Get 和 Post 请求都是安全和幂等的吗？</h2>\n<p>先说明下安全和幂等的概念：</p>\n<ul>\n<li>在 HTTP 协议里，所谓的安全是指请求方法不会破坏服务器上的资源</li>\n<li>所谓的幂等，意思是多次执行相同的操作，结果都是相同的</li>\n</ul>\n<p>那么很明显 GET 方法就是安全且幂等的，因为它是只读操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。POST 因为是新增或提交数据的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤴 HTTP 协议 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/network/http/",
      "id": "https://blog.lixiangyu.xyz/interview/network/http/",
      "content_html": "<p>一个应用于应用层的协议：</p>\n<ol>\n<li><a href=\"/interview/network/http/http-basic\">HTTP 协议基础</a>：介绍 HTTP 协议的基础知识</li>\n<li><a href=\"/interview/network/http/http-method\">HTTP 协议的请求方法</a>：最常见的是 GET 和 POST</li>\n<li><a href=\"/interview/network/http/other\">HTTPS 协议</a>：HTTP 协议并不安全，如何通过 HTTPS 协议增加安全性</li>\n<li><a href=\"/interview/network/http/other\">HTTP 协议的改进</a>：HTTP 协议的演变</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👓 IP 地址",
      "url": "https://blog.lixiangyu.xyz/interview/network/ip/ip-address/",
      "id": "https://blog.lixiangyu.xyz/interview/network/ip/ip-address/",
      "content_html": "<h2 id=\"什么是-ip-地址\"> 什么是 IP 地址？</h2>\n<p>IP 地址（Internet Protocol Address）是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>\n<p>对于 IPv4（Internet Protocol version 4），它的地址由 32 位二进制数来表示。为了方便人的记忆，将 32 位的 IP 地址以每 8 位为一组进行划分，共可分为 4 组，每组以符号 <code>.</code> 分隔，再将每组转换成十进制。这种表示方式也称为“点分十进制”。</p>\n<p>对于 IPv6（Internet Protocol version 6），它的地址由 128 位二进制数来表示。每 16 位为一组，共可分为 8 组，使用符号 <code>:</code> 分隔，再将每组转换成十六进制。如：<code>2000:0:0:0:1:2345:6789:abcd</code>。</p>\n<h2 id=\"介绍一下-a-类-ip-地址\"> 介绍一下 A 类 IP 地址？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/lAzgYH8JaUq43LG.png\" alt=\"aip.png\" /></p>\n</div>\n<p>A 类 IP 地址第一位必须是 0，剩下的 31 位中有 7 位用于网络号，24 位用于主机号，一般用于政府机构。</p>\n<p>可分配的网络个数为：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>7</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>126</span></span></span></span>个（网络号全为 1，即 <code>127.x.x.x</code> 的地址是保留地址，不能使用）。</p>\n<p>可分配的主机个数为：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>24</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>16777214</span></span></span></span>（主机号全 0 表示本网络，主机号全 1 表示广播地址，这两个地址需要忽略，下同）。</p>\n<p>A 类 IP 地址的主机范围为：<code>1.0.0.0~127.255.255.255</code>。</p>\n<h2 id=\"介绍一下-b-类-ip-地址\"> 介绍一下 B 类 IP 地址？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/tmcSDefnCBkuPLJ.png\" alt=\"bip.png\" /></p>\n</div>\n<p>B 类 IP 地址的第一二位必须是 1 和 0，剩下的 30 位中有 14 位用于网络号，有 16 位用于主机号，一般用于大中型企业。</p>\n<p>可分配的网络个数：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>14</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>16383</span></span></span></span>个。</p>\n<p>可分配的主机个数：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>16</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>65534</span></span></span></span>个。</p>\n<p>B 类 IP 地址的主机范围为：<code>128.0.0.1~191.255.255.255</code>。</p>\n<h2 id=\"介绍一下-c-类-ip-地址\"> 介绍一下 C 类 IP 地址？</h2>\n<p>C 类 IP 地址的第一二位必须是 1，第三位必须是 0，剩下的 29 位中有 21 位用于网络号，有 8 位用于主机号，个人可以使用。</p>\n<p>可分配的网络个数：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>21</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2097151</span></span></span></span>个。</p>\n<p>可分配的主机个数：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>8</span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>2</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>254</span></span></span></span>个。</p>\n<p>C 类 IP 地址的主机范围为：<code>192.0.0.0~223.255.255.255</code>。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/jABfvJSEwQ9ILZ8.png\" alt=\"cip.png\" /></p>\n<div>\n<h2 id=\"介绍一下-d、e-类-ip-地址\"> 介绍一下 D、E 类 IP 地址？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/6WZasjz1mVKJDqg.png\" alt=\"oip.png\" /></p>\n<div>\n<p>D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。</p>\n<h2 id=\"如何快速区别上述五类地址\"> 如何快速区别上述五类地址？</h2>\n<p>看前四位哪一位是 0，它就是哪类地址：</p>\n<ul>\n<li>第一位是 0 -&gt; A 类地址</li>\n<li>第二位是 0 -&gt; B 类地址</li>\n<li>...</li>\n<li>全都不是 0 -&gt; E 类地址</li>\n</ul>\n<h2 id=\"ip-分类所导致的问题\"> IP 分类所导致的问题？</h2>\n<h3 id=\"同一网络下没有地址划分\"> 同一网络下没有地址划分</h3>\n<p>比如一个公司使用了 B 类地址，他们可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。</p>\n<h3 id=\"不能很好的与现实网络匹配\"> 不能很好的与现实网络匹配</h3>\n<p>C 类地址能包含的最大主机数量实在太少了，只有 254 个。而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，空闲的地址就是浪费。需要通过 CIDR 无分类地址解决。</p>\n<h2 id=\"介绍一下-cidr\"> 介绍一下 CIDR？</h2>\n<p>因为 IP 分类存在许多缺点，所以后面提出了无分类地址的方案，即 CIDR。这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。表示形式为<code>a.b.c.d/x</code>，其中 /x 表示前 x 位属于网络号，x 的范围是 0 ~ 32，这就使得 IP 地址更加具有灵活性。</p>\n<p>比如 <code>10.100.122.2/24</code>，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/zB5WZC2UN7JHtp6.png\" alt=\"cidr1.png\" /></p>\n<div>\n<p>还有另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。将子网掩码和 IP 地址按位计算与，就可得到网络号。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/i4d1QKW2N5uHCPI.png\" alt=\"cidr2.png\" /></p>\n<div>\n<h2 id=\"怎么进行子网划分\"> 怎么进行子网划分？</h2>\n<p>子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。形式如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/nY9Z2RM3GKegEdT.png\" alt=\"ip子网划分.png\" /></p>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n</div>\n<h2 id=\"哪些地址是私有-ip\"> 哪些地址是私有 IP？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/ynH4sI5iSTzpvDJ.png\" alt=\"ip私有.png\" /></p>\n</div>\n",
      "image": "https://i.loli.net/2021/08/01/lAzgYH8JaUq43LG.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👣 IP 协议基础",
      "url": "https://blog.lixiangyu.xyz/interview/network/ip/ip-basic/",
      "id": "https://blog.lixiangyu.xyz/interview/network/ip/ip-basic/",
      "content_html": "<h2 id=\"介绍一下-ip-协议\"> 介绍一下 IP 协议？</h2>\n<p>IP 协议在 TCP/IP 模型中处于第三层，也就是网络层。网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。</p>\n<h2 id=\"ip-和-mac-之间的关系\"> IP 和 MAC 之间的关系？</h2>\n<p>MAC（数据链路层） 的作用是实现直连的两个设备之间通信，而 IP（网络层） 则负责在没有直连的两个网络之间进行通信传输。</p>\n<div><p>IP 与 MAC</p>\n<p>因为出发地和目的地是不会变的，所以源 IP 地址和目标 IP 地址在传输过程中是不会变化的。但这个过程中可能通过不同的路由器进行转发，所以源 MAC 地址和目标 MAC 是一直在变化</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👕 其他",
      "url": "https://blog.lixiangyu.xyz/interview/network/ip/other/",
      "id": "https://blog.lixiangyu.xyz/interview/network/ip/other/",
      "content_html": "<h2 id=\"dns-域名解析流程\"> DNS 域名解析流程？<i>Not supported content</i></h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/auYBznLxjq7s524.png\" alt=\"dns解析流程.png\" /></p>\n</div>\n<h2 id=\"广播和多播的区别\"> 广播和多播的区别？</h2>\n<p>广播是将包发送给所有连接的主机。多播是将包发送给特定的某个、某几个主机。</p>\n<h2 id=\"介绍一下-arp-协议\"> 介绍一下 ARP 协议？</h2>\n<p>主机通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</p>\n<p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。不过 MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。</p>\n<h2 id=\"了解-rarp-协议吗\"> 了解 RARP 协议吗？</h2>\n<p>ARP 协议是已知 IP 地址求 MAC 地址，RARP 协议正好相反，它是已知 MAC 地址求 IP 地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。通常需要架设一台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，然后：</p>\n<ul>\n<li>该设备会发送一条&quot;我的 MAC 地址是 xx，请告诉我我的 IP 地址应该是什么&quot;的请求信息。</li>\n<li>RARP 服务器接到这个消息后返回&quot;MAC 地址为 xx 的设备，IP 地址为 xx&quot;的信息给这个设备。\n最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/08/01/auYBznLxjq7s524.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👨‍🔧 IP - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/network/ip/",
      "id": "https://blog.lixiangyu.xyz/interview/network/ip/",
      "content_html": "<p>一个应用于网络层的协议：</p>\n<ol>\n<li><a href=\"/interview/network/ip/ip-basic\">IP 协议基础</a>：介绍 IP 协议的基础知识</li>\n<li><a href=\"/interview/network/ip/ip-address\">IP 地址</a>：IP 地址如何划分</li>\n<li><a href=\"/interview/network/ip/other\">其他</a>：一些其他内容</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 计算机网络 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/network/",
      "id": "https://blog.lixiangyu.xyz/interview/network/",
      "content_html": "<p>重温一下计算机网络，模型图必须了解：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/VGkNyafPdFxnO2j.png\" alt=\"计算机网络模型.png\" /></p>\n</div>\n<p>常问的主要是 TCP 相关的知识，但是 IP 和 HTTP 相关的知识点也一起整理了：</p>\n<ol>\n<li><a href=\"/interview/network/ip/\">IP</a>：IP 协议相关知识点</li>\n<li><a href=\"/interview/network/tcp/\">TCP</a>：TCP 协议相关知识点</li>\n<li><a href=\"/interview/network/http/\">HTTP</a>：HTTP 协议相关知识点</li>\n</ol>\n",
      "image": "https://i.loli.net/2021/08/01/VGkNyafPdFxnO2j.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👨‍💼 TCP 协议 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/network/tcp/",
      "id": "https://blog.lixiangyu.xyz/interview/network/tcp/",
      "content_html": "<p>一个应用于运输层的协议：</p>\n<ol>\n<li><a href=\"/interview/network/tcp/tcp-basic\">TCP 协议基础</a>：介绍 TCP 协议的基础知识</li>\n<li><a href=\"/interview/network/tcp/tcp-connection\">建立连接与释放</a>：TCP 如何建立与释放连接，这一部分非常重要</li>\n<li><a href=\"/interview/network/tcp/tcp-retry\">超时重传机制</a>：如果收不到确认应答，TCP 协议是如何处理的</li>\n<li><a href=\"/interview/network/tcp/tcp-window\">滑动窗口</a>：通过滑动窗口增加发送的数据量</li>\n<li><a href=\"/interview/network/tcp/tcp-control\">拥塞控制</a>：通过拥塞窗口调节要发送的数据量</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧣 TCP 协议基础",
      "url": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-basic/",
      "id": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-basic/",
      "content_html": "<h2 id=\"什么是-tcp-和-udp-协议\"> 什么是 TCP 和 UDP 协议</h2>\n<p>TCP（Transmission Control Protocol）传输控制协议与 UDP（User Datagram Protocol）用户数据协议，都是运输层提供的通用数据传输协议。</p>\n<h2 id=\"tcp-和-udp-的区别-它们的使用场景\"> TCP 和 UDP 的区别，它们的使用场景？<i>Not supported content</i></h2>\n<ul>\n<li>TCP：面向连接，传输可靠，传输效率低</li>\n<li>UDP：无连接，传输不可靠，传输效率高</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧳 建立与释放连接",
      "url": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-connection/",
      "id": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-connection/",
      "content_html": "<h2 id=\"介绍一下-tcp-的三次握手\"> 介绍一下 TCP 的三次握手？<i>Not supported content</i></h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/MoAdhFvkaTfROXC.png\" alt=\"tcp三次握手.jpg\" /></p>\n</div>\n<h3 id=\"第一次握手\"> 第一次握手</h3>\n<p>客户端发送带有 SYN 标志的数据包，假设 SYN 的序列号为 J。</p>\n<h3 id=\"第二次握手\"> 第二次握手</h3>\n<p>服务端接收到 SYN J 的请求后，向客户端返回带有 SYN/ACK 标志的数据包，ACK 的序列号为 J + 1，表示是 SYN J 的应答，新发送的 SYN 的序列号为 K。</p>\n<h3 id=\"第三次握手\"> 第三次握手</h3>\n<p>客户端在接收到服务端的应答后，向服务端返回带有 ACK 标志的数据包，ACK 的序列号为 K + 1，表示是 SYN K 的应答。</p>\n<h2 id=\"为什么是三次握手而不是两次或者四次握手\"> 为什么是三次握手而不是两次或者四次握手？<i>Not supported content</i></h2>\n<h3 id=\"三次握手才可以阻止重复历史连接的初始化\"> 三次握手才可以阻止重复历史连接的初始化</h3>\n<p>客户端连续发送多次 SYN 建立连接的报文，在网络拥堵情况下：</p>\n<ul>\n<li>一个旧 SYN 报文比最新的 SYN 报文早到达了服务端</li>\n<li>那么此时服务端就会回一个 SYN + ACK 报文给客户端</li>\n<li>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 RST（Reset the connection，用于复位因某种原因引起出现的错误连接，也用来拒绝非法数据和请求）报文给服务端，表示中止这一次连接</li>\n</ul>\n<p>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时：</p>\n<ul>\n<li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此终止历史连接</li>\n<li>如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接</li>\n</ul>\n<h3 id=\"同步双方初始序列号\"> 同步双方初始序列号</h3>\n<p>TCP 协议的通信双方， 都必须维护一个序列号， 序列号是可靠传输的一个关键因素，它的作用包括：</p>\n<ul>\n<li>接收方可以去除重复的数据</li>\n<li>接收方可以根据数据包的序列号按序接收</li>\n<li>可以标识发送出去的数据包中， 哪些是已经被对方收到的</li>\n</ul>\n<p>可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，这样一来一回，才能确保双方的初始序列号能被可靠的同步。</p>\n<h3 id=\"避免资源浪费\"> 避免资源浪费</h3>\n<p>如果只有两次握手，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN 。由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？</p>\n<p>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>\n<div><p>四次握手</p>\n<p>四次握手是将服务器返回的 ACK + SYN 拆成两次进行返回的，但实际上这两步可以放在一起处理，因此最终简化成了三次握手。</p>\n</div>\n<h2 id=\"可以把其他数据和第三次握手的-ack-一起发给服务端吗\"> 可以把其他数据和第三次握手的 ACK 一起发给服务端吗？</h2>\n<p>客户端在收到服务端的第二次握手信息时就已经可以知道通信连接是正常的，状态会变更为 ESTABLISHED，所以在第三次握手时可以传输数据。</p>\n<h2 id=\"介绍一下-tcp-的四次挥手\"> 介绍一下 TCP 的四次挥手？<i>Not supported content</i></h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/SqEDgmkBano9NQb.png\" alt=\"tcp四次挥手.jpg\" /></p>\n</div>\n<h3 id=\"第一次挥手\"> 第一次挥手</h3>\n<p>客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。</p>\n<h3 id=\"第二次挥手\"> 第二次挥手</h3>\n<p>服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSED_WAIT 状态。客户端收到服务端的 ACK 应答报文后，进入 FIN_WAIT_2 状态。</p>\n<h3 id=\"第三次挥手\"> 第三次挥手</h3>\n<p>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。</p>\n<h3 id=\"第四次挥手\"> 第四次挥手</h3>\n<p>客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态。服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。<strong>客户端在经过 2MSL 个时间后，自动进入 CLOSED 状态</strong>，至此客户端也完成连接的关闭。</p>\n<h2 id=\"为什么需要四次挥手\"> 为什么需要四次挥手？<i>Not supported content</i></h2>\n<ul>\n<li>关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据</li>\n<li>服务器收到客户端的 FIN 报文时，先回一个 ACK 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报文给客户端来表示同意现在关闭连接</li>\n</ul>\n<p>由于服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手多了一次。</p>\n",
      "image": "https://i.loli.net/2021/08/01/MoAdhFvkaTfROXC.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🚶‍♂️ 超时重传机制",
      "url": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-retry/",
      "id": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-retry/",
      "content_html": "<h2 id=\"介绍一下超时重传机制\"> 介绍一下超时重传机制？</h2>\n<p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，这就是超时重传。</p>\n<p>TCP 会在以下两种情况发生超时重传：</p>\n<ul>\n<li>数据包丢失</li>\n<li>确认应答丢失</li>\n</ul>\n<h2 id=\"怎么确认超时重传的超时时间\"> 怎么确认超时重传的超时时间？</h2>\n<p>先介绍一下 RTT 和 RTO：</p>\n<ul>\n<li>RTT（Round-Trip Time）指的是数据从网络一端传送到另一端所需的时间，也就是包的往返时间</li>\n<li>RTO（Retransmission Timeout）指的是超时重传时间</li>\n</ul>\n<p>如果 RTO 设置的不太合适：</p>\n<ul>\n<li>如果设置的比较短，那么可能并没有丢包但依然重发了，这会造成网络阻塞</li>\n<li>如果设置的比较长，那么可能在丢包很久后才进行重发，效率低</li>\n</ul>\n<p>所以 RTO 应该是一个动态的值，并且要略大于 RTT。RTT 也是一个动态的值，它的估算需要以下两点，具体的计算公式就不贴了：</p>\n<ul>\n<li>TCP 采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化</li>\n<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况</li>\n</ul>\n<p>如果超时重发的数据，再次超时重传，那么 TCP 的策略是超时间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。超时触发重传存在的问题是，超时周期可能相对较长。所以就可以用快速重传机制来解决超时重发的时间等待。</p>\n<h2 id=\"介绍一下快速重传机制\"> 介绍一下快速重传机制？</h2>\n<p>TCP 还有另外一种叫做快速重传（Fast Retransmit）的机制，它不以时间为驱动，而是以数据驱动进行重传。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/j2vNckRoiV6EmW4.png\" alt=\"快速重传.png\" /></p>\n</div>\n<p>在上图，发送方发出了 1、2、3、4、5，共计 5 份数据：</p>\n<ul>\n<li>第一份 Seq1 先送到了，于是 Ack 返回了 2</li>\n<li>但是 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2</li>\n<li>后面的 Seq4 和 Seq5 都到了，但 Ack 还是返回 2，因为 Seq2 还是没有收到</li>\n<li>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2</li>\n<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li>\n</ul>\n<p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p>\n<p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题：重传的时候，是重传之前的一个，还是重传所有。比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。根据 TCP 不同的实现，以上两种情况都是有可能的。为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。</p>\n<h2 id=\"介绍一下-sack-重传机制\"> 介绍一下 SACK 重传机制？</h2>\n<p>还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。这种方式需要在 TCP 头部的选项字段里加一个 SACK ，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p>\n<p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/CIuGNljZ9EWfm1g.png\" alt=\"sack.png\" /></p>\n</div>\n<div><p>需要操作系统支持</p>\n<p>SACK 机制必须双方都要支持，在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。</p>\n</div>\n<h2 id=\"介绍一下-d-sack-机制\"> 介绍一下 D-SACK 机制</h2>\n<p>因为 ACK 丢包或者网络时延导致发送发没有及时收到 ACK，误以为丢包而进行重发，此时接收方可以给发送方回复一个包含接收序号的 SACK，表示这之前的序号都已经收到了，发送了重复数据。这种方式称为 Duplicate SACK，又称 D-SACK，主要就使用了 SACK 来告诉发送方有哪些数据被重复接收了。</p>\n<p>D-SACK 的好处：</p>\n<ul>\n<li>可以让发送方知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了</li>\n<li>可以知道是不是发送方的数据包被网络延迟了</li>\n<li>可以知道网络中是不是把发送方的数据包给复制了</li>\n</ul>\n<div><p>需要操作系统支持</p>\n<p>在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。</p>\n</div>\n",
      "image": "https://i.loli.net/2021/08/01/j2vNckRoiV6EmW4.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧤 拥塞控制",
      "url": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-control/",
      "id": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-control/",
      "content_html": "<h2 id=\"已经有了流量控制-为什么还需要拥塞控制\"> 已经有了流量控制，为什么还需要拥塞控制？</h2>\n<p>流量控制是避免发送方的数据填满接收方的缓存，但是并不知道网络的中发生了什么。有可能会因为其他主机之间的通信使得网络拥堵。</p>\n<p>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。所以当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量，即拥塞控制机制，控制的目的是避免发送方的数据填满整个网络。</p>\n<p>为了在发送方调节所要发送数据的量，需要引入拥塞窗口的概念。</p>\n<h2 id=\"什么是拥塞窗口\"> 什么是拥塞窗口？</h2>\n<p>拥塞窗口 cwnd 是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是 <code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗口和接收窗口中的最小值。</p>\n<p>拥塞窗口 cwnd 变化的规则：</p>\n<ul>\n<li>只要网络中没有出现拥塞，cwnd 就会增大</li>\n<li>如果网络中出现了拥塞，cwnd 就减少</li>\n</ul>\n<h2 id=\"怎么判断是否出现了拥塞\"> 怎么判断是否出现了拥塞？</h2>\n<p>只要发送方没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。</p>\n<h2 id=\"tcp-拥塞控制机制有哪几种\"> TCP 拥塞控制机制有哪几种？</h2>\n<ul>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>拥塞发生</li>\n<li>快速恢复</li>\n</ul>\n<h2 id=\"介绍一下慢启动机制\"> 介绍一下慢启动机制？</h2>\n<p>TCP 在刚建立连接完成后，首先有一个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，不要一上来就发大量的数据。</p>\n<p>对于慢启动机制，记住一个规则：发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/RmCbFT1xfqMiAU8.png\" alt=\"慢启动.png\" /></p>\n</div>\n<h2 id=\"慢启动机制的拥塞窗口难道会无限增长\"> 慢启动机制的拥塞窗口难道会无限增长？</h2>\n<p>拥塞窗口不会无限增加，有一个叫慢启动门限 ssthresh （slow start threshold）的状态变量：</p>\n<ul>\n<li>当 cwnd &lt; ssthresh 时，使用慢启动算法</li>\n<li>当 cwnd &gt; ssthresh 时，就会使用拥塞避免算法</li>\n<li>相等时，使用哪个都可以</li>\n</ul>\n<h2 id=\"介绍一下拥塞避免机制\"> 介绍一下拥塞避免机制？</h2>\n<p>当拥塞窗口 cwnd 超过慢启动门限 ssthresh 后就会进入拥塞避免算法。一般来说 ssthresh 的大小是 65535 字节。当进入拥塞避免算法后，它的规则是：每收到一个 ACK 时，cwnd 增加 1/cwnd。</p>\n<p>比如当前的慢启动门限是 8，每个 ACK 都会使拥塞窗口增加 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.190108em;vertical-align:-0.345em;\"></span><span><span></span><span><span><span><span style=\"height:0.845108em;\"><span style=\"top:-2.6550000000000002em;\"><span style=\"height:3em;\"></span><span><span><span>8</span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span style=\"height:3em;\"></span><span><span><span>1</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.345em;\"><span></span></span></span></span></span><span></span></span></span></span></span>，所以这种机制会使拥塞窗口的增长趋势变为线性增长。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/A82vHapIMZ9gTtd.png\" alt=\"拥塞避免.png\" /></p>\n</div>\n<p>就一直按照这么趋势增长后，网络就会慢慢进入拥塞的状况，可能就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p>\n<p>当触发了重传机制，也就进入了拥塞发生算法。</p>\n<h2 id=\"介绍一下拥塞发生机制\"> 介绍一下拥塞发生机制？</h2>\n<p>当发生拥塞时，会触发数据重传，重传机制主要有：</p>\n<ul>\n<li>超时重传机制</li>\n<li>快速重传机制</li>\n</ul>\n<p>对于这两种不同的重传机制，拥塞发生机制的处理方式也不一样。</p>\n<h2 id=\"介绍一下超时重传机制的拥塞发生机制\"> 介绍一下超时重传机制的拥塞发生机制？</h2>\n<p>当发生了超时重传时，ssthresh 和 cwnd 的值会发生变化：</p>\n<ul>\n<li>ssthresh 会设为 cwnd/2</li>\n<li>cwnd 会重置为 1</li>\n</ul>\n<p>由于 cwnd 被重置为 1，所以会以慢启动方式重新开始。所以这种方式非常激进，反应也很强烈，会造成网络卡顿。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/PsFLbC17al34Nd5.png\" alt=\"超时重传拥塞发生.png\" /></p>\n</div>\n<h2 id=\"介绍一下快速重传机制的拥塞发生机制\"> 介绍一下快速重传机制的拥塞发生机制？</h2>\n<p>快速重传机制是：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分包没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下，同时进入快速恢复算法：</p>\n<ul>\n<li>cwnd = cwnd/2 ，也就是设置为原来的一半</li>\n<li>ssthresh = cwnd</li>\n</ul>\n<h2 id=\"介绍一下快速恢复机制\"> 介绍一下快速恢复机制？</h2>\n<p>快速恢复算法认为，既然还能收到 3 个重复 ACK 说明网络也不是那么坏，所以没有必要像超时重传一样反应的那么激烈。此时 ssthresh 和 cwnd 变化如下：</p>\n<ul>\n<li>cwnd = cwnd/2 ，也就是设置为原来的一半</li>\n<li>ssthresh = cwnd</li>\n</ul>\n<p>快速恢复机制的操作如下：</p>\n<ul>\n<li>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）</li>\n<li>重传丢失的数据包</li>\n<li>如果再收到重复的 ACK，那么 cwnd 增加 1</li>\n<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从重复 ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态</li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/u7NqgSlxc91Pbyn.png\" alt=\"快速恢复.png\" /></p>\n</div>\n<h2 id=\"总结\"> 总结</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/zQwsiRLWn9r7ZgH.png\" alt=\"拥塞控制总结.png\" /></p>\n</div>\n",
      "image": "https://i.loli.net/2021/08/01/RmCbFT1xfqMiAU8.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👟 滑动窗口",
      "url": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-window/",
      "id": "https://blog.lixiangyu.xyz/interview/network/tcp/tcp-window/",
      "content_html": "<h2 id=\"什么是滑动窗口\"> 什么是滑动窗口？</h2>\n<p>TCP 是每发送一个数据，都要进行一次确认应答，当上一个数据包返回了应答，再发送下一个。所以一个显而易见的缺点是：数据包的往返时间越长，通信的效率就越低。</p>\n<p>为了解决这个问题，TCP 引入了窗口的概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>\n<p>假设窗口大小为 3 个 TCP 段，那么发送方就可以连续发送 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过下一个确认应答进行确认。这个模式就叫累计确认或者累计应答。如下图：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/pQjCfX4LJiUlsqy.png\" alt=\"tcp滑动窗口.png\" /></p>\n</div>\n<h2 id=\"窗口大小由哪一方决定\"> 窗口大小由哪一方决定？</h2>\n<p>TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，通常窗口的大小是由接收方的窗口大小来决定的，发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>\n<h2 id=\"接收窗口和发送窗口的大小是相等的吗\"> 接收窗口和发送窗口的大小是相等的吗？</h2>\n<p>并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Window 字段来告诉发送方的，这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。</p>\n<h2 id=\"tcp-是如何进行流量控制的\"> TCP 是如何进行流量控制的？</h2>\n<p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP 提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>\n<p>通过限制发送窗口的大小可以起到限制发送方流量的作用，如果窗口大小为 0 时，就会阻止发送方给接收方传递数据。</p>\n<h2 id=\"介绍一下滑动窗口的窗口关闭-tcp-是如何解决潜在的死锁问题的\"> 介绍一下滑动窗口的窗口关闭，TCP 是如何解决潜在的死锁问题的？</h2>\n<p>通过上一点可以知道，通过限制发送窗口的大小可以起到限制发送方流量的作用，如果窗口大小为 0 时，就会阻止发送方给接收方传递数据。如果处于窗口关闭状态并且接收方处理完数据后，会向发送方发送一个窗口非 0 的 ACK 报文，如果这个报文丢失了，那么发送方、接收方就会一直等待，形成死锁。</p>\n<p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在收到这个探测报文时，会给出自己现在的接收窗口大小。</p>\n<ul>\n<li>如果接收窗口仍然是 0，那么接收方会重新启动持续定时器</li>\n<li>如果接收窗口不是 0，那么就会打破死锁，正常传输数据</li>\n</ul>\n<div><p>窗口探测次数</p>\n<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。</p>\n</div>\n<h2 id=\"糊涂窗口综合症\"> 糊涂窗口综合症</h2>\n<p>如果发送端应用进程产生数据很慢或接收端应用进程处理接收缓冲区数据很慢，就会使应用进程间传送的报文段很小，特别是有效载荷很小。 极端情况下，有效载荷可能只有 1 个字节，传输开销有 40 字节(20 字节的 IP 头 + 20 字节的 TCP 头) 。</p>\n<p>只有在下面两种情况任意一种/全部成立时，才会发生糊涂窗口综合症的情况：</p>\n<ul>\n<li>发送方可以发送小数据</li>\n<li>接收方可以通告一个小窗口</li>\n</ul>\n<p>解决方案：</p>\n<ul>\n<li>发送方避免发送小数据</li>\n</ul>\n<p>使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据，\n只要没满足上面条件中的一条，发送方就会一直囤积数据，直到满足上面的发送条件。：</p>\n<ul>\n<li>\n<p>窗口大小 &gt;= MSS 或者数据大小 &gt;= MSS</p>\n</li>\n<li>\n<p>收到之前发送数据的 ack 回包\nNagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如 telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法（通过在 Socket 中设置 TCP_NODELAY 选项来关闭这个算法）。</p>\n</li>\n<li>\n<p>接收方避免通告小窗口</p>\n</li>\n</ul>\n<p>当窗口大小小于 min(MSS，缓存空间/2 ) 时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 &gt;= MSS 或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。</p>\n",
      "image": "https://i.loli.net/2021/08/01/pQjCfX4LJiUlsqy.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧛‍♂️ I/O",
      "url": "https://blog.lixiangyu.xyz/interview/os/io/",
      "id": "https://blog.lixiangyu.xyz/interview/os/io/",
      "content_html": "<h2 id=\"i-o-多路复用\"> I/O 多路复用<i>Not supported content</i></h2>\n<h3 id=\"socket-模型的演进\"> Socket 模型的演进？</h3>\n<p>想要在不同的主机之间发送信息需要使用 Socket，一个最基本的模型如下图所示：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/YnOwgEstVAXGMrN.png\" alt=\"socket模型.png\" /></p>\n</div>\n<p>但是这个模型只提供了一对一的服务，因为它使用的是阻塞 I/O，当服务端在还没处理完一个客户端的网络 I/O 时，或者读写操作发生阻塞时，其他客户端是无法与服务端连接的。为了使服务端能够对多个客户端提供服务，需要对上述模型进行改造，一种最简单的思路是：每有一个请求就创建一个线程为它提供服务。这种用多个进程来应付多个客户端的方式，在客户端数量比较少的时候还是可行的，但是当客户端数量很大，比如一万、十万时，肯定是扛不住的，因为每产生一个进程，必会占据一定的系统资源，除此之外还需要考虑进程间上下文切换的性能损耗。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/yhkdLPsqU8tb6nM.png\" alt=\"socket模型1.png\" /></p>\n</div>\n<p>为了解决这个问题，可以引入线程池，通过使用线程池来避免线程的频繁创建和销毁。所谓的线程池，就是提前创建若干个线程，当有新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出已连接的 Socket 进程进行处理。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/CHlZTdQpyxcSJrz.png\" alt=\"socket模型2.png\" /></p>\n</div>\n<p>上述的方案都可以解决，但都不是最好的方案。真正的解决方案是 I/O 多路复用。</p>\n<h3 id=\"什么是-i-o-多路复用\"> 什么是 I/O 多路复用？</h3>\n<p>I/O 多路复用是指使用一个进程来维护多个 Socket，一个进程虽然在任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，也就是多路复用，这种思想很类似一个 CPU 并发多个进程。</p>\n<p>I/O 多路复用主要涉及三个系统调用：select、poll、epoll。前两个基本相同，主要使用的是最后一个。</p>\n<h3 id=\"什么是-select-和-poll\"> 什么是 select 和 poll？</h3>\n<p>select 实现多路复用的方式是将已连接的 Socket 都放到一个文件描述符集合中，然后调用 select 函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生。检查的方式很粗暴，就是遍历，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方式找到可读或可写的 Socket，再对其进行处理。</p>\n<p>select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 进行限制， 默认最大值为 1024，只能监听 0~1023 个文件描述符。</p>\n<p>poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。</p>\n<p>但是 poll 和 select 并没有太大的本质区别，都是使用线性结构来存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>n</span><span>)</span></span></span></span>，另外还需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发量的增长，性能的损耗会呈指数级增长。</p>\n<h3 id=\"什么是-epoll\"> 什么是 epoll？</h3>\n<p>epoll 在两个方面进行了改造，很好解决了 select/poll 的问题。</p>\n<h4 id=\"怎么保存所有待检测的文件描述字\"> 怎么保存所有待检测的文件描述字？</h4>\n<p>epoll 在内核里使用红黑树来跟踪进程所有待检测的文件描述字，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里。红黑树是个高效的数据结构，增删查的时间复杂度是 $$O(\\log N)$$，避免了像 select/poll 操作一样每次都传入整个 Socket 集合，减少了内核和用户空间大量的数据拷贝和内存分配。</p>\n<h4 id=\"怎么知道存在-socket-需要处理\"> 怎么知道存在 Socket 需要处理？</h4>\n<p>epoll 使用事件驱动的机制，在内核里维护了一个链表来记录就绪事件，当某个 Socket 有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用 epoll_wait() 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 Socket 集合，大大提高了检测的效率。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/JcjvrEgOleKW1Ps.png\" alt=\"epoll.png\" /></p>\n</div>\n<h3 id=\"epoll-的两种触发模式\"> epoll 的两种触发模式？</h3>\n<ul>\n<li>\n<p>边缘触发模式：当被监控的 Socket 描述符上有可读事件发生时，服务器端只会从 epoll_wait 中苏醒一次，因此程序要保证一次性将内核缓冲区的数据读取完，通常和非阻塞 I/O 搭配使用</p>\n</li>\n<li>\n<p>水平触发模式：当被监控的 Socket 上有可读事件发生时，服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</p>\n</li>\n<li>\n<p>对于 select 和 poll，它们只提供了水平触发模式，epoll 默认也是水平触发方式，但也可以配置为边缘触发模式。</p>\n</li>\n</ul>\n<h2 id=\"reactor-模型\"> Reactor 模型</h2>\n<h3 id=\"什么是-reactor\"> 什么是 Reactor？</h3>\n<p>Reactor 指的是对事件的反应，也就是说来了一个事件，Reactor 就有相对应的响应。事实上，Reactor 模式也叫 Dispatcher 模式，即收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程。</p>\n<p>Reactor 模式主要有以下四种实现方案：</p>\n<ul>\n<li>单 Reactor 单进程 / 线程</li>\n<li>单 Reactor 多进程 / 线程</li>\n<li>多 Reactor 单进程 / 线程</li>\n<li>多 Reactor 多进程 / 线程</li>\n</ul>\n<p>其中，多 Reactor 单进程 / 线程的实现方案相比单 Reactor 单进程 / 线程的方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。主要介绍一下另外三种方案。</p>\n<h3 id=\"介绍一下单-reactor-单进程-线程模型\"> 介绍一下单 Reactor 单进程/线程模型？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/3ZNEiHUuoLj7gnK.png\" alt=\"reactor1.png\" /></p>\n</div>\n<p>这种方案存在两个缺点：</p>\n<ul>\n<li>因为只有一个进程，所以无法充分利用 多核 CPU 的性能</li>\n<li>Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，如果业务处理耗时比较长，那么就会造成响应的延迟</li>\n</ul>\n<p>因此，这种方案更适合于业务处理非常快速的场景。比如 Redis（Redis 的瓶颈不在 CPU，而是内存和网络 I/O）。</p>\n<h3 id=\"介绍一下单-reactor-多进程-线程模型\"> 介绍一下单 Reactor 多进程/线程模型？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/A1cW5D4xuwqJoft.png\" alt=\"reactor2.png\" /></p>\n</div>\n<p>单 Reator 多线程的方案优势在于能够充分利用多核 CPU 的性能，既然引入多线程，那么自然就带来了多线程竞争资源的问题。同时因为只有一个 Reactor 对象承担所有事件的监听和响应，在面对瞬间高并发的场景时，容易成为性能瓶颈。</p>\n<h3 id=\"介绍一下多-reactor-多进程-线程模型\"> 介绍一下多 Reactor 多进程/线程模型？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/7rWqT5QtOoCKNSZ.png\" alt=\"reactor3.png\" /></p>\n</div>\n<p>多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：</p>\n<ul>\n<li>主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理</li>\n<li>主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无需返回数据，直接就可以在子线程将处理结果发送给客户端</li>\n</ul>\n<p>使用这种方案的包括 Netty，Memcached，Nginx。</p>\n<h2 id=\"proactor\"> Proactor</h2>\n<h3 id=\"什么是同步-异步-阻塞-非阻塞\"> 什么是同步/异步，阻塞/非阻塞？</h3>\n<p>阻塞是指当用户程序执行 read 的时候，线程会被阻塞，一直等到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区中，即拷贝过程完成时，read 才会返回。所以阻塞等待的是内核数据准备好和数据从内核态拷贝到用户态这两个过程。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/kTFSnVzM8Av3wY9.png\" alt=\"阻塞io.png\" /></p>\n</div>\n<p>非阻塞 I/O 的 read 请求在数据未准备好的情况下会立即返回，并会继续往下执行，此时应用程序不断轮询内核，直到数据准备好，read 调用才可以获取到结果。但是最后一次 read 调用，获取数据的过程，是一个同步的过程。这里的同步指的是内核态的数据拷贝到用户程序的缓存区这个过程。过程如下图：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/9jSit8LTUMm57PA.png\" alt=\"非阻塞io.png\" /></p>\n</div>\n<p>异步 I/O 指的是内核数据准备好和数据从内核态拷贝到用户态这两个过程都不用等待。当一切处理完成后，由操作系统通知应用程序过来处理。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/y3VUMcO29xsPS5C.png\" alt=\"异步io.png\" /></p>\n</div>\n<h3 id=\"什么是-proactor\"> 什么是 Proactor？</h3>\n<p>Reactor 是非阻塞同步网络模式，而 Proactor 是异步网络模式。流程图如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/8RxVgNHO5qJnXtp.png\" alt=\"proactor.png\" /></p>\n</div>\n<p>可惜的是，在 Linux 下的异步 I/O 是不完善的，aio 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 Socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。</p>\n<p>而 Windows 里实现了一套完整的支持 Socket 的异步编程接口，这套接口就是 IOCP，是由操作系统级别实现的异步 I/O，真正意义上实现了异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。</p>\n<h3 id=\"和-reactor-的对比\"> 和 Reactor 的对比？</h3>\n<p>Reactor 可以理解为：来了事件操作系统通知应用进程，让应用进程来处理；而 Proactor 可以理解为：来了事件操作系统来处理，处理完再通知应用进程。这里的事件可以指：新连接、有数据可读、有数据可写的这些 I/O 事件。这里的处理指从驱动读取到内核以及从内核读取到用户空间。</p>\n",
      "image": "https://i.loli.net/2021/08/01/YnOwgEstVAXGMrN.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧚 CPU 缓存一致性",
      "url": "https://blog.lixiangyu.xyz/interview/os/cpu-cache/",
      "id": "https://blog.lixiangyu.xyz/interview/os/cpu-cache/",
      "content_html": "<h2 id=\"cpu-缓存的结构\"> CPU 缓存的结构</h2>\n<h3 id=\"cpu-缓存的结构是怎么样的\"> CPU 缓存的结构是怎么样的？</h3>\n<p>CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度越快，但是存储容量相对就会越小。在多核心的 CPU 中，每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/DoZ3wJXFTiG2LQe.png\" alt=\"cpu缓存结构.png\" /></p>\n</div>\n<h2 id=\"cpu-缓存的数据写入\"> CPU 缓存的数据写入</h2>\n<h3 id=\"什么是写直达策略\"> 什么是写直达策略？</h3>\n<p>写直达策略会把数据同时写入缓存和内存，这种方法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响（相比缓存的读写速度而言内存的读写速度是相当慢了）。</p>\n<h3 id=\"什么是写回策略\"> 什么是写回策略？</h3>\n<p>因为写直达每次都有写操作将数据写回到内存，而影响性能，为了减少数据写回内存的频率，就出现了写回（Write Back）策略。在写回策略中，当发生写操作时，新的数据仅仅被写入到缓存中，只有当修改过的缓存要被替换时才会将数据写到内存中，减少了数据写回内存的频率，这样可以提高系统的性能。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/T9PcnLg3krKCEwQ.png\" alt=\"写回策略.jpg\" /></p>\n</div>\n<p>可以发现写回策略在把数据写入到缓存的时候，只有在缓存不命中同时数据对应的缓存中的缓存块为脏的情况下，才会将数据写到内存中；在缓存命中的情况下，只需把该数据对应的缓存块标记为脏，不需要写到内存里。\n这样的好处是：如果大量的操作都能够命中缓存，那么在大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。</p>\n<h2 id=\"缓存一致性问题\"> 缓存一致性问题</h2>\n<h3 id=\"什么是缓存一致性问题\"> 什么是缓存一致性问题？</h3>\n<p>由于 L1/L2 Cache 是多个核心各自独有的，那么就可能引发多核心的缓存一致性（Cache Coherence）问题，即多核心下不同缓存内的数据需要保持一致。下面是一个含有两核心的 CPU，假设 A 号核心和 B 号核心同时运行两个线程，都操作内存中共同的变量 i（初始值为 0 ），写策略为写回策略。</p>\n<p>如果 A 号核心执行了 i++ 语句，会把值为 1 的执行结果写入到 L1/L2 Cache 中，然后把 L1/L2 Cache 中对应的 Block 标记为脏的，这个时候数据是没有被同步到内存中的。如果这时 B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0，会导致执行结果的错误。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/HMdKVBuO7CqGD6n.png\" alt=\"缓存一致性问题举例.png\" /></p>\n</div>\n<h3 id=\"如何保证数据一致\"> 如何保证数据一致？</h3>\n<ul>\n<li>写传播（Wreite Propagation）：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的缓存</li>\n<li>事务的串形化（Transaction Serialization）：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的</li>\n</ul>\n<h3 id=\"什么是总线嗅探机制\"> 什么是总线嗅探机制？</h3>\n<p>一种比较简单的实现写传播原则的方式是使用总线嗅探，CPU 需要每时每刻监听总线上的一切活动，只要有某个核心修改了值就会通知其他所有的核心进行更新。不管别的核心的 Cache 是否缓存相同的数据，都会发出一个广播事件，这无疑会加重总线的负载。</p>\n<p>另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。于是，有一个协议基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。</p>\n<h3 id=\"什么是-mesi-协议\"> 什么是 MESI 协议？</h3>\n<p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：</p>\n<h4 id=\"modified\"> Modified</h4>\n<p>已修改状态，就是前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。</p>\n<h4 id=\"exclusive\"> Exclusive</h4>\n<p>独占状态，此时数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。同时这个状态代表这个缓存中的数据是干净的。如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候独占状态下的数据就会变成共享状态。</p>\n<h4 id=\"shared\"> Shared</h4>\n<p>共享状态，代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当需要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为无效状态，然后再更新当前 Cache 里面的数据。</p>\n<h4 id=\"invalidated\"> Invalidated</h4>\n<p>已失效状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。</p>\n<p>MESI 状态转移图：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Yf2Imakg91WQ84L.png\" alt=\"MESI.png\" /></p>\n</div>\n",
      "image": "https://i.loli.net/2021/08/01/DoZ3wJXFTiG2LQe.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧟 锁",
      "url": "https://blog.lixiangyu.xyz/interview/os/lock/",
      "id": "https://blog.lixiangyu.xyz/interview/os/lock/",
      "content_html": "<h2 id=\"互斥锁与自旋锁\"> 互斥锁与自旋锁</h2>\n<h3 id=\"什么是互斥锁\"> 什么是互斥锁？</h3>\n<p>互斥锁是一种独占锁，比如线程 A 获取了互斥锁，那么只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，那么线程 B 加锁的代码就会被阻塞。互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为睡眠状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，就可以继续执行。</p>\n<p>互斥锁的开销主要在于上下文切换（时间大概在几十纳秒到几微秒之间），如果锁住的代码执行时间比较短，那可能上下文切换的时间都比锁住的代码执行时间还要长。所以，如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁。</p>\n<h3 id=\"什么是自旋锁\"> 什么是自旋锁？</h3>\n<p>自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在用户态完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。自旋锁在锁不可用时会一直自旋，一直占据 CPU，直到锁可用。比较适合于异步、协程等在用户态切换请求的编程方式。但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成正比的关系的。</p>\n<h2 id=\"读写锁\"> 读写锁</h2>\n<h3 id=\"什么是读写锁\"> 什么是读写锁？</h3>\n<p>读写锁由读锁和写锁两部分构成，如果只读取共享资源用读锁加锁，如果要修改共享资源则用写锁加锁：</p>\n<ul>\n<li>当写锁没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为读锁是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据</li>\n<li>一旦写锁被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞</li>\n</ul>\n<p>所以读写锁在读多写少的场景，能发挥出比较大的优势。根据使用场景的不同，读写锁可细分为读优先锁和写优先锁：</p>\n<ul>\n<li>读优先锁：优先进行读操作，写操作会被阻塞，如果一直在读，写操作会一直无法运行</li>\n<li>写优先锁：优先进行写操作，读操作会被阻塞，如果一直在写，读操作会一直无法运行</li>\n</ul>\n<p>为了解决这个问题，可以实现一个公平读写锁：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁，这样读线程仍然可以并发，也不会出现饥饿的现象。</p>\n<h2 id=\"乐观锁与悲观锁\"> 乐观锁与悲观锁</h2>\n<h3 id=\"什么是悲观锁\"> 什么是悲观锁？</h3>\n<p>悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前必须要上锁。比如：互斥锁、自旋锁、读写锁。</p>\n<h3 id=\"什么是悲观锁-2\"> 什么是悲观锁？</h3>\n<p>乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。比如：CAS。</p>\n<h2 id=\"死锁\"> 死锁</h2>\n<h3 id=\"什么是死锁\"> 什么是死锁？</h3>\n<p>当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，如果这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁。</p>\n<p>只有同时满足以下四个条件死锁才会发生：</p>\n<ul>\n<li>互斥条件：多个线程不能同时使用同一个资源</li>\n<li>持有并等待条件：当线程 A 已经持有了资源一，又想申请资源 二，而资源二已经被线程 C 持有了，那么线程 A 就会处于等待状态，但是线程 A 在等待资源二的同时并不会释放自己已经持有的资源二</li>\n<li>不可剥夺条件：当线程已经持有了资源，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取</li>\n<li>环路等待条件：在死锁发生的时候，两个线程获取资源的顺序构成了环形链。比如线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧙‍♂️ 内存管理",
      "url": "https://blog.lixiangyu.xyz/interview/os/memory/",
      "id": "https://blog.lixiangyu.xyz/interview/os/memory/",
      "content_html": "<h2 id=\"虚拟内存\"> 虚拟内存</h2>\n<h3 id=\"什么是虚拟内存\"> 什么是虚拟内存？</h3>\n<p>虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上它通常是被分隔成多个物理内存碎片，操作系统会提供一种机制负责将不同进程的虚拟地址和不同内存的物理地址映射起来。</p>\n<p>操作系统会根据进程持有的虚拟地址，通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Xus2I9oerAECYZj.png\" alt=\"虚拟内存.png\" /></p>\n</div>\n<h3 id=\"操作系统是如何维护虚拟地址和物理地址之间的关系的\"> 操作系统是如何维护虚拟地址和物理地址之间的关系的？</h3>\n<p>主要有两种方式：</p>\n<ul>\n<li>内存分段</li>\n<li>内存分页</li>\n</ul>\n<h2 id=\"内存分段\"> 内存分段</h2>\n<h3 id=\"什么是内存分段\"> 什么是内存分段？</h3>\n<p>程序是由若干个逻辑分段组成的，如：代码分段、数据分段、栈段、堆段等。不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</p>\n<h3 id=\"在分段机制下-如何将虚拟地址和物理地址进行映射\"> 在分段机制下，如何将虚拟地址和物理地址进行映射？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/MOHuUG7hKEIYbN5.png\" alt=\"分段.png\" /></p>\n</div>\n<p>分段机制下的虚拟地址由两部分组成：</p>\n<ul>\n<li>段选择因子：保存在段寄存器中，最最重要的是段号，用作段表的索引，段表里面保存的是这个段的基地址、段的界限和特权等级等</li>\n<li>段内偏移量：它应该位于 0 和段界限之间，如果段内偏移量是合法的，将段基地址加上段内偏移量就可以得到物理内存地址</li>\n</ul>\n<h3 id=\"分段机制会引发什么问题\"> 分段机制会引发什么问题？</h3>\n<h4 id=\"产生内存碎片\"> 产生内存碎片</h4>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/HQCPoBkRmz4hTfs.png\" alt=\"分段的问题.png\" /></p>\n</div>\n<h4 id=\"内存交换效率低\"> 内存交换效率低</h4>\n<p>由于分段机制会产生内存碎片，所以可以将上图中空闲的两部分写入硬盘中，再从磁盘重新读入内存。只不过读入的时候需要把它们连续放置，不能再像这样产生碎片。这种操作是很常见的，比如 Linux 系统的交换（Swap）空间，专门分出一部分硬盘空间，用于内存和硬盘的空间交换。由于段式机制的内存碎片会频繁的产生同时硬盘的访问速度要远远慢于内存，因此内存交换效率比较低。</p>\n<h2 id=\"内存分页\"> 内存分页</h2>\n<h3 id=\"什么是内存分页\"> 什么是内存分页？</h3>\n<p>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题。要解决这些问题，就要想出一个能少出现内存碎片的办法。另外当需要进行内存交换的时候，需要让交换写入或者从磁盘装载的数据更少一点。这个办法，也就是内存分页（Paging）。</p>\n<p>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小的空间。这样一个连续并且尺寸固定的内存空间，叫叫做页（Page）。在 Linux 下，每一页的大小为 4KB。虚拟地址与物理地址之间通过页表来映射，如下图：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/pQ5h4vAef6LZmcj.png\" alt=\"分页.png\" /></p>\n</div>\n<p>页表实际上存储在 CPU 的内存管理单元 （MMU） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>\n<h3 id=\"分页机制下-如何将虚拟地址和物理地址进行映射\"> 分页机制下，如何将虚拟地址和物理地址进行映射？</h3>\n<p>在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，见下图：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/S71vjZulUghcRE8.png\" alt=\"分页地址映射.png\" /></p>\n</div>\n<h3 id=\"一级页表存在什么问题\"> 一级页表存在什么问题？</h3>\n<p>在 32 位环境下，虚拟地址空间共有 4GB，每个页的大小为 4KB，那么页的总数量大约为 1MB 个。每个页表项需要 4 个字节，所以这 4GB 的虚拟空间需要 4MB 的内存来存储页表。由于每个进程都有自己的虚拟地址空间，假设有 100 个进程，就需要 400MB 的空间存储页表，这个开销是相当大的。为了解决这个问题，需要引入多级页表。</p>\n<h3 id=\"什么是多级页表-地址如何映射\"> 什么是多级页表，地址如何映射？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/emv1faq7HtSrwpJ.png\" alt=\"多级页表.png\" /></p>\n</div>\n<p>与一级页表相比，一级页号对应的不再是物理页号而是二级页号，二级页号对应的才是物理页号。如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了（一级页表 4KB + 二级页表 4MB），但是往往不需要为一个进程分配那么多内存。</p>\n<p>根据局部性原理，对于大多数程序来说，真正使用到的空间远未达到 4GB，因此会存在部分对应的页表项都是空的，根本没有分配（可以在需要时才创建二级页表），对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p>\n<p>假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB。</p>\n<h3 id=\"什么是-tlb\"> 什么是 TLB？</h3>\n<p>多级页表虽然解决了空间上的问题，但是在虚拟地址到物理地址的转换上多了几道工序，这显然就降低了地址转换的速度，也就是带来了时间上的开销。程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p>\n<p>利用这一特性，可以把最常访问的几个页表项存储到访问速度更快的硬件，于是在 CPU 芯片中加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，它通常被称为页表缓存、转址旁路缓存、快表等。</p>\n<p>有了 TLB 后，CPU 在寻址时会先查 TLB，如果没找到，才会继续查常规的页表。TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/9jBzKGfMVCIsu3k.png\" alt=\"TLB.png\" /></p>\n</div>\n<h2 id=\"段页式管理\"> 段页式管理</h2>\n<h3 id=\"什么是段页式内存管理机制\"> 什么是段页式内存管理机制？</h3>\n<p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为段页式内存管理。</p>\n<ul>\n<li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制</li>\n<li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页</li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Dbql5C7xWXHa41V.png\" alt=\"段页式.png\" /></p>\n</div>\n",
      "image": "https://i.loli.net/2021/08/01/Xus2I9oerAECYZj.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧝‍♂️ 进程与线程",
      "url": "https://blog.lixiangyu.xyz/interview/os/process-thread/",
      "id": "https://blog.lixiangyu.xyz/interview/os/process-thread/",
      "content_html": "<h2 id=\"进程\"> 进程</h2>\n<h3 id=\"并发和并行的区别\"> 并发和并行的区别？</h3>\n<ul>\n<li>并发：能够处理多个任务，但不一定同时</li>\n<li>并行：能够处理多个任务，并且能够同时执行（只要速度足够快，看起来就像是在同时执行）</li>\n</ul>\n<h3 id=\"进程有哪几个状态\"> 进程有哪几个状态？</h3>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Sdlb9XfRaGqYLUm.png\" alt=\"进程状态1.png\" /></p>\n</div>\n<p>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，非常浪费空间。所以在使用虚拟内存管理的操作系统中，通常会把处于阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候再从硬盘换入到物理内存。通过挂起状态来描述这种行为。</p>\n<p>挂起状态又分为：</p>\n<ul>\n<li>阻塞挂起：进程在外存（硬盘）并等待某个事件的出现</li>\n<li>就绪挂起：进程在外存（硬盘），但只要进入内存，那么立刻就会运行（比如通过 Ctrl+Z 挂起进程）</li>\n</ul>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/RPVBXA2zmdyJptn.png\" alt=\"进程状态2.png\" /></p>\n</div>\n<h3 id=\"什么是进程控制块\"> 什么是进程控制块？</h3>\n<p>进程控制块（process control block，PCB）是操作系统用来描述进程的一种数据结构。一个进程必然会对应一个 PCB，如果进程结束了，那么 PCB 也会随之消失。一个 PCB 中会包含以下信息：</p>\n<ul>\n<li>进程描述信息\n<ul>\n<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符</li>\n<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务</li>\n</ul>\n</li>\n<li>进程控制和管理信息\n<ul>\n<li>进程当前状态：如 new、ready、running、waiting 或 blocked 等</li>\n<li>进程优先级：进程抢占 CPU 时的优先级</li>\n</ul>\n</li>\n<li>资源分配清单\n<ul>\n<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息</li>\n</ul>\n</li>\n<li>CPU 相关信息\n<ul>\n<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是进程的上下文切换\"> 什么是进程的上下文切换？</h3>\n<p>进程是由内核管理和调度的，所以进程的切换只能发生在内核态。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/sVzGlWwXuTQtIJB.png\" alt=\"进程上下文切换.png\" /></p>\n</div>\n<h3 id=\"哪些情况会引发线程上下文切换\"> 哪些情况会引发线程上下文切换？</h3>\n<ul>\n<li>时间片用完</li>\n<li>所需资源（比如内存）不足</li>\n<li>调用 <code>sleep</code> 主动挂起</li>\n<li>有更高优先级的进程需要先执行</li>\n<li>发生硬件中断</li>\n</ul>\n<h2 id=\"线程\"> 线程</h2>\n<h3 id=\"什么是线程\"> 什么是线程？</h3>\n<p>线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。</p>\n<h3 id=\"线程与进程的比较\"> 线程与进程的比较？</h3>\n<p>线程与进程的区别如下：</p>\n<ul>\n<li>进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位</li>\n<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</li>\n<li>线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系</li>\n<li>线程能减少并发执行的时间和空间开销</li>\n</ul>\n<p>线程相比进程能减少开销，体现在：</p>\n<ul>\n<li>线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们</li>\n<li>线程的终止时间比进程快，因为线程释放的资源相比进程少很多</li>\n<li>同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的</li>\n<li>由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了</li>\n</ul>\n<h3 id=\"什么是线程的上下文切换\"> 什么是线程的上下文切换？</h3>\n<ul>\n<li>当两个线程不是属于同一个进程时，切换的过程就跟进程上下文切换一样</li>\n<li>当两个线程是属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</li>\n</ul>\n<h2 id=\"调度\"> 调度</h2>\n<h3 id=\"什么情况下会发生调度\"> 什么情况下会发生调度？</h3>\n<ul>\n<li>从就绪态转变为运行态</li>\n<li>从运行态转变为阻塞态</li>\n<li>从运行态转变为结束态</li>\n</ul>\n<p>以上三种情况，操作系统都需要重新选择一个进程来执行，所以需要调度。调度算法大体上分为两类：</p>\n<ul>\n<li>非抢占式调度算法：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情</li>\n<li>抢占式调度算法：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程，这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制</li>\n</ul>\n<h3 id=\"cpu-调度的基本原则\"> CPU 调度的基本原则？</h3>\n<ul>\n<li>CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率</li>\n<li>系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量</li>\n<li>周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好</li>\n<li>等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意</li>\n<li>响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准</li>\n</ul>\n<h3 id=\"有哪些调度算法\"> 有哪些调度算法？</h3>\n<h4 id=\"先来先服务算法\"> 先来先服务算法</h4>\n<p>先来先服务（First Come First Severd, FCFS）算法是指每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，这将不利于短作业。</p>\n<h4 id=\"最短作业优先调度算法\"> 最短作业优先调度算法</h4>\n<p>最短作业优先（Shortest Job First, SJF）调度算法会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。但这种算法很明显对长作业不友好。</p>\n<h4 id=\"高响应比优先调度算法\"> 高响应比优先调度算法</h4>\n<p>高响应比优先 （Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行，响应比优先级的计算公式：</p>\n<div>\n<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.68333em;vertical-align:0em;\"></span><span>优先权</span><span style=\"margin-right:0.2777777777777778em;\"></span><span>=</span><span style=\"margin-right:0.2777777777777778em;\"></span></span><span><span style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span><span></span><span><span><span><span style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span style=\"height:3em;\"></span><span><span>要求服务时间</span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span style=\"height:3em;\"></span><span><span>等待时间</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span><span>要求服务时间</span></span></span></span><span>​</span></span><span><span style=\"height:0.686em;\"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>\n</div>\n<h4 id=\"时间片轮转调度算法\"> 时间片轮转调度算法</h4>\n<p>时间片轮转（Round Robin, RR）调度算法是给每个进程分配一个时间段，称为时间片（Quantum）。</p>\n<ul>\n<li>如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程</li>\n<li>如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换</li>\n</ul>\n<h4 id=\"最高优先级调度算法\"> 最高优先级调度算法</h4>\n<p>时间片轮转算法做了个假设，即让所有的进程同等重要，大家的运行时间都一样。但是对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。</p>\n<p>进程的优先级可以分为，静态优先级或动态优先级：</p>\n<ul>\n<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化</li>\n<li>动态优先级：根据进程的动态变化调整优先级，比如进程运的行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级</li>\n</ul>\n<h4 id=\"多级反馈队列调度算法\"> 多级反馈队列调度算法</h4>\n<p>多级反馈队列（Multilevel Feedback Queue）调度算法是时间片轮转算法和最高优先级算法的综合和发展。</p>\n<ul>\n<li>多级表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短</li>\n<li>反馈表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列</li>\n</ul>\n<h2 id=\"进程间的通信方式\"> 进程间的通信方式</h2>\n<h3 id=\"为什么要进行进程间通信\"> 为什么要进行进程间通信？</h3>\n<p>程序中经常需要多个进程同时工作，这些进程需要互相通信，这就需要进程间通信。进程间的通信方式包括：</p>\n<ul>\n<li>管道</li>\n<li>消息队列</li>\n<li>共享内存</li>\n<li>信号量</li>\n<li>信号</li>\n<li>Socket</li>\n</ul>\n<h3 id=\"如何通过管道实现进程间通信\"> 如何通过管道实现进程间通信？</h3>\n<p>在 Linux 中使用符号 <code>|</code> 就是使用了管道的功能。这种方式实际上是创建了一个匿名管道，它将前一个命令的的输出作为后一个命令的输入，比如：<code>ps auxf | grep mysql</code>。</p>\n<p>还有一种方式可以创建一个命名管道，它通过 <code>mkfifo</code> 命令创建，比如：<code>mkfifo myPipeline</code>。管道这种通信方式效率低，不适合进程间频繁通信。</p>\n<h3 id=\"如何通过消息队列实现进程间通信\"> 如何通过消息队列实现进程间通信？</h3>\n<p>对于管道存在的问题，可以使用消息队列进行解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p>\n<p>但这种方式有两个问题：</p>\n<ul>\n<li>通信不及时</li>\n<li>传送的消息大小有限制</li>\n</ul>\n<p>由于进程是写入数据到内核的消息队列，所以发生从用户态到内核态的过程，读取数据同理，所以还存在状态切换的开销。</p>\n<h3 id=\"如何通过共享内存实现进程间通信\"> 如何通过共享内存实现进程间通信？</h3>\n<p>共享内存就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，不需要再传来传去，大大提高了进程间通信的速度。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/Qa3BSfYgqyCoLMj.png\" alt=\"共享内存.png\" /></p>\n</div>\n<h3 id=\"如何通过信号量实现进程间通信\"> 如何通过信号量实现进程间通信？</h3>\n<p>通过共享内存进行通信的方式会带来新的问题：如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。为了防止多进程竞争共享资源，而造成的数据错乱，需要一种保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量就实现了这样一种保护机制。</p>\n<p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：</p>\n<ul>\n<li>P 操作：这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待，如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行</li>\n<li>V 操作：这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行，如果信号量 &gt; 0，则表明当前没有阻塞中的进程</li>\n</ul>\n<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。在下面的例子中信号量被初始化为 1：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/sMUOdwgqEIDbPiN.png\" alt=\"pv操作举例.png\" /></p>\n</div>\n<h3 id=\"如何通过信号实现进程间通信\"> 如何通过信号实现进程间通信？</h3>\n<p>上面说的几种方式都是常规状态下的工作模式。对于异常情况下的工作模式，需要用信号的方式来通知进程。</p>\n<p>在 Linux 中为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义，通过 <code>kill -l</code> 命令可以查看所有的信号。</p>\n<p>在终端中，通过键盘组合键也可以发送信号：</p>\n<ul>\n<li><code>Ctrl + C</code>：产生 <code>SIGINT</code> 信号，表示终止进程</li>\n<li><code>Ctrl + Z</code>：产生 <code>SIGTSTP</code> 信号，表示挂起进程</li>\n</ul>\n<h3 id=\"如何通过-socket-实现进程间通信\"> 如何通过 Socket 实现进程间通信？</h3>\n<p>前面所说的的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。针对 TCP 协议的 Socket 编程模型：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/KDGJEiz2WpLjhcN.png\" alt=\"TCP编程模型.png\" /></p>\n</div>\n<p>针对 UDP 协议的 Socket 编程：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/08/01/wT5Y1NzIUK92Xnt.png\" alt=\"udp编程模型.png\" /></p>\n</div>\n<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。</p>\n",
      "image": "https://i.loli.net/2021/08/01/Sdlb9XfRaGqYLUm.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 操作系统 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/os/",
      "id": "https://blog.lixiangyu.xyz/interview/os/",
      "content_html": "<p>常温一下操作的知识：</p>\n<ol>\n<li><a href=\"/interview/os/memory\">内存管理</a>：操作系统是如何管理内存的</li>\n<li><a href=\"/interview/os/cpu-cache\">CPU 缓存一致性</a>：CPU 如何保证缓存一致性</li>\n<li><a href=\"/interview/os/process-thread\">进程和线程</a>：操作系统级别的进程和线程</li>\n<li><a href=\"/interview/os/lock\">锁</a>：操作系统中的锁</li>\n<li><a href=\"/interview/os/io\">I/O</a>：操作系统的 I/O</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "💂 面试知识点整理",
      "url": "https://blog.lixiangyu.xyz/interview/",
      "id": "https://blog.lixiangyu.xyz/interview/",
      "content_html": "<p>按照我自己的面试经历，对面试中可能涉及的知识点进行了整理。在知识点中某些比较重要的内容标注了“重点”，这是必须要掌握的内容，在面试中问的频率特别高。其他未标注的内容也可能会问，也要看一看。</p>\n<p>面试前建议先找一些中小厂练练手，培养一下自信。另外面试要有针对性，面试前多看一些面经，在 <a href=\"https://codetop.cc/#/home\" target=\"_blank\" rel=\"noopener noreferrer\">codetop</a> 上有针对性的复习算法题。</p>\n<ol>\n<li><a href=\"/interview/java-basic/\">Java 基础</a>：快速回顾一下 Java 基础知识点</li>\n<li><a href=\"/interview/java-basic/\">Java 容器</a>：面试必问，此部分内容要多看</li>\n<li><a href=\"/interview/java-basic/\">Java 并发</a>：面试必问，此部分内容要多看</li>\n<li><a href=\"/interview/java-basic/\">Java I/O</a>：待整理，基本不问</li>\n<li><a href=\"/interview/java-basic/\">JVM</a>：面试必问，此部分内容要多看</li>\n<li><a href=\"/interview/java-basic/\">框架使用</a>：问的较少，不建议花太多时间准备，如果有微服务相关经验建议好好准备一下微服务相关的内容</li>\n<li><a href=\"/interview/java-basic/\">MySQL</a>：面试必问，此部分内容要多看</li>\n<li><a href=\"/interview/java-basic/\">Redis</a>：相对 MySQL 而言，问的会少一些</li>\n<li><a href=\"/interview/java-basic/\">中间件</a>：问的相对较少，一般可能会在二面问问</li>\n<li><a href=\"/interview/java-basic/\">计算机网络</a>：除了百度其他的都问的比较少</li>\n<li><a href=\"/interview/java-basic/\">操作系统</a>：除了 I/O 多路复用，其他的都问的比较少</li>\n<li><a href=\"/interview/java-basic/\">设计思想</a>：主要要会写单例，可能会考手写单例</li>\n<li><a href=\"/interview/experience\">面经</a>：面经整理</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 Redis - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/redis/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/",
      "content_html": "<p>目前国内大火的非关系型数据库 Redis，最大的特点就是快，因为所有的操作都在内存里面：</p>\n<ol>\n<li><a href=\"/interview/redis/redis-basic\">Redis 基础</a>：Redis 基础知识</li>\n<li><a href=\"/interview/redis/redis-implemention\">Redis 底层实现</a>：Redis 的一些数据结构在底层是如何实现的</li>\n<li><a href=\"/interview/redis/redis-elimination\">Redis 淘汰策略</a>：对于过期的键值对，Redis 是如何处理的</li>\n<li><a href=\"/interview/redis/redis-persistence\">Redis 持久化策略</a>：Redis 如何将数据持久化</li>\n<li><a href=\"/interview/redis/redis-transcation\">Redis 事务</a>：Redis 中的事务</li>\n<li><a href=\"/interview/redis/troubleshooting\">故障处理</a>：什么情况会出现故障，怎么解决</li>\n<li><a href=\"/interview/redis/redis-cluster\">Redis 集群</a>：Redis 集群怎么设置</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙇‍♂️ Redis 基础",
      "url": "https://blog.lixiangyu.xyz/interview/redis/redis-basic/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/redis-basic/",
      "content_html": "<h2 id=\"什么是-redis\"> 什么是 Redis？</h2>\n<p>Redis 一款内存高速缓存数据库，全称为：<strong>Re</strong>mote <strong>Di</strong>ctionary <strong>S</strong>erver（远程数据服务），使用 C 语言编写。</p>\n<h2 id=\"为什么要使用-redis\"> 为什么要使用 Redis？</h2>\n<ul>\n<li>高性能：直接从缓存中获取的速度肯定是要比从数据库中获取的速度要快的，但是需要注意的是保证数据库和缓存内容的一致性</li>\n<li>高并发：一般像 MySQL 这类的数据库的 QPS（Query Per Second，服务器每秒可以执行的查询次数）大概都在 1w 左右（4 核 8g），但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）</li>\n</ul>\n<p>所以直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，那么就可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而也就提高了系统整体的并发量。</p>\n<h2 id=\"redis-提供的数据类型有哪些\"> Redis 提供的数据类型有哪些？<i>Not supported content</i></h2>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">可以存储的值</th>\n<th style=\"text-align:center\">操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">STRING</td>\n<td style=\"text-align:center\">字符串、整数或者浮点数</td>\n<td style=\"text-align:center\">对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LIST</td>\n<td style=\"text-align:center\">列表</td>\n<td style=\"text-align:center\">从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SET</td>\n<td style=\"text-align:center\">无序集合</td>\n<td style=\"text-align:center\">添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">HASH</td>\n<td style=\"text-align:center\">包含键值对的无序散列表</td>\n<td style=\"text-align:center\">添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ZSET</td>\n<td style=\"text-align:center\">有序集合</td>\n<td style=\"text-align:center\">添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"redis-的应用场景\"> Redis 的应用场景？</h2>\n<ul>\n<li>计数器</li>\n<li>缓存</li>\n<li>消息队列</li>\n<li>对话缓存</li>\n<li>分布式锁</li>\n</ul>\n<h2 id=\"redis-为什么速度快\"> Redis 为什么速度快？</h2>\n<ul>\n<li>采用多路 I/O 复用机制</li>\n<li>数据结构简单，操作节省时间</li>\n<li>运行在内存中</li>\n</ul>\n<h2 id=\"redis-是单线程的吗\"> Redis 是单线程的吗？</h2>\n<p>虽然 Redis 是单线程模型，但是实际上 Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。不过 Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理线程之外的其他线程来异步处理。</p>\n<p>整体上来说，Redis 在 6.0 版本之前主要还是单线程处理。那 Redis 6.0 之前为什么不使用多线程呢？</p>\n<ul>\n<li>单线程编程容易并且更容易维护</li>\n<li>Redis 的性能瓶颈不在 CPU，<strong>主要是内存和网络</strong></li>\n<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能</li>\n</ul>\n<p>那为什么 Redis 6.0 之后又引入了多线程呢？主要是为了提升网络 I/O 读写性能，多线程在默认情况下是关闭的，需要通过修改配置项进行开启：</p>\n<div><pre><code>io-threads-do-reads yes # 开启多线程\nio-threads 4 # 官网建议 4 核的机器设置为 2 或 3 个线程，8 核的建议设置为 6 个线程\n</code></pre>\n<div><span>1</span><br><span>2</span><br></div></div><h2 id=\"redis-的操作是原子性的吗-如何保证原子性\"> Redis 的操作是原子性的吗，如何保证原子性？</h2>\n<p>对于 Redis 来说，执行 <code>get</code>、<code>set</code> 以及 <code>eval</code>（使用 Lua 解释器执行脚本）等命令，都是一个一个的任务，这些任务都会由 Redis 的线程去负责执行，任务要么执行成功，要么执行失败。</p>\n<h2 id=\"怎么保证缓存和数据库的数据一致性\"> 怎么保证缓存和数据库的数据一致性？</h2>\n<ul>\n<li>缓存失效时间变短（不推荐，治标不治本）：让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据</li>\n<li>增加缓存更新重试机制（常用）：如果因为缓存服务当前不可用导致缓存删除失败的话，就隔一段时间进行重试。如果多次重试还是失败的话，可以把当前更新失败的 <code>key</code> 存入队列中，等缓存服务可用之后，再将缓存中对应的 <code>key</code> 删除即可</li>\n</ul>\n<h2 id=\"redis-在什么情况下会有性能问题-如何处理\"> Redis 在什么情况下会有性能问题，如何处理？</h2>\n<ul>\n<li>主服务器写内存快照，<code>save</code> 命令调度 <code>rdbSave</code> 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照</li>\n<li>主服务器 AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响主服务器重启的恢复速度</li>\n<li>主服务器调用 <code>BGREWRITEAOF</code> 重写 AOF 文件会占大量的 CPU 和内存资源，导致服务过载，出现短暂服务暂停现象</li>\n<li>Redis 主从复制也可能会有性能问题，为了主从复制的速度和连接的稳定性，从服务器和主服务器最好在同一个局域网内</li>\n</ul>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙅‍♂️ Redis 淘汰策略",
      "url": "https://blog.lixiangyu.xyz/interview/redis/redis-elimination/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/redis-elimination/",
      "content_html": "<h2 id=\"redis-的删除策略有哪些\"> Redis 的删除策略有哪些？</h2>\n<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。对于散列表这种容器，只能为整个散列表设置过期时间，而不能为键里面的某个元素设置过期时间。</p>\n<div><pre><code>127.0.0.1:6379&gt; exp key  60 # 数据在 60s 后过期\n(integer) 1\n127.0.0.1:6379&gt; setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)\nOK\n127.0.0.1:6379&gt; ttl key # 查看数据还有多久过期\n(integer) 56\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>过期命令</p>\n<p>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> （set + ex）外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间，使用 <code>persist</code> 命令可以移除一个键的过期时间。</p>\n</div>\n<p>当时间到时，Redis 将如何删除这些值呢？常用的过期数据的删除策略就两个：</p>\n<ul>\n<li>惰性删除：只会在取出 <code>key</code> 的时候才对数据进行过期检查，这样对 CPU 最友好，但是可能会造成太多过期 <code>key</code> 没有被删除</li>\n<li>定期删除：每隔一段时间抽取一批 <code>key</code> 执行删除过期 <code>key</code> 的操作，并且 Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响</li>\n</ul>\n<p>定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有优劣，所以 Redis 采用的是定期删除 + 惰性删除。但是仅仅通过给 <code>key</code> 设置过期时间还是有问题的，因为还是可能存在漏掉很多过期 <code>key</code> 的情况。这样就导致大量过期 <code>key</code> 堆积在内存里，然后就 <code>Out of memory</code> 了。这个问题的解决方案是数据淘汰机制。</p>\n<h2 id=\"有哪些更新-淘汰策略\"> 有哪些更新/淘汰策略？</h2>\n<p>在 Redis 中可以设置最大使用量，当内存使用量超出时，会根据数据淘汰策略对数据进行淘汰。Redis 有 6 种淘汰策略：</p>\n<ul>\n<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>\n<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>\n<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰</li>\n<li>allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰</li>\n<li>allkeys-random：从所有数据集中任意选择数据进行淘汰</li>\n<li>noeviction：禁止驱逐数据</li>\n</ul>\n<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 <code>key</code>，而是抽样一小部分并且从中选出被淘汰的 <code>key</code>。使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>\n<p>Redis 4.0 中引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对（最近一次被访问次数最少的数据）淘汰。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🧏‍♂️ Redis 集群",
      "url": "https://blog.lixiangyu.xyz/interview/redis/redis-cluster/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/redis-cluster/",
      "content_html": "<h2 id=\"redis-集群有哪些方式\"> Redis 集群有哪些方式？</h2>\n<h3 id=\"主从模式\"> 主从模式</h3>\n<p>只需要在配置文件加上 <code>slaveof 192.169.x.x 6379</code>，指明主服务器的 IP 和端口号就会启动主从模式，主从模式下从服务器会自动模仿主服务器的操作并写入。</p>\n<h3 id=\"哨兵模式\"> 哨兵模式</h3>\n<p>给几台哨兵服务添加不同的端口，配置主服务器的 IP 和端口，并且加上权值，使用 Redis 命令：<code>redis-server.exe redis-xx.conf --sentinel</code> 启动哨兵。配置文件：</p>\n<div><pre><code>sentinel monitor master 127.0.0.1 28380 2 # 主服务器的IP和端口，后面的数字表示有多少个哨兵认为master失效，master才真正失效\nsentinel down-after-milliseconds master 5000 # 超过这个时间认为主服务器挂了\nsentinel failover-timeout master 30000 # 投票选举超时时间\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id=\"集群模式\"> 集群模式</h3>\n<p>修改配置文件：</p>\n<div><pre><code>port 7000 # 不同节点配置不同的端口\nlogfile &quot;./redis.log&quot; # 输出的日志\ndaemonize yes # 是否以守护进程的方式启动，如果是的话除非手动kill，否则不会关闭进程\n\ncluster-enable yes # 是否启用集群\ncluster-config-file nodes-7000.conf # 指定配置文件，每个节点需要指定不同的配置文件\ncluster-node-timeout 15000 # 集群超时时间\ncluster-require-full-coverage no # 集群不完整是否依然可以提供服务\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id=\"介绍一下一致性哈希\"> 介绍一下一致性哈希？</h2>\n<p>假设 Redis 集群中有三个节点，那么数据应该保存在哪个节点通常是由 <code>key % 3</code> 计算得到的。如果希望新增一个节点，由于数量已经固定为 3，那么数据将永远不会落在第四个节点上。另外如果某个节点挂了，那么将不能写入、获取数据。所以需要通过一致性哈希算法来解决这个问题。</p>\n<p>首先容量肯定不能固定，可以将容量设置为一个很大的数，比如：<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span><span>31</span></span></span></span></span></span></span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>−</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span>。数据在存储时对它求余，然后选取离结果最近的节点进行保存。在下面的图中，四个对象（ObjectA ~ ObjectD）就根据计算得到哈希值就近选择了要保存的节点：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/96VTDlqONSGjaHp.png\" alt=\"一致性哈希.png\" /></p>\n</div>\n<p>但是在 Redis 中并没有使用这种方式，而是引入了哈希槽（slot）的概念。集群总共包含了 16384 个哈希槽，每个 <code>key</code> 通过计算后都会落在一个具体的槽位上，而这个槽位具体属于哪个存储节点则由用户自己分配。比如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。通过哈希槽这种概念很好地解决了一致性哈希的弊端。</p>\n<p>在容错性和扩展性上，哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p>\n<h2 id=\"redis-的分布式锁\"> Redis 的分布式锁？<i>Not supported content</i></h2>\n<h3 id=\"setnx\"> SETNX</h3>\n<p>使用 <code>SET</code>、<code>SETNX</code> （SETifNot eXists）等命令插入一条记录，其他客户端通过获取 <code>key</code> 来判断是否可以获取锁。为了避免死锁，需要设置超时时间。</p>\n<h4 id=\"优点\"> <strong>优点</strong></h4>\n<ul>\n<li>Redis 性能很好</li>\n<li>Redis 对命令的支持较好，实现起来比较方便</li>\n</ul>\n<h4 id=\"缺点\"> <strong>缺点</strong></h4>\n<ul>\n<li>Redis 分布式锁，需要自己不断尝试去获取锁，比较消耗性能</li>\n<li>Redis 获取锁的那个客户端如果挂了，只能等待超时时间后才能释放锁</li>\n</ul>\n<h3 id=\"redlock\"> RedLock</h3>\n<p>假设现在有 5 个 Redis 节点，通过 RedLock 途径获取锁的过程如下：</p>\n<ol>\n<li>获取当前 Unix 时间，以毫秒为单位</li>\n<li>依次尝试从 5 个实例，使用相同的 <code>key</code> 和具有唯一性的 value（例如 UUID）获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间（避免服务端已经挂了，客户端还在等待）</li>\n<li>客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间，当且仅当从大多数（<span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1.217331em;vertical-align:-0.345em;\"></span><span><span></span><span><span><span><span style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span style=\"height:3em;\"></span><span><span><span>2</span></span></span></span><span style=\"top:-3.23em;\"><span style=\"height:3em;\"></span><span style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span style=\"height:3em;\"></span><span><span><span style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span>​</span></span><span><span style=\"height:0.345em;\"><span></span></span></span></span></span><span></span></span><span style=\"margin-right:0.2222222222222222em;\"></span><span>+</span><span style=\"margin-right:0.2222222222222222em;\"></span></span><span><span style=\"height:0.64444em;vertical-align:0em;\"></span><span>1</span></span></span></span>，这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</li>\n<li>如果取到了锁，<code>key</code> 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 的时间）</li>\n<li>如果因为某些原因，获取锁失败（超时或者达不到大多数节点的要求），那么就需要在所有的 Redis 节点上进行解锁</li>\n</ol>\n",
      "image": "https://i.loli.net/2021/07/31/96VTDlqONSGjaHp.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙋‍♂️ Redis 底层实现",
      "url": "https://blog.lixiangyu.xyz/interview/redis/redis-implemention/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/redis-implemention/",
      "content_html": "<h2 id=\"redis-是如何实现字符串的\"> Redis 是如何实现字符串的？<i>Not supported content</i></h2>\n<p>SDS（Simple Dynamic String）简单动态字符串是 Redis 底层实现的一种可修改字符串。类似于 Java 中的 <code>ArrayList</code>，它采用预分配冗余空间的方式来减少内存的频繁分配。SDS 比 C 语言的字符串多了一个 <code>SDSHDR</code> 表头，里面存放 <code>free</code>（空闲长度）、<code>len</code>（已使用长度）、<code>buf</code>（真正保存的那个字符串）。源码中提供的 <code>sds</code> 类型实际上是 <code>char *</code> 的别名，它真正指向的是 buf 数组。</p>\n<p>优点：</p>\n<ul>\n<li>获取字符串长度更快：C 语言获取字符串长度需要遍历整个字符串，时间复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span style=\"margin-right:0.10903em;\">N</span><span>)</span></span></span></span>，SDS 的表头 <code>len</code> 成员存放了当前已使用长度，获取字符串长度复杂度为 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:1em;vertical-align:-0.25em;\"></span><span style=\"margin-right:0.02778em;\">O</span><span>(</span><span>1</span><span>)</span></span></span></span></li>\n<li>杜绝缓冲区溢出：C 语言字符串本身不记录自身长度和空闲空间，容易造成缓冲区溢出，SDS 表头的 <code>free</code> 成员存放了空闲空间，拼接字符串前会先通过 <code>free</code> 字段检测剩余空间是否能满足，如果空间不够就会扩容</li>\n<li>减少内存分配次数：C 语言对字符串进行增长或缩短操作，都需要重新分配内存，SDS 使用了空间预分配和惰性空间释放策略，减少了内存分配次数</li>\n<li>二进制安全：C 语言字符串遇 <code>\\0</code> 则止，会对字符串进行截断，而 SDS 判断字符串是否结尾的依据是头信息中的 <code>len</code> 属性，即使 SDS 中间保存了 <code>\\0</code> 也不影响</li>\n</ul>\n<h2 id=\"sds-的扩容机制\"> SDS 的扩容机制？<i>Not supported content</i></h2>\n<p>SDS 源码提供了 <code>sdsMakeRoomFor()</code> 函数来进行扩容，它的参数有两个，一个 <code>sds</code> 类型的字符串数组，另一个是一个数字 <code>addlen</code>。具体的流程如下：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/zYeV1apdblOAScB.png\" alt=\"sds扩容流程图.jpg\" /></p>\n</div>\n<h2 id=\"redis-的字典是如何实现的\"> Redis 的字典是如何实现的？</h2>\n<p>C 语言没有提供字典，Redis 提供了一种实现。<code>Hash</code> 类型的底层实现是字典。它根据键值对中的键计算哈希值和索引值，然后根据索引值，将包含键值对的哈希节点放到哈希数组的指定索引上。</p>\n<h3 id=\"解决哈希冲突\"> 解决哈希冲突</h3>\n<p>Redis 采用链地址法解决键冲突，每个哈希节点有一个 <code>next</code> 指针，多个哈希节点通过 <code>next</code> 指针构成一个单向链表，最新的节点总是添加到表头。</p>\n<h3 id=\"rehash\"> rehash</h3>\n<p>字典中保存两个哈希表：<code>ht[0]</code> 和 <code>ht[1]</code>，<code>ht[1]</code> 只在 <code>rehash</code> 时使用。Redis 对字典的哈希表执行 <code>rehash</code> 的步骤如下：</p>\n<ul>\n<li>为 <code>ht[1]</code> 哈希表分配空间，<code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 <span><span><i>Not supported content</i></span><span aria-hidden=\"true\"><span><span style=\"height:0.664392em;vertical-align:0em;\"></span><span><span>2</span><span><span><span><span style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span style=\"height:2.7em;\"></span><span><span>n</span></span></span></span></span></span></span></span></span></span></span></li>\n<li>将保存在 <code>ht[0]</code> 中的所有键值对 <code>rehash</code> 到 <code>ht[1]</code> 上面</li>\n<li>当 <code>ht[0]</code> 包含的所有键值对都迁移到 <code>ht[1]</code> 之后，释放 <code>ht[0]</code>，将 <code>ht[1]</code> 设置为 <code>ht[0]</code>，并为 <code>ht[1]</code> 新创建一个空白哈希表，为下一次 <code>rehash</code> 做准备</li>\n</ul>\n<div><p>渐进式 rehash</p>\n<p><code>rehash</code> 动作并不是一次性、集中式完成的，而是分多次、渐进式的完成的。如果服务器中包含很多键值对，要一次性的将这些键值对全部 <code>rehash</code> 到 <code>ht[1]</code> 的话，庞大的计算量可能导致服务器在一段时间内停止服务。</p>\n</div>\n<h2 id=\"redis-的跳跃表是如何实现的\"> Redis 的跳跃表是如何实现的？<i>Not supported content</i></h2>\n<p>跳跃表是有序集合（<code>zset</code>）的底层实现之一，它是基于多指针有序链表实现的，可以看成多个有序链表。</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/sWy4M7OYBSGvm8h.png\" alt=\"跳跃表.png\" /></p>\n</div>\n<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程：</p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/L3tyY2nzQTOZx6e.png\" alt=\"跳跃表查找.png\" /></p>\n</div>\n<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>\n<ul>\n<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性</li>\n<li>更容易实现</li>\n<li>支持无锁操作</li>\n</ul>\n<div><p>ziplist 和 skiplist</p>\n<p>默认情况下，当 <code>zset</code> 中集合的元素个数少于 128 个（对应配置项 <code>zset-max-ziplist-value</code>）并且 <code>zadd</code> 操作的 <code>member</code> 的长度小于 64 字节（对应配置项 <code>zset-max-ziplist-entries</code>），Redis 会使用 <code>ziplist</code> 来存储元素，否则使用 <code>skiplist</code> 来存储元素。</p>\n<p>修改 <code>zset-max-ziplist-value</code> 为 3，并执行以下操作查看 Redis 所使用的数据结构：</p>\n<div><pre><code>127.0.0.1:6379&gt; zadd myset 10 &quot;A&quot;\n(integer) 1\n127.0.0.1:6379&gt; object encoding myset\n&quot;ziplist&quot;\n\n// 此处省略插入数据 BB 和 CCC 的过程，它们的结果也是 ziplist\n\n127.0.0.1:6379&gt; zadd myset 10 &quot;DDDD&quot;\n127.0.0.1:6379&gt; object encoding myset\n&quot;skiplist&quot;\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></div>\n<h2 id=\"介绍一下-redis-的线程模型\"> 介绍一下 Redis 的线程模型？</h2>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/PK4j3RF1mJsIqbe.png\" alt=\"Redis线程模型.png\" /></p>\n</div>\n",
      "image": "https://i.loli.net/2021/07/31/zYeV1apdblOAScB.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🙆‍♂️ Redis 持久化策略",
      "url": "https://blog.lixiangyu.xyz/interview/redis/redis-persistence/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/redis-persistence/",
      "content_html": "<h2 id=\"redis-的持久化策略有哪些\"> Redis 的持久化策略有哪些？</h2>\n<h3 id=\"rdb-策略\"> RDB 策略</h3>\n<p>将某个时间点的所有数据都存放到硬盘上，可以将快照复制到其它服务器从而创建具有相同数据的服务器副本，但是：</p>\n<ul>\n<li>如果系统发生故障，将会丢失最后一次创建快照之后的数据</li>\n<li>如果数据量很大，保存快照的时间会很长</li>\n</ul>\n<div><p>默认启用 RDB 策略</p>\n<p>Redis 默认启用的是 RDB 策略，数据保存到 <code>./dump.rdb</code> 中。如果需要启用 AOF 策略，需要修改配置项 <code>appendonly</code> 为 <code>yes</code>，默认输出的文件是 <code>./appendonly.aof</code>。</p>\n</div>\n<div><p>RDB 策略的优缺点</p>\n<p>优点：</p>\n<ul>\n<li>存储的文件是紧凑的，备份速度比 AOF 要快</li>\n<li>方便恢复不同版本的数据，适合于容灾恢复，备份文件可以在其他服务器恢复</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>如果 Redis 因为没有正确关闭而停止工作，则在下一个 RDB 备份操作到来之前，新增的数据可能会丢失</li>\n<li>由于是通过 fork 子线程来进行备份操作，如果数据量很大的话，fork 比较耗时，可能会导致服务器卡顿</li>\n</ul>\n</div>\n<h3 id=\"aof-策略\"> AOF 策略</h3>\n<p>将写命令添加到 AOF 文件（Append Only File）的末尾。使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>\n<ul>\n<li>always：每个写命令都同步，这个选项会严重降低服务器的性能</li>\n<li>everysec：每秒同步一次，这个选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响</li>\n<li>no：让操作系统来决定何时同步，这个选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量</li>\n</ul>\n<div><p>AOF 策略的优缺点</p>\n<p>优点：</p>\n<ul>\n<li>AOF 是一个日志追加文件，即使因为没有正确关闭而停止工作造成 AOF 文件末尾是一个写到一半的命令，也可以借助 <code>redis-check-aof</code> 进行恢复</li>\n<li>AOF 包含的是一个又一个的操作命令，易于理解和解析</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>AOF 采用文件追加的方式，使得文件越来越大，如果没有设置好对应的重写策略，容易造成内存溢出</li>\n<li>AOF 可能比 RDB 要慢（跟 <code>no-appendfsync-on-rewrite</code> 有关）</li>\n<li>AOF 采用文件追加的方式更新数据，而 RDB 是从头开始创建，更健壮和稳定</li>\n</ul>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "💁‍♂️ Redis 事务",
      "url": "https://blog.lixiangyu.xyz/interview/redis/redis-transcation/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/redis-transcation/",
      "content_html": "<h2 id=\"redis-怎么处理事务\"> Redis 怎么处理事务？</h2>\n<p>Redis 使用 <code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code> 这四个命令完成事务。</p>\n<p>使用 <code>MULTI</code> 开启事务，客户端可以向服务器发送任意多个命令，这些命令不会立马执行，而是被放到一个队列中，当调用 <code>EXEC</code> 命令时，所有队列中的命令才会被执行。如果没有执行 <code>EXEC</code>，那么事务中的所有命令都不会被执行。如果在执行 <code>EXEC</code> 命令之后发生了错误，或者在事务中某个命令发生了错误，事务也会正常执行，不会进行回滚。比如下面的操作将正常执行：</p>\n<div><pre><code>127.0.0.1:6379&gt; multi \nOK \n127.0.0.1:6379&gt; set key value1 \nQUEUED \n127.0.0.1:6379&gt; incr key \nQUEUED \n127.0.0.1:6379&gt; set key value2 \nQUEUED \n127.0.0.1:6379&gt; exec \n1) OK \n2) (error) ERR value is not an integer or out of range \n3) OK \n127.0.0.1:6379&gt; get key \n&quot;value2&quot; \n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>通过调用 <code>DISCARD</code> 命令，客户端可以清空事务队列，并放弃执行事务。在事务执行之前，可以通过 <code>WATCH</code> 命令监视一个或多个 <code>key</code>，如果在事务执行之前这个（或这些）<code>key</code> 被其他命令修改了，那么事务将被打断。可以视为 Redis 提供的 CAS 锁。</p>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🤦‍♂️ 故障处理",
      "url": "https://blog.lixiangyu.xyz/interview/redis/troubleshooting/",
      "id": "https://blog.lixiangyu.xyz/interview/redis/troubleshooting/",
      "content_html": "<h2 id=\"缓存穿透应该怎么处理\"> 缓存穿透应该怎么处理？</h2>\n<p>缓存穿透指：<strong>大量请求肯定不存在于缓存和数据库中的 key</strong>，使请求全部落到了数据库上，就好像没有缓存一样，直接穿透了。解决方案：</p>\n<ul>\n<li>做好参数校验：对于不合理的参数即时返回错误信息</li>\n<li>把无效 <code>key</code> 缓存起来：这种方式是治标不治本，可能会导致在 Redis 中缓存大量的无效 <code>key</code>，如果需要使用方式，建议将过期时间尽可能的设置短一些</li>\n<li>使用布隆过滤器：在判断缓存前，优先在布隆过滤器中判断，需要注意的是：布隆过滤器可能会误判，因为哈希相同但原对象可能不同</li>\n</ul>\n<p>为什么会出现误判的情况呢？先来看一下，当一个元素加入布隆过滤器中的时候，会进行哪些操作：</p>\n<ul>\n<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）</li>\n<li>根据得到的哈希值，在位数组中把对应下标的值置为 1</li>\n</ul>\n<p>再来看一下，当需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</p>\n<ul>\n<li>对给定元素再次进行相同的哈希计算</li>\n<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中</li>\n</ul>\n<p>然后，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同（可以适当增加位数组大小或者调整我们的哈希函数来降低概率），因此可能会发生哈希冲突。<strong>所以如果布隆过滤器判断某个元素不存在，那么它一定不存在；如果判断某个元素存在，它是可能存在。</strong></p>\n<div>\n<p><img src=\"https://i.loli.net/2021/07/31/4zWsckj8LINeunb.png\" alt=\"布隆过滤器.jpg\" /></p>\n</div>\n<h2 id=\"缓存击穿应该怎么处理\"> 缓存击穿应该怎么处理？</h2>\n<p>缓存击穿指：<strong>同时有大量的查询请求去查询一个缓存中肯定没有（可能刚刚失效）但数据库中存在的数据</strong>，这往往发生在第一次请求缓存数据或者缓存数据到期的时候。解决方案：</p>\n<ul>\n<li>采用分级缓存：采用 L1 一级缓存（失效时间短）和 L2 二级缓存（失效时间长）结合使用的方式，首先请求 L1，如果 L1 中没有元素则加锁，使一个线程从数据库中获取值并更新 L1 和 L2 缓存，但是这种方案可能会导致 L2 中存在脏数据，同时会占用更大的内存</li>\n<li>加互斥锁：确保同一时间只有一个线程在查询数据库并更新缓存</li>\n<li>设置热点数据永不失效</li>\n<li>接口限流、熔断、降级</li>\n</ul>\n<h2 id=\"缓存雪崩应该怎么处理\"> 缓存雪崩应该怎么处理？</h2>\n<p>缓存雪崩是指：<strong>缓存在同一时间大面积的失效或者数据未加载到缓存中，使请求直接落到了数据库上</strong>，造成数据库短时间内承受大量请求，就像发生了雪崩一样。解决方案：</p>\n<ul>\n<li>如果是 Redis 服务不可用导致的缓存雪崩\n<ul>\n<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用</li>\n<li>接口限流、熔断、降级</li>\n</ul>\n</li>\n<li>如果是热点缓存失效导致的缓存雪崩\n<ul>\n<li>设置不同的失效时间，比如随机设置缓存的失效时间</li>\n<li>设置为缓存永不失效</li>\n<li>接口限流、熔断、降级</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"热点数据失效怎么处理\"> 热点数据失效怎么处理？</h2>\n<p>热点数据是访问率比较高的数据，<strong>当热点数据集中的数据缓存同时失效后可能会使大量的请求落到数据库上</strong>，从而导致数据库崩溃。解决方案：</p>\n<ul>\n<li>设置不同的失效时间，比如随机设置缓存的失效时间</li>\n<li>设置缓存为永不失效</li>\n<li>接口限流、熔断、降级</li>\n</ul>\n",
      "image": "https://i.loli.net/2021/07/31/4zWsckj8LINeunb.png",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "👨‍🔧 设计模式",
      "url": "https://blog.lixiangyu.xyz/interview/thoughts/design-pattern/",
      "id": "https://blog.lixiangyu.xyz/interview/thoughts/design-pattern/",
      "content_html": "<h2 id=\"什么是设计模式\"> 什么是设计模式？</h2>\n<p>设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>\n<h2 id=\"单例模式\"> 单例模式<i>Not supported content</i></h2>\n<h3 id=\"什么是单例模式\"> 什么是单例模式？</h3>\n<p>单例类必须保证只有一个实例存在，整个系统只能使用一个对象实例。优点是不会频繁地创建和销毁对象，浪费系统资源。</p>\n<h3 id=\"单例模式有哪几种创建方式\"> 单例模式有哪几种创建方式？</h3>\n<CodeGroup>\n<CodeGroupItem title=\"懒汉式（线程不安全）\">\n<div><pre><code><span>/**\n * 懒加载：是\n * 线程安全：不安全\n */</span>\n<span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"懒汉式（线程安全）\" active>\n<div><pre><code><span>/**\n * 懒加载：是\n * 线程安全：使用了synchronized，所以可以保证线程安全\n */</span>\n<span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>synchronized</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"饿汉式\" active>\n<div><pre><code><span>/**\n * 懒加载：否\n * 线程安全：在类加载时就进行了实例化，所以可以保证线程安全\n */</span>\n<span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>Singleton</span> instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"双检锁\" active>\n<div><pre><code><span>/**\n * 懒加载：是\n * 线程安全：是，另外相比线程安全的懒汉式，这种方式的执行效率明明显更高\n */</span>\n<span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>static</span> <span>volatile</span> <span>Singleton</span> instance<span>;</span>\n\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>\n            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>\n                <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>\n                    instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n                <span>}</span>\n            <span>}</span>\n        <span>}</span>\n        <span>return</span> instance<span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>\n<CodeGroupItem title=\"静态内部类\" active>\n<div><pre><code><span>/**\n * 懒加载：是\n * 线程安全：同样的，基于类加载器实现的线程安全\n */</span>\n<span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>\n    <span>private</span> <span>Singleton</span><span>(</span><span>)</span> <span>{</span>\n\n    <span>}</span>\n\n    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>\n        <span>return</span> <span>SingletonHolder</span><span>.</span>INSTANCE<span>;</span>\n    <span>}</span>\n    \n    <span>private</span> <span>static</span> <span>class</span> <span>SingletonHolder</span> <span>{</span>\n        <span>private</span> <span>static</span> <span>final</span> <span>Singleton</span> INSTANCE <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span>\n<span>}</span>\n</code></pre>\n<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></CodeGroupItem>\n</CodeGroup>\n<div><p>为什么要命名为饿汉式和懒汉式</p>\n<p>通过上面的代码可以看到：</p>\n<ul>\n<li>饿汉式不支持懒加载，不管程序是否需要这个对象的实例，总是在类加载的时候就先创建好实例</li>\n<li>懒汉式支持懒加载，只有在需要的时候才会去创建对象</li>\n</ul>\n<p>饿汉式就好像一个人不管想不想吃东西都会把吃的提前先买好，如同饿怕了一样；而懒汉式就好像一个人懒的直到饿的不行了才会去吃东西。</p>\n</div>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "🌀 设计思想 - 简介",
      "url": "https://blog.lixiangyu.xyz/interview/thoughts/",
      "id": "https://blog.lixiangyu.xyz/interview/thoughts/",
      "content_html": "<p>作为程序员，编码是基本功，但真要有所发展还是得看思想。所以这一部分会聊聊设计思想，比如场景怎么设计、技术如何选型。</p>\n<ol>\n<li><a href=\"/interview/thoughts/design-pattern\">设计模式</a>：程序员必须要了解的设计模式</li>\n</ol>\n",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    },
    {
      "title": "主页",
      "url": "https://blog.lixiangyu.xyz/",
      "id": "https://blog.lixiangyu.xyz/",
      "content_html": "",
      "date_published": "2021-08-01T11:23:38.000Z",
      "date_modified": "2021-08-01T11:23:38.000Z",
      "authors": [
        {
          "name": "Xiangyu Li"
        }
      ],
      "tags": []
    }
  ]
}