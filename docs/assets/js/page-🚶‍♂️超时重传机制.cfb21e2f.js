(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{776:function(t,v,_){"use strict";_.r(v);var s=_(1),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"介绍一下超时重传机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下超时重传机制"}},[t._v("#")]),t._v(" 介绍一下超时重传机制？")]),t._v(" "),_("p",[t._v("重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据，这就是超时重传。")]),t._v(" "),_("p",[t._v("TCP 会在以下两种情况发生超时重传：")]),t._v(" "),_("ul",[_("li",[t._v("数据包丢失")]),t._v(" "),_("li",[t._v("确认应答丢失")])]),t._v(" "),_("h2",{attrs:{id:"怎么确认超时重传的超时时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么确认超时重传的超时时间"}},[t._v("#")]),t._v(" 怎么确认超时重传的超时时间？")]),t._v(" "),_("p",[t._v("先介绍一下 RTT 和 RTO：")]),t._v(" "),_("ul",[_("li",[t._v("RTT（Round-Trip Time）指的是数据从网络一端传送到另一端所需的时间，也就是包的往返时间")]),t._v(" "),_("li",[t._v("RTO（Retransmission Timeout）指的是超时重传时间")])]),t._v(" "),_("p",[t._v("如果 RTO 设置的不太合适：")]),t._v(" "),_("ul",[_("li",[t._v("如果设置的比较短，那么可能并没有丢包但依然重发了，这会造成网络阻塞")]),t._v(" "),_("li",[t._v("如果设置的比较长，那么可能在丢包很久后才进行重发，效率低")])]),t._v(" "),_("p",[t._v("所以 RTO 应该是一个动态的值，并且要略大于 RTT。RTT 也是一个动态的值，它的估算需要以下两点，具体的计算公式就不贴了：")]),t._v(" "),_("ul",[_("li",[t._v("TCP 采样 RTT 的时间，然后进行加权平均，算出一个平滑 RTT 的值，而且这个值还是要不断变化的，因为网络状况不断地变化")]),t._v(" "),_("li",[t._v("除了采样 RTT，还要采样 RTT 的波动范围，这样就避免如果 RTT 有一个大的波动的话，很难被发现的情况")])]),t._v(" "),_("p",[t._v("如果超时重发的数据，再次超时重传，那么 TCP 的策略是超时间隔加倍。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。超时触发重传存在的问题是，超时周期可能相对较长。所以就可以用快速重传机制来解决超时重发的时间等待。")]),t._v(" "),_("h2",{attrs:{id:"介绍一下快速重传机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下快速重传机制"}},[t._v("#")]),t._v(" 介绍一下快速重传机制？")]),t._v(" "),_("p",[t._v("TCP 还有另外一种叫做快速重传（Fast Retransmit）的机制，它不以时间为驱动，而是以数据驱动进行重传。")]),t._v(" "),_("div",{staticClass:"custom-block center"},[_("p",[_("img",{attrs:{src:"https://i.loli.net/2021/08/01/j2vNckRoiV6EmW4.png",alt:"快速重传.png"}})])]),t._v(" "),_("p",[t._v("在上图，发送方发出了 1、2、3、4、5，共计 5 份数据：")]),t._v(" "),_("ul",[_("li",[t._v("第一份 Seq1 先送到了，于是 Ack 返回了 2")]),t._v(" "),_("li",[t._v("但是 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2")]),t._v(" "),_("li",[t._v("后面的 Seq4 和 Seq5 都到了，但 Ack 还是返回 2，因为 Seq2 还是没有收到")]),t._v(" "),_("li",[t._v("发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2")]),t._v(" "),_("li",[t._v("最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。")])]),t._v(" "),_("p",[t._v("所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。")]),t._v(" "),_("p",[t._v("快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题：重传的时候，是重传之前的一个，还是重传所有。比如对于上面的例子，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。根据 TCP 不同的实现，以上两种情况都是有可能的。为了解决不知道该重传哪些 TCP 报文，于是就有 SACK 方法。")]),t._v(" "),_("h2",{attrs:{id:"介绍一下-sack-重传机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-sack-重传机制"}},[t._v("#")]),t._v(" 介绍一下 SACK 重传机制？")]),t._v(" "),_("p",[t._v("还有一种实现重传机制的方式叫：SACK（ Selective Acknowledgment 选择性确认）。这种方式需要在 TCP 头部的选项字段里加一个 SACK ，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。")]),t._v(" "),_("p",[t._v("如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。")]),t._v(" "),_("div",{staticClass:"custom-block center"},[_("p",[_("img",{attrs:{src:"https://i.loli.net/2021/08/01/CIuGNljZ9EWfm1g.png",alt:"sack.png"}})])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("需要操作系统支持")]),t._v(" "),_("p",[t._v("SACK 机制必须双方都要支持，在 Linux 下，可以通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。")])]),t._v(" "),_("h2",{attrs:{id:"介绍一下-d-sack-机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-d-sack-机制"}},[t._v("#")]),t._v(" 介绍一下 D-SACK 机制")]),t._v(" "),_("p",[t._v("因为 ACK 丢包或者网络时延导致发送发没有及时收到 ACK，误以为丢包而进行重发，此时接收方可以给发送方回复一个包含接收序号的 SACK，表示这之前的序号都已经收到了，发送了重复数据。这种方式称为 Duplicate SACK，又称 D-SACK，主要就使用了 SACK 来告诉发送方有哪些数据被重复接收了。")]),t._v(" "),_("p",[t._v("D-SACK 的好处：")]),t._v(" "),_("ul",[_("li",[t._v("可以让发送方知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了")]),t._v(" "),_("li",[t._v("可以知道是不是发送方的数据包被网络延迟了")]),t._v(" "),_("li",[t._v("可以知道网络中是不是把发送方的数据包给复制了")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("需要操作系统支持")]),t._v(" "),_("p",[t._v("在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能（Linux 2.4 后默认打开）。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);