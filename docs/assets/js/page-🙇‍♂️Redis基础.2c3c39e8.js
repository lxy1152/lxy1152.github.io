(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{785:function(t,e,v){"use strict";v.r(e);var s=v(1),_=Object(s.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"什么是-redis"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-redis"}},[t._v("#")]),t._v(" 什么是 Redis？")]),t._v(" "),v("p",[t._v("Redis 一款内存高速缓存数据库，全称为："),v("strong",[t._v("Re")]),t._v("mote "),v("strong",[t._v("Di")]),t._v("ctionary "),v("strong",[t._v("S")]),t._v("erver（远程数据服务），使用 C 语言编写。")]),t._v(" "),v("h2",{attrs:{id:"为什么要使用-redis"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用-redis"}},[t._v("#")]),t._v(" 为什么要使用 Redis？")]),t._v(" "),v("ul",[v("li",[t._v("高性能：直接从缓存中获取的速度肯定是要比从数据库中获取的速度要快的，但是需要注意的是保证数据库和缓存内容的一致性")]),t._v(" "),v("li",[t._v("高并发：一般像 MySQL 这类的数据库的 QPS（Query Per Second，服务器每秒可以执行的查询次数）大概都在 1w 左右（4 核 8g），但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）")])]),t._v(" "),v("p",[t._v("所以直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，那么就可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而也就提高了系统整体的并发量。")]),t._v(" "),v("h2",{attrs:{id:"redis-提供的数据类型有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-提供的数据类型有哪些"}},[t._v("#")]),t._v(" Redis 提供的数据类型有哪些？"),v("Badge",{attrs:{text:"重点",type:"error"}})],1),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("数据类型")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("可以存储的值")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("操作")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("STRING")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("字符串、整数或者浮点数")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("对整个字符串或者字符串的其中一部分执行操作，对整数和浮点数执行自增或者自减操作")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("LIST")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("列表")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("从两端压入或者弹出元素，对单个或者多个元素进行修剪，只保留一个范围内的元素")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("SET")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("无序集合")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("添加、获取、移除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集，从集合里面随机获取元素")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("HASH")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("包含键值对的无序散列表")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("添加、获取、移除单个键值对，获取所有键值对，检查某个键是否存在")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("ZSET")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("有序集合")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("添加、获取、删除元素，根据分值范围或者成员来获取元素，计算一个键的排名")])])])]),t._v(" "),v("h2",{attrs:{id:"redis-的应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-的应用场景"}},[t._v("#")]),t._v(" Redis 的应用场景？")]),t._v(" "),v("ul",[v("li",[t._v("计数器")]),t._v(" "),v("li",[t._v("缓存")]),t._v(" "),v("li",[t._v("消息队列")]),t._v(" "),v("li",[t._v("对话缓存")]),t._v(" "),v("li",[t._v("分布式锁")])]),t._v(" "),v("h2",{attrs:{id:"redis-为什么速度快"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么速度快"}},[t._v("#")]),t._v(" Redis 为什么速度快？")]),t._v(" "),v("ul",[v("li",[t._v("采用多路 I/O 复用机制")]),t._v(" "),v("li",[t._v("数据结构简单，操作节省时间")]),t._v(" "),v("li",[t._v("运行在内存中")])]),t._v(" "),v("h2",{attrs:{id:"redis-是单线程的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-是单线程的吗"}},[t._v("#")]),t._v(" Redis 是单线程的吗？")]),t._v(" "),v("p",[t._v("虽然 Redis 是单线程模型，但是实际上 Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。不过 Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理线程之外的其他线程来异步处理。")]),t._v(" "),v("p",[t._v("整体上来说，Redis 在 6.0 版本之前主要还是单线程处理。那 Redis 6.0 之前为什么不使用多线程呢？")]),t._v(" "),v("ul",[v("li",[t._v("单线程编程容易并且更容易维护")]),t._v(" "),v("li",[t._v("Redis 的性能瓶颈不在 CPU，"),v("strong",[t._v("主要是内存和网络")])]),t._v(" "),v("li",[t._v("多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能")])]),t._v(" "),v("p",[t._v("那为什么 Redis 6.0 之后又引入了多线程呢？主要是为了提升网络 I/O 读写性能，多线程在默认情况下是关闭的，需要通过修改配置项进行开启：")]),t._v(" "),v("div",{staticClass:"language-text line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("io-threads-do-reads yes # 开启多线程\nio-threads 4 # 官网建议 4 核的机器设置为 2 或 3 个线程，8 核的建议设置为 6 个线程\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("h2",{attrs:{id:"redis-的操作是原子性的吗-如何保证原子性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-的操作是原子性的吗-如何保证原子性"}},[t._v("#")]),t._v(" Redis 的操作是原子性的吗，如何保证原子性？")]),t._v(" "),v("p",[t._v("对于 Redis 来说，执行 "),v("code",[t._v("get")]),t._v("、"),v("code",[t._v("set")]),t._v(" 以及 "),v("code",[t._v("eval")]),t._v("（使用 Lua 解释器执行脚本）等命令，都是一个一个的任务，这些任务都会由 Redis 的线程去负责执行，任务要么执行成功，要么执行失败。")]),t._v(" "),v("h2",{attrs:{id:"怎么保证缓存和数据库的数据一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#怎么保证缓存和数据库的数据一致性"}},[t._v("#")]),t._v(" 怎么保证缓存和数据库的数据一致性？")]),t._v(" "),v("ul",[v("li",[t._v("缓存失效时间变短（不推荐，治标不治本）：让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据")]),t._v(" "),v("li",[t._v("增加缓存更新重试机制（常用）：如果因为缓存服务当前不可用导致缓存删除失败的话，就隔一段时间进行重试。如果多次重试还是失败的话，可以把当前更新失败的 "),v("code",[t._v("key")]),t._v(" 存入队列中，等缓存服务可用之后，再将缓存中对应的 "),v("code",[t._v("key")]),t._v(" 删除即可")])]),t._v(" "),v("h2",{attrs:{id:"redis-在什么情况下会有性能问题-如何处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-在什么情况下会有性能问题-如何处理"}},[t._v("#")]),t._v(" Redis 在什么情况下会有性能问题，如何处理？")]),t._v(" "),v("ul",[v("li",[t._v("主服务器写内存快照，"),v("code",[t._v("save")]),t._v(" 命令调度 "),v("code",[t._v("rdbSave")]),t._v(" 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照")]),t._v(" "),v("li",[t._v("主服务器 AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响主服务器重启的恢复速度")]),t._v(" "),v("li",[t._v("主服务器调用 "),v("code",[t._v("BGREWRITEAOF")]),t._v(" 重写 AOF 文件会占大量的 CPU 和内存资源，导致服务过载，出现短暂服务暂停现象")]),t._v(" "),v("li",[t._v("Redis 主从复制也可能会有性能问题，为了主从复制的速度和连接的稳定性，从服务器和主服务器最好在同一个局域网内")])])])}),[],!1,null,null,null);e.default=_.exports}}]);