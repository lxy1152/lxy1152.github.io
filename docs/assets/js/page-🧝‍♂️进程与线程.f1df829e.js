(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{784:function(t,a,s){"use strict";s.r(a);var v=s(1),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"进程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[t._v("#")]),t._v(" 进程")]),t._v(" "),s("h3",{attrs:{id:"并发和并行的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发和并行的区别"}},[t._v("#")]),t._v(" 并发和并行的区别？")]),t._v(" "),s("ul",[s("li",[t._v("并发：能够处理多个任务，但不一定同时")]),t._v(" "),s("li",[t._v("并行：能够处理多个任务，并且能够同时执行（只要速度足够快，看起来就像是在同时执行）")])]),t._v(" "),s("h3",{attrs:{id:"进程有哪几个状态"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程有哪几个状态"}},[t._v("#")]),t._v(" 进程有哪几个状态？")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/Sdlb9XfRaGqYLUm.png",alt:"进程状态1.png"}})])]),t._v(" "),s("p",[t._v("如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，非常浪费空间。所以在使用虚拟内存管理的操作系统中，通常会把处于阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候再从硬盘换入到物理内存。通过挂起状态来描述这种行为。")]),t._v(" "),s("p",[t._v("挂起状态又分为：")]),t._v(" "),s("ul",[s("li",[t._v("阻塞挂起：进程在外存（硬盘）并等待某个事件的出现")]),t._v(" "),s("li",[t._v("就绪挂起：进程在外存（硬盘），但只要进入内存，那么立刻就会运行（比如通过 Ctrl+Z 挂起进程）")])]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/RPVBXA2zmdyJptn.png",alt:"进程状态2.png"}})])]),t._v(" "),s("h3",{attrs:{id:"什么是进程控制块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是进程控制块"}},[t._v("#")]),t._v(" 什么是进程控制块？")]),t._v(" "),s("p",[t._v("进程控制块（process control block，PCB）是操作系统用来描述进程的一种数据结构。一个进程必然会对应一个 PCB，如果进程结束了，那么 PCB 也会随之消失。一个 PCB 中会包含以下信息：")]),t._v(" "),s("ul",[s("li",[t._v("进程描述信息\n"),s("ul",[s("li",[t._v("进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符")]),t._v(" "),s("li",[t._v("用户标识符：进程归属的用户，用户标识符主要为共享和保护服务")])])]),t._v(" "),s("li",[t._v("进程控制和管理信息\n"),s("ul",[s("li",[t._v("进程当前状态：如 new、ready、running、waiting 或 blocked 等")]),t._v(" "),s("li",[t._v("进程优先级：进程抢占 CPU 时的优先级")])])]),t._v(" "),s("li",[t._v("资源分配清单\n"),s("ul",[s("li",[t._v("有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息")])])]),t._v(" "),s("li",[t._v("CPU 相关信息\n"),s("ul",[s("li",[t._v("CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行")])])])]),t._v(" "),s("h3",{attrs:{id:"什么是进程的上下文切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是进程的上下文切换"}},[t._v("#")]),t._v(" 什么是进程的上下文切换？")]),t._v(" "),s("p",[t._v("进程是由内核管理和调度的，所以进程的切换只能发生在内核态。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/sVzGlWwXuTQtIJB.png",alt:"进程上下文切换.png"}})])]),t._v(" "),s("h3",{attrs:{id:"哪些情况会引发线程上下文切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些情况会引发线程上下文切换"}},[t._v("#")]),t._v(" 哪些情况会引发线程上下文切换？")]),t._v(" "),s("ul",[s("li",[t._v("时间片用完")]),t._v(" "),s("li",[t._v("所需资源（比如内存）不足")]),t._v(" "),s("li",[t._v("调用 "),s("code",[t._v("sleep")]),t._v(" 主动挂起")]),t._v(" "),s("li",[t._v("有更高优先级的进程需要先执行")]),t._v(" "),s("li",[t._v("发生硬件中断")])]),t._v(" "),s("h2",{attrs:{id:"线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[t._v("#")]),t._v(" 线程")]),t._v(" "),s("h3",{attrs:{id:"什么是线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程"}},[t._v("#")]),t._v(" 什么是线程？")]),t._v(" "),s("p",[t._v("线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。")]),t._v(" "),s("h3",{attrs:{id:"线程与进程的比较"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程与进程的比较"}},[t._v("#")]),t._v(" 线程与进程的比较？")]),t._v(" "),s("p",[t._v("线程与进程的区别如下：")]),t._v(" "),s("ul",[s("li",[t._v("进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位")]),t._v(" "),s("li",[t._v("进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈")]),t._v(" "),s("li",[t._v("线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系")]),t._v(" "),s("li",[t._v("线程能减少并发执行的时间和空间开销")])]),t._v(" "),s("p",[t._v("线程相比进程能减少开销，体现在：")]),t._v(" "),s("ul",[s("li",[t._v("线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们")]),t._v(" "),s("li",[t._v("线程的终止时间比进程快，因为线程释放的资源相比进程少很多")]),t._v(" "),s("li",[t._v("同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的")]),t._v(" "),s("li",[t._v("由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了")])]),t._v(" "),s("h3",{attrs:{id:"什么是线程的上下文切换"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程的上下文切换"}},[t._v("#")]),t._v(" 什么是线程的上下文切换？")]),t._v(" "),s("ul",[s("li",[t._v("当两个线程不是属于同一个进程时，切换的过程就跟进程上下文切换一样")]),t._v(" "),s("li",[t._v("当两个线程是属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据")])]),t._v(" "),s("h2",{attrs:{id:"调度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调度"}},[t._v("#")]),t._v(" 调度")]),t._v(" "),s("h3",{attrs:{id:"什么情况下会发生调度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下会发生调度"}},[t._v("#")]),t._v(" 什么情况下会发生调度？")]),t._v(" "),s("ul",[s("li",[t._v("从就绪态转变为运行态")]),t._v(" "),s("li",[t._v("从运行态转变为阻塞态")]),t._v(" "),s("li",[t._v("从运行态转变为结束态")])]),t._v(" "),s("p",[t._v("以上三种情况，操作系统都需要重新选择一个进程来执行，所以需要调度。调度算法大体上分为两类：")]),t._v(" "),s("ul",[s("li",[t._v("非抢占式调度算法：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情")]),t._v(" "),s("li",[t._v("抢占式调度算法：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程，这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制")])]),t._v(" "),s("h3",{attrs:{id:"cpu-调度的基本原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cpu-调度的基本原则"}},[t._v("#")]),t._v(" CPU 调度的基本原则？")]),t._v(" "),s("ul",[s("li",[t._v("CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率")]),t._v(" "),s("li",[t._v("系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量")]),t._v(" "),s("li",[t._v("周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好")]),t._v(" "),s("li",[t._v("等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意")]),t._v(" "),s("li",[t._v("响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准")])]),t._v(" "),s("h3",{attrs:{id:"有哪些调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#有哪些调度算法"}},[t._v("#")]),t._v(" 有哪些调度算法？")]),t._v(" "),s("h4",{attrs:{id:"先来先服务算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#先来先服务算法"}},[t._v("#")]),t._v(" 先来先服务算法")]),t._v(" "),s("p",[t._v("先来先服务（First Come First Severd, FCFS）算法是指每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，这将不利于短作业。")]),t._v(" "),s("h4",{attrs:{id:"最短作业优先调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最短作业优先调度算法"}},[t._v("#")]),t._v(" 最短作业优先调度算法")]),t._v(" "),s("p",[t._v("最短作业优先（Shortest Job First, SJF）调度算法会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。但这种算法很明显对长作业不友好。")]),t._v(" "),s("h4",{attrs:{id:"高响应比优先调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#高响应比优先调度算法"}},[t._v("#")]),t._v(" 高响应比优先调度算法")]),t._v(" "),s("p",[t._v("高响应比优先 （Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行，响应比优先级的计算公式：")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",{staticClass:"katex-block"},[s("span",{staticClass:"katex-display"},[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML",display:"block"}},[s("semantics",[s("mrow",[s("mtext",[t._v("优先权")]),s("mo",[t._v("=")]),s("mfrac",[s("mrow",[s("mtext",[t._v("等待时间")]),s("mo",[t._v("+")]),s("mtext",[t._v("要求服务时间")])],1),s("mtext",[t._v("要求服务时间")])],1)],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("优先权 = \\frac{等待时间+要求服务时间}{要求服务时间}\n")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord cjk_fallback"},[t._v("优先权")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),s("span",{staticClass:"mrel"},[t._v("=")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"2.04633em","vertical-align":"-0.686em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mopen nulldelimiter"}),s("span",{staticClass:"mfrac"},[s("span",{staticClass:"vlist-t vlist-t2"},[s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"1.36033em"}},[s("span",{staticStyle:{top:"-2.314em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord cjk_fallback"},[t._v("要求服务时间")])])]),s("span",{staticStyle:{top:"-3.23em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),s("span",{staticClass:"frac-line",staticStyle:{"border-bottom-width":"0.04em"}})]),s("span",{staticStyle:{top:"-3.677em"}},[s("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),s("span",{staticClass:"mord"},[s("span",{staticClass:"mord cjk_fallback"},[t._v("等待时间")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),s("span",{staticClass:"mbin"},[t._v("+")]),s("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),s("span",{staticClass:"mord cjk_fallback"},[t._v("要求服务时间")])])])]),s("span",{staticClass:"vlist-s"},[t._v("​")])]),s("span",{staticClass:"vlist-r"},[s("span",{staticClass:"vlist",staticStyle:{height:"0.686em"}},[s("span")])])])]),s("span",{staticClass:"mclose nulldelimiter"})])])])])])])]),t._v(" "),s("h4",{attrs:{id:"时间片轮转调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间片轮转调度算法"}},[t._v("#")]),t._v(" 时间片轮转调度算法")]),t._v(" "),s("p",[t._v("时间片轮转（Round Robin, RR）调度算法是给每个进程分配一个时间段，称为时间片（Quantum）。")]),t._v(" "),s("ul",[s("li",[t._v("如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程")]),t._v(" "),s("li",[t._v("如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换")])]),t._v(" "),s("h4",{attrs:{id:"最高优先级调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最高优先级调度算法"}},[t._v("#")]),t._v(" 最高优先级调度算法")]),t._v(" "),s("p",[t._v("时间片轮转算法做了个假设，即让所有的进程同等重要，大家的运行时间都一样。但是对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。")]),t._v(" "),s("p",[t._v("进程的优先级可以分为，静态优先级或动态优先级：")]),t._v(" "),s("ul",[s("li",[t._v("静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化")]),t._v(" "),s("li",[t._v("动态优先级：根据进程的动态变化调整优先级，比如进程运的行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级")])]),t._v(" "),s("h4",{attrs:{id:"多级反馈队列调度算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多级反馈队列调度算法"}},[t._v("#")]),t._v(" 多级反馈队列调度算法")]),t._v(" "),s("p",[t._v("多级反馈队列（Multilevel Feedback Queue）调度算法是时间片轮转算法和最高优先级算法的综合和发展。")]),t._v(" "),s("ul",[s("li",[t._v("多级表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短")]),t._v(" "),s("li",[t._v("反馈表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列")])]),t._v(" "),s("h2",{attrs:{id:"进程间的通信方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程间的通信方式"}},[t._v("#")]),t._v(" 进程间的通信方式")]),t._v(" "),s("h3",{attrs:{id:"为什么要进行进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要进行进程间通信"}},[t._v("#")]),t._v(" 为什么要进行进程间通信？")]),t._v(" "),s("p",[t._v("程序中经常需要多个进程同时工作，这些进程需要互相通信，这就需要进程间通信。进程间的通信方式包括：")]),t._v(" "),s("ul",[s("li",[t._v("管道")]),t._v(" "),s("li",[t._v("消息队列")]),t._v(" "),s("li",[t._v("共享内存")]),t._v(" "),s("li",[t._v("信号量")]),t._v(" "),s("li",[t._v("信号")]),t._v(" "),s("li",[t._v("Socket")])]),t._v(" "),s("h3",{attrs:{id:"如何通过管道实现进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何通过管道实现进程间通信"}},[t._v("#")]),t._v(" 如何通过管道实现进程间通信？")]),t._v(" "),s("p",[t._v("在 Linux 中使用符号 "),s("code",[t._v("|")]),t._v(" 就是使用了管道的功能。这种方式实际上是创建了一个匿名管道，它将前一个命令的的输出作为后一个命令的输入，比如："),s("code",[t._v("ps auxf | grep mysql")]),t._v("。")]),t._v(" "),s("p",[t._v("还有一种方式可以创建一个命名管道，它通过 "),s("code",[t._v("mkfifo")]),t._v(" 命令创建，比如："),s("code",[t._v("mkfifo myPipeline")]),t._v("。管道这种通信方式效率低，不适合进程间频繁通信。")]),t._v(" "),s("h3",{attrs:{id:"如何通过消息队列实现进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何通过消息队列实现进程间通信"}},[t._v("#")]),t._v(" 如何通过消息队列实现进程间通信？")]),t._v(" "),s("p",[t._v("对于管道存在的问题，可以使用消息队列进行解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。")]),t._v(" "),s("p",[t._v("但这种方式有两个问题：")]),t._v(" "),s("ul",[s("li",[t._v("通信不及时")]),t._v(" "),s("li",[t._v("传送的消息大小有限制")])]),t._v(" "),s("p",[t._v("由于进程是写入数据到内核的消息队列，所以发生从用户态到内核态的过程，读取数据同理，所以还存在状态切换的开销。")]),t._v(" "),s("h3",{attrs:{id:"如何通过共享内存实现进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何通过共享内存实现进程间通信"}},[t._v("#")]),t._v(" 如何通过共享内存实现进程间通信？")]),t._v(" "),s("p",[t._v("共享内存就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，不需要再传来传去，大大提高了进程间通信的速度。")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/Qa3BSfYgqyCoLMj.png",alt:"共享内存.png"}})])]),t._v(" "),s("h3",{attrs:{id:"如何通过信号量实现进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何通过信号量实现进程间通信"}},[t._v("#")]),t._v(" 如何通过信号量实现进程间通信？")]),t._v(" "),s("p",[t._v("通过共享内存进行通信的方式会带来新的问题：如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。为了防止多进程竞争共享资源，而造成的数据错乱，需要一种保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量就实现了这样一种保护机制。")]),t._v(" "),s("p",[t._v("信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：")]),t._v(" "),s("ul",[s("li",[t._v("P 操作：这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待，如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行")]),t._v(" "),s("li",[t._v("V 操作：这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行，如果信号量 > 0，则表明当前没有阻塞中的进程")])]),t._v(" "),s("p",[t._v("P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。在下面的例子中信号量被初始化为 1：")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/sMUOdwgqEIDbPiN.png",alt:"pv操作举例.png"}})])]),t._v(" "),s("h3",{attrs:{id:"如何通过信号实现进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何通过信号实现进程间通信"}},[t._v("#")]),t._v(" 如何通过信号实现进程间通信？")]),t._v(" "),s("p",[t._v("上面说的几种方式都是常规状态下的工作模式。对于异常情况下的工作模式，需要用信号的方式来通知进程。")]),t._v(" "),s("p",[t._v("在 Linux 中为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义，通过 "),s("code",[t._v("kill -l")]),t._v(" 命令可以查看所有的信号。")]),t._v(" "),s("p",[t._v("在终端中，通过键盘组合键也可以发送信号：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Ctrl + C")]),t._v("：产生 "),s("code",[t._v("SIGINT")]),t._v(" 信号，表示终止进程")]),t._v(" "),s("li",[s("code",[t._v("Ctrl + Z")]),t._v("：产生 "),s("code",[t._v("SIGTSTP")]),t._v(" 信号，表示挂起进程")])]),t._v(" "),s("h3",{attrs:{id:"如何通过-socket-实现进程间通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何通过-socket-实现进程间通信"}},[t._v("#")]),t._v(" 如何通过 Socket 实现进程间通信？")]),t._v(" "),s("p",[t._v("前面所说的的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。针对 TCP 协议的 Socket 编程模型：")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/KDGJEiz2WpLjhcN.png",alt:"TCP编程模型.png"}})])]),t._v(" "),s("p",[t._v("针对 UDP 协议的 Socket 编程：")]),t._v(" "),s("div",{staticClass:"custom-block center"},[s("p",[s("img",{attrs:{src:"https://i.loli.net/2021/08/01/wT5Y1NzIUK92Xnt.png",alt:"udp编程模型.png"}})])]),t._v(" "),s("p",[t._v("实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。")])])}),[],!1,null,null,null);a.default=_.exports}}]);