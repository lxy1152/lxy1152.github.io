(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{711:function(e,v,t){"use strict";t.r(v);var _=t(1),o=Object(_.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"什么是-netty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-netty"}},[e._v("#")]),e._v(" 什么是 Netty？")]),e._v(" "),t("ul",[t("li",[e._v("Netty 是一个基于 NIO 的 client-server（客户端服务器）框架，使用它可以快速简单地开发网络应用程序")]),e._v(" "),t("li",[e._v("它极大地简化并优化了 TCP 和 UDP 套接字服务器等网络编程，并且性能以及安全性等很多方面甚至都要更好")]),e._v(" "),t("li",[e._v("支持多种协议，如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议")])]),e._v(" "),t("p",[e._v("用官方的总结就是：Netty 成功地找到了一种在不妥协可维护性和性能的情况下实现易于开发、性能、稳定性和灵活性的方法。")]),e._v(" "),t("h2",{attrs:{id:"为什么要使用-netty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用-netty"}},[e._v("#")]),e._v(" 为什么要使用 Netty？")]),e._v(" "),t("ul",[t("li",[e._v("统一的 API，支持多种传输类型，阻塞和非阻塞的")]),e._v(" "),t("li",[e._v("简单而强大的线程模型")]),e._v(" "),t("li",[e._v("自带编解码器解决 TCP 粘包/拆包问题")]),e._v(" "),t("li",[e._v("自带各种协议栈")]),e._v(" "),t("li",[e._v("真正的无连接数据包套接字支持")]),e._v(" "),t("li",[e._v("比直接使用 Java 核心 API 有更高的吞吐量、更低的延迟、更低的资源消耗和更少的内存复制")]),e._v(" "),t("li",[e._v("安全性不错，有完整的 SSL/TLS 以及 StartTLS 支持")]),e._v(" "),t("li",[e._v("社区活跃，成熟稳定，经历了大型项目的使用和考验，而且很多开源项目都使用到了 Netty， 比如 Dubbo、RocketMQ 等")])]),e._v(" "),t("h2",{attrs:{id:"netty-有哪些应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-有哪些应用场景"}},[e._v("#")]),e._v(" Netty 有哪些应用场景？")]),e._v(" "),t("ul",[t("li",[e._v("作为 RPC 框架的网络通信工具")]),e._v(" "),t("li",[e._v("作为 HTTP 服务器（可类比 Tomcat）")]),e._v(" "),t("li",[e._v("实现一个即时通讯软件")]),e._v(" "),t("li",[e._v("实现消息推送系统")])]),e._v(" "),t("h2",{attrs:{id:"netty-有哪些核心组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-有哪些核心组件"}},[e._v("#")]),e._v(" Netty 有哪些核心组件？")]),e._v(" "),t("h3",{attrs:{id:"channel"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[e._v("#")]),e._v(" Channel")]),e._v(" "),t("p",[t("code",[e._v("Channel")]),e._v(" 接口是 Netty 对网络操作抽象类，它除了包括基本的 I/O 操作，以及 "),t("code",[e._v("bind()")]),e._v("、"),t("code",[e._v("connect()")]),e._v("、"),t("code",[e._v("read()")]),e._v("、"),t("code",[e._v("write()")]),e._v(" 操作等。比较常用的 "),t("code",[e._v("Channel")]),e._v(" 接口实现类是 "),t("code",[e._v("NioServerSocketChannel")]),e._v("（服务端）和 "),t("code",[e._v("NioSocketChannel")]),e._v("（客户端），这两个 "),t("code",[e._v("Channel")]),e._v(" 可以和 BIO 编程模型中的 "),t("code",[e._v("ServerSocket")]),e._v(" 以及 "),t("code",[e._v("Socket")]),e._v(" 两个概念对应上。Netty 的 "),t("code",[e._v("Channel")]),e._v(" 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。")]),e._v(" "),t("h3",{attrs:{id:"eventloop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[e._v("#")]),e._v(" EventLoop")]),e._v(" "),t("p",[t("code",[e._v("EventLoop")]),e._v(" 定义了 Netty 的核心抽象，用于处理连接的生命周期中所发生的事件，主要作用就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。")]),e._v(" "),t("h3",{attrs:{id:"channelfuture"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#channelfuture"}},[e._v("#")]),e._v(" ChannelFuture")]),e._v(" "),t("p",[e._v("Netty 是异步非阻塞的，所有的 I/O 操作都是异步的。可以通过 "),t("code",[e._v("ChannelFuture")]),e._v(" 接口的 "),t("code",[e._v("addListener()")]),e._v(" 方法注册一个 "),t("code",[e._v("ChannelFutureListener")]),e._v("，当操作执行成功或者失败时，监听就会自动返回结果。")]),e._v(" "),t("h3",{attrs:{id:"channelhandler-和-channelpipeline"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler-和-channelpipeline"}},[e._v("#")]),e._v(" ChannelHandler 和 ChannelPipeline")]),e._v(" "),t("p",[t("code",[e._v("ChannelHandler")]),e._v(" 是消息的具体处理器，它负责处理读写操作、客户端连接等事情。"),t("code",[e._v("ChannelPipeline")]),e._v(" 为 "),t("code",[e._v("ChannelHandler")]),e._v(" 的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 "),t("code",[e._v("Channel")]),e._v(" 被创建时，它会被自动地分配到它专属的 "),t("code",[e._v("ChannelPipeline")]),e._v("，再通过 "),t("code",[e._v("addLast()")]),e._v(" 方法添加一个或者多个 "),t("code",[e._v("ChannelHandler")]),e._v("，因为一个数据或者事件可能会被多个 "),t("code",[e._v("Handler")]),e._v(" 处理。当一个 "),t("code",[e._v("ChannelHandler")]),e._v(" 处理完之后就将数据交给下一个 "),t("code",[e._v("ChannelHandler")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"什么是-eventloopgroup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-eventloopgroup"}},[e._v("#")]),e._v(" 什么是 EventLoopGroup？")]),e._v(" "),t("div",{staticClass:"custom-block center"},[t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/07/31/ihueo5ZHfASXItr.png",alt:"EventLoopGroup.png"}})])]),e._v(" "),t("p",[t("code",[e._v("EventLoopGroup")]),e._v(" 包含多个 "),t("code",[e._v("EventLoop")]),e._v("，"),t("code",[e._v("EventLoop")]),e._v(" 处理的 I/O 事件都将在它专有的 "),t("code",[e._v("Thread")]),e._v(" 上被处理，即 "),t("code",[e._v("Thread")]),e._v(" 和 "),t("code",[e._v("EventLoop")]),e._v(" 属于 "),t("code",[e._v("1 : 1")]),e._v(" 的关系，从而保证线程安全。上图是一个服务端使用 "),t("code",[e._v("EventLoopGroup")]),e._v(" 的模块图，其中 "),t("code",[e._v("Boss EventloopGroup")]),e._v(" 用于接收连接，"),t("code",[e._v("Worker EventloopGroup")]),e._v(" 用于具体的处理（消息的读写以及其他逻辑处理）。")]),e._v(" "),t("p",[e._v("当客户端通过 "),t("code",[e._v("connect()")]),e._v(" 方法连接服务端时，"),t("code",[e._v("bossGroup")]),e._v(" 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 "),t("code",[e._v("workerGroup")]),e._v(" 来处理，然后 "),t("code",[e._v("workerGroup")]),e._v(" 负责处理其 I/O 相关操作。")]),e._v(" "),t("h2",{attrs:{id:"什么是-bootstrap-和-serverbootstrap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-bootstrap-和-serverbootstrap"}},[e._v("#")]),e._v(" 什么是 Bootstrap 和 ServerBootstrap？")]),e._v(" "),t("p",[t("code",[e._v("Bootstrap")]),e._v(" 是客户端的启动引导类/辅助类，"),t("code",[e._v("ServerBootstrap")]),e._v(" 是客户端的启动引导类/辅助类。区别：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Bootstrap")]),e._v(" 通常使用 "),t("code",[e._v("connect()")]),e._v(" 方法连接到远程的主机和端口，作为一个 Netty TCP 协议通信中的客户端。但是它也可以通过 "),t("code",[e._v("bind()")]),e._v(" 方法绑定本地的一个端口，作为 UDP 协议通信中的一端")]),e._v(" "),t("li",[t("code",[e._v("ServerBootstrap")]),e._v(" 通常使用 "),t("code",[e._v("bind()")]),e._v(" 方法绑定本地的端口上，然后等待客户端的连接")]),e._v(" "),t("li",[t("code",[e._v("Bootstrap")]),e._v(" 只需要配置一个线程组，而 "),t("code",[e._v("ServerBootstrap")]),e._v(" 需要配置两个线程组，一个用于接收连接（"),t("code",[e._v("bossGroup")]),e._v("），一个用于具体的处理（"),t("code",[e._v("workerGroup")]),e._v("）")])]),e._v(" "),t("h2",{attrs:{id:"nioeventloopgroup-的默认构造函数会启动多少个线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nioeventloopgroup-的默认构造函数会启动多少个线程"}},[e._v("#")]),e._v(" NioEventLoopGroup 的默认构造函数会启动多少个线程？")]),e._v(" "),t("p",[e._v("默认数量为 CPU 核心数 * 2。")]),e._v(" "),t("h2",{attrs:{id:"介绍一下-netty-的线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-netty-的线程模型"}},[e._v("#")]),e._v(" 介绍一下 Netty 的线程模型？"),t("Badge",{attrs:{text:"重点",type:"error"}})],1),e._v(" "),t("h3",{attrs:{id:"单线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单线程模型"}},[e._v("#")]),e._v(" 单线程模型")]),e._v(" "),t("p",[e._v("一个线程需要执行处理所有的 "),t("code",[e._v("accept")]),e._v("、"),t("code",[e._v("read")]),e._v("、"),t("code",[e._v("decode")]),e._v("、"),t("code",[e._v("process")]),e._v("、"),t("code",[e._v("encode")]),e._v("、"),t("code",[e._v("send")]),e._v(" 事件。对于高负载、高并发，并且对性能要求比较高的场景不适用。")]),e._v(" "),t("h3",{attrs:{id:"多线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多线程模型"}},[e._v("#")]),e._v(" 多线程模型")]),e._v(" "),t("p",[e._v("一个 "),t("code",[e._v("Acceptor")]),e._v(" 线程只负责监听客户端的连接，一个 NIO 线程池负责具体处理： "),t("code",[e._v("accept")]),e._v("、"),t("code",[e._v("read")]),e._v("、"),t("code",[e._v("decode")]),e._v("、"),t("code",[e._v("process")]),e._v("、"),t("code",[e._v("encode")]),e._v("、"),t("code",[e._v("send")]),e._v(" 事件。满足绝大部分应用场景，并发连接量不大的时候没啥问题，但是遇到并发连接大的时候就可能会出现问题，成为性能瓶颈。")]),e._v(" "),t("div",{staticClass:"custom-block center"},[t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/07/31/jLMVbGTH3Dw6qlP.png",alt:"Netty多线程模型.png"}})])]),e._v(" "),t("h3",{attrs:{id:"主从多线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从多线程模型"}},[e._v("#")]),e._v(" 主从多线程模型")]),e._v(" "),t("p",[e._v("从一个主线程 NIO 线程池中选择一个线程作为 "),t("code",[e._v("Acceptor")]),e._v(" 线程，绑定监听端口接收客户端的连接，其他线程负责后续的接入认证等工作。连接建立完成后，Sub NIO 线程池负责具体处理 I/O 读写。如果多线程模型无法满足需求，可以考虑使用主从多线程模型。")]),e._v(" "),t("div",{staticClass:"custom-block center"},[t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/07/31/LbNd4cTRja1SHvU.png",alt:"Netty主从多线程模型.png"}})])]),e._v(" "),t("h2",{attrs:{id:"netty-服务端的启动过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-服务端的启动过程"}},[e._v("#")]),e._v(" Netty 服务端的启动过程？")]),e._v(" "),t("ul",[t("li",[e._v("创建两个 "),t("code",[e._v("NioEventLoopGroup")]),e._v(" 对象实例："),t("code",[e._v("bossGroup")]),e._v(" 和 "),t("code",[e._v("workerGroup")])]),e._v(" "),t("li",[e._v("创建服务端启动引导/辅助类："),t("code",[e._v("ServerBootstrap")]),e._v("，这个类将引导服务端的启动工作")]),e._v(" "),t("li",[e._v("给引导类配置上面示例化的两大线程组，确定了线程模型")]),e._v(" "),t("li",[e._v("给引导类指定 I/O 模型为 NIO")]),e._v(" "),t("li",[e._v("给引导类指定 "),t("code",[e._v("ChannelInitializer")]),e._v("，指定 "),t("code",[e._v("ChannelPipeline")]),e._v(" 和 "),t("code",[e._v("ChannelHandler")]),e._v(" 的初始化方式")]),e._v(" "),t("li",[e._v("通过引导类绑定端口")])]),e._v(" "),t("h2",{attrs:{id:"netty-客户端的启动过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-客户端的启动过程"}},[e._v("#")]),e._v(" Netty 客户端的启动过程？")]),e._v(" "),t("ul",[t("li",[e._v("创建一个 "),t("code",[e._v("NioEventLoopGroup")]),e._v(" 对象")]),e._v(" "),t("li",[e._v("创建客户端启动引导类："),t("code",[e._v("Bootstrap")])]),e._v(" "),t("li",[e._v("给引导类 "),t("code",[e._v("Bootstrap")]),e._v(" 配置一个线程组")]),e._v(" "),t("li",[e._v("给引导类 "),t("code",[e._v("Bootstrap")]),e._v(" 指定了 I/O 模型为 NIO")]),e._v(" "),t("li",[e._v("给引导类配置 "),t("code",[e._v("ChannelInitializer")]),e._v("，指定 "),t("code",[e._v("ChannelPipeline")]),e._v(" 和 "),t("code",[e._v("ChannelHandler")]),e._v(" 的初始化方式")]),e._v(" "),t("li",[e._v("调用 "),t("code",[e._v("Bootstrap")]),e._v(" 类的 "),t("code",[e._v("connect()")]),e._v(" 方法进行连接，参数为 IP 地址和端口号")])]),e._v(" "),t("h2",{attrs:{id:"什么是-tcp-粘包-拆包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是-tcp-粘包-拆包"}},[e._v("#")]),e._v(" 什么是 TCP 粘包/拆包？")]),e._v(" "),t("p",[e._v("TCP 粘包/拆包指的：基于 TCP 发送数据的时候，出现了多个字符串“粘”在了一起或者一个字符串被“拆”开的问题。")]),e._v(" "),t("h2",{attrs:{id:"netty-怎么解决的-tcp-粘包-拆包问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-怎么解决的-tcp-粘包-拆包问题"}},[e._v("#")]),e._v(" Netty 怎么解决的 TCP 粘包/拆包问题？")]),e._v(" "),t("p",[e._v("使用 Netty 自带的解码器：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("LineBasedFrameDecoder")]),e._v("：发送端发送数据包的时候，每个数据包之间以换行符作为分隔，"),t("code",[e._v("LineBasedFrameDecoder")]),e._v(" 会遍历判断是否有换行符，然后进行相应的截取")]),e._v(" "),t("li",[t("code",[e._v("DelimiterBasedFrameDecoder")]),e._v("：自定义分隔符解码器，"),t("code",[e._v("LineBasedFrameDecoder")]),e._v(" 实际上是一种特殊的 "),t("code",[e._v("DelimiterBasedFrameDecoder")]),e._v(" 解码器")]),e._v(" "),t("li",[t("code",[e._v("FixedLengthFrameDecoder")]),e._v("：固定长度解码器，它能够按照指定的长度对消息进行相应的拆包")]),e._v(" "),t("li",[t("code",[e._v("LengthFieldBasedFrameDecoder")]),e._v("：自定义长度解码器")])]),e._v(" "),t("h2",{attrs:{id:"介绍一下-netty-的心跳机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-netty-的心跳机制"}},[e._v("#")]),e._v(" 介绍一下 Netty 的心跳机制？")]),e._v(" "),t("p",[e._v("在 TCP 保持长连接的过程中，可能会出现断网或者其他的引起网络异常的情况，在异常发生的时候，如果客户端与服务端之间没有交互的话，它们彼此是无法发现对方已经掉线的。为了解决这个问题, 需要引入心跳机制。")]),e._v(" "),t("p",[e._v("心跳机制的工作原理是：当客户端与服务端在一定时间内没有数据交互时，客户端或服务器就会发送一个特殊的数据包给对方，当接收方收到这个数据报文后，也立即发送一个特殊的数据报文进行回应。所以当某一端收到心跳消息后，就知道了对方仍然在线，确保了 TCP 连接的有效性。通过 Netty 实现心跳机制的核心类是 "),t("code",[e._v("IdleStateHandler")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"介绍一下-netty-的零拷贝机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-netty-的零拷贝机制"}},[e._v("#")]),e._v(" 介绍一下 Netty 的零拷贝机制？")]),e._v(" "),t("p",[e._v("在操作系统层面，"),t("strong",[e._v("零拷贝通常指避免在用户态与内核态之间来回拷贝数据")]),e._v("。而在 Netty 层面，零拷贝主要体现在对于数据操作的优化：")]),e._v(" "),t("ul",[t("li",[e._v("使用 Netty 提供的 "),t("code",[e._v("CompositeByteBuf")]),e._v(" 类, 可以将多个 "),t("code",[e._v("ByteBuf")]),e._v(" 合并为一个逻辑上的 "),t("code",[e._v("ByteBuf")]),e._v("，避免了各个 "),t("code",[e._v("ByteBuf")]),e._v(" 之间的拷贝")]),e._v(" "),t("li",[t("code",[e._v("ByteBuf")]),e._v(" 支持 "),t("code",[e._v("slice")]),e._v(" 操作，因此可以将 "),t("code",[e._v("ByteBuf")]),e._v(" 分解为多个共享同一个存储区域的 "),t("code",[e._v("ByteBuf")]),e._v("，避免了内存的拷贝")]),e._v(" "),t("li",[e._v("通过 "),t("code",[e._v("FileRegion")]),e._v(" 包装的 "),t("code",[e._v("FileChannel.transferTo")]),e._v(" 实现文件传输，可以直接将文件缓冲区的数据发送到目标 "),t("code",[e._v("Channel")]),e._v("，避免了传统通过循环 "),t("code",[e._v("write")]),e._v(" 方式导致的内存拷贝问题")])])])}),[],!1,null,null,null);v.default=o.exports}}]);