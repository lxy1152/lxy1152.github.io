(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{798:function(s,t,a){"use strict";a.r(t);var e=a(1),i=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"redis-集群有哪些方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-集群有哪些方式"}},[s._v("#")]),s._v(" Redis 集群有哪些方式？")]),s._v(" "),a("h3",{attrs:{id:"主从模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从模式"}},[s._v("#")]),s._v(" 主从模式")]),s._v(" "),a("p",[s._v("只需要在配置文件加上 "),a("code",[s._v("slaveof 192.169.x.x 6379")]),s._v("，指明主服务器的 IP 和端口号就会启动主从模式，主从模式下从服务器会自动模仿主服务器的操作并写入。")]),s._v(" "),a("h3",{attrs:{id:"哨兵模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[s._v("#")]),s._v(" 哨兵模式")]),s._v(" "),a("p",[s._v("给几台哨兵服务添加不同的端口，配置主服务器的 IP 和端口，并且加上权值，使用 Redis 命令："),a("code",[s._v("redis-server.exe redis-xx.conf --sentinel")]),s._v(" 启动哨兵。配置文件：")]),s._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("sentinel monitor master 127.0.0.1 28380 2 # 主服务器的IP和端口，后面的数字表示有多少个哨兵认为master失效，master才真正失效\nsentinel down-after-milliseconds master 5000 # 超过这个时间认为主服务器挂了\nsentinel failover-timeout master 30000 # 投票选举超时时间\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("h3",{attrs:{id:"集群模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#集群模式"}},[s._v("#")]),s._v(" 集群模式")]),s._v(" "),a("p",[s._v("修改配置文件：")]),s._v(" "),a("div",{staticClass:"language-text line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('port 7000 # 不同节点配置不同的端口\nlogfile "./redis.log" # 输出的日志\ndaemonize yes # 是否以守护进程的方式启动，如果是的话除非手动kill，否则不会关闭进程\n\ncluster-enable yes # 是否启用集群\ncluster-config-file nodes-7000.conf # 指定配置文件，每个节点需要指定不同的配置文件\ncluster-node-timeout 15000 # 集群超时时间\ncluster-require-full-coverage no # 集群不完整是否依然可以提供服务\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("h2",{attrs:{id:"介绍一下一致性哈希"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下一致性哈希"}},[s._v("#")]),s._v(" 介绍一下一致性哈希？")]),s._v(" "),a("p",[s._v("假设 Redis 集群中有三个节点，那么数据应该保存在哪个节点通常是由 "),a("code",[s._v("key % 3")]),s._v(" 计算得到的。如果希望新增一个节点，由于数量已经固定为 3，那么数据将永远不会落在第四个节点上。另外如果某个节点挂了，那么将不能写入、获取数据。所以需要通过一致性哈希算法来解决这个问题。")]),s._v(" "),a("p",[s._v("首先容量肯定不能固定，可以将容量设置为一个很大的数，比如："),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("msup",[a("mn",[s._v("2")]),a("mn",[s._v("31")])],1),a("mo",[s._v("−")]),a("mn",[s._v("1")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("2^{31} - 1")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.897438em","vertical-align":"-0.08333em"}}),a("span",{staticClass:"mord"},[a("span",{staticClass:"mord"},[s._v("2")]),a("span",{staticClass:"msupsub"},[a("span",{staticClass:"vlist-t"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[a("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[a("span",{staticClass:"mord mtight"},[s._v("31")])])])])])])])])]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),a("span",{staticClass:"mbin"},[s._v("−")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),a("span",{staticClass:"mord"},[s._v("1")])])])]),s._v("。数据在存储时对它求余，然后选取离结果最近的节点进行保存。在下面的图中，四个对象（ObjectA ~ ObjectD）就根据计算得到哈希值就近选择了要保存的节点：")]),s._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/07/31/96VTDlqONSGjaHp.png",alt:"一致性哈希.png"}})])]),s._v(" "),a("p",[s._v("但是在 Redis 中并没有使用这种方式，而是引入了哈希槽（slot）的概念。集群总共包含了 16384 个哈希槽，每个 "),a("code",[s._v("key")]),s._v(" 通过计算后都会落在一个具体的槽位上，而这个槽位具体属于哪个存储节点则由用户自己分配。比如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。通过哈希槽这种概念很好地解决了一致性哈希的弊端。")]),s._v(" "),a("p",[s._v("在容错性和扩展性上，哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。")]),s._v(" "),a("h2",{attrs:{id:"redis-的分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-的分布式锁"}},[s._v("#")]),s._v(" Redis 的分布式锁？"),a("Badge",{attrs:{text:"重点",type:"error"}})],1),s._v(" "),a("h3",{attrs:{id:"setnx"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setnx"}},[s._v("#")]),s._v(" SETNX")]),s._v(" "),a("p",[s._v("使用 "),a("code",[s._v("SET")]),s._v("、"),a("code",[s._v("SETNX")]),s._v(" （SETifNot eXists）等命令插入一条记录，其他客户端通过获取 "),a("code",[s._v("key")]),s._v(" 来判断是否可以获取锁。为了避免死锁，需要设置超时时间。")]),s._v(" "),a("h4",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[s._v("#")]),s._v(" "),a("strong",[s._v("优点")])]),s._v(" "),a("ul",[a("li",[s._v("Redis 性能很好")]),s._v(" "),a("li",[s._v("Redis 对命令的支持较好，实现起来比较方便")])]),s._v(" "),a("h4",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" "),a("strong",[s._v("缺点")])]),s._v(" "),a("ul",[a("li",[s._v("Redis 分布式锁，需要自己不断尝试去获取锁，比较消耗性能")]),s._v(" "),a("li",[s._v("Redis 获取锁的那个客户端如果挂了，只能等待超时时间后才能释放锁")])]),s._v(" "),a("h3",{attrs:{id:"redlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redlock"}},[s._v("#")]),s._v(" RedLock")]),s._v(" "),a("p",[s._v("假设现在有 5 个 Redis 节点，通过 RedLock 途径获取锁的过程如下：")]),s._v(" "),a("ol",[a("li",[s._v("获取当前 Unix 时间，以毫秒为单位")]),s._v(" "),a("li",[s._v("依次尝试从 5 个实例，使用相同的 "),a("code",[s._v("key")]),s._v(" 和具有唯一性的 value（例如 UUID）获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间（避免服务端已经挂了，客户端还在等待）")]),s._v(" "),a("li",[s._v("客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间，当且仅当从大多数（"),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mfrac",[a("mi",[s._v("N")]),a("mn",[s._v("2")])],1),a("mo",[s._v("+")]),a("mn",[s._v("1")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[s._v("\\frac N 2 +1")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1.217331em","vertical-align":"-0.345em"}}),a("span",{staticClass:"mord"},[a("span",{staticClass:"mopen nulldelimiter"}),a("span",{staticClass:"mfrac"},[a("span",{staticClass:"vlist-t vlist-t2"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.872331em"}},[a("span",{staticStyle:{top:"-2.6550000000000002em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[a("span",{staticClass:"mord mtight"},[s._v("2")])])])]),a("span",{staticStyle:{top:"-3.23em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),a("span",{staticClass:"frac-line",staticStyle:{"border-bottom-width":"0.04em"}})]),a("span",{staticStyle:{top:"-3.394em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[a("span",{staticClass:"mord mathnormal mtight",staticStyle:{"margin-right":"0.10903em"}},[s._v("N")])])])])]),a("span",{staticClass:"vlist-s"},[s._v("​")])]),a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.345em"}},[a("span")])])])]),a("span",{staticClass:"mclose nulldelimiter"})]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),a("span",{staticClass:"mbin"},[s._v("+")]),a("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),a("span",{staticClass:"mord"},[s._v("1")])])])]),s._v("，这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功")]),s._v(" "),a("li",[s._v("如果取到了锁，"),a("code",[s._v("key")]),s._v(" 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 的时间）")]),s._v(" "),a("li",[s._v("如果因为某些原因，获取锁失败（超时或者达不到大多数节点的要求），那么就需要在所有的 Redis 节点上进行解锁")])])])}),[],!1,null,null,null);t.default=i.exports}}]);