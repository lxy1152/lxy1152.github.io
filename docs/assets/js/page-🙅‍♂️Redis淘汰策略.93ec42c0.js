(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{798:function(e,s,t){"use strict";t.r(s);var v=t(1),_=Object(v.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"redis-的删除策略有哪些"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-的删除策略有哪些"}},[e._v("#")]),e._v(" Redis 的删除策略有哪些？")]),e._v(" "),t("p",[e._v("Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。对于散列表这种容器，只能为整个散列表设置过期时间，而不能为键里面的某个元素设置过期时间。")]),e._v(" "),t("div",{staticClass:"language-text line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("127.0.0.1:6379> exp key  60 # 数据在 60s 后过期\n(integer) 1\n127.0.0.1:6379> setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)\nOK\n127.0.0.1:6379> ttl key # 查看数据还有多久过期\n(integer) 56\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br")])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("过期命令")]),e._v(" "),t("p",[e._v("Redis 中除了字符串类型有自己独有设置过期时间的命令 "),t("code",[e._v("setex")]),e._v(" （set + ex）外，其他方法都需要依靠 "),t("code",[e._v("expire")]),e._v(" 命令来设置过期时间，使用 "),t("code",[e._v("persist")]),e._v(" 命令可以移除一个键的过期时间。")])]),e._v(" "),t("p",[e._v("当时间到时，Redis 将如何删除这些值呢？常用的过期数据的删除策略就两个：")]),e._v(" "),t("ul",[t("li",[e._v("惰性删除：只会在取出 "),t("code",[e._v("key")]),e._v(" 的时候才对数据进行过期检查，这样对 CPU 最友好，但是可能会造成太多过期 "),t("code",[e._v("key")]),e._v(" 没有被删除")]),e._v(" "),t("li",[e._v("定期删除：每隔一段时间抽取一批 "),t("code",[e._v("key")]),e._v(" 执行删除过期 "),t("code",[e._v("key")]),e._v(" 的操作，并且 Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响")])]),e._v(" "),t("p",[e._v("定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有优劣，所以 Redis 采用的是定期删除 + 惰性删除。但是仅仅通过给 "),t("code",[e._v("key")]),e._v(" 设置过期时间还是有问题的，因为还是可能存在漏掉很多过期 "),t("code",[e._v("key")]),e._v(" 的情况。这样就导致大量过期 "),t("code",[e._v("key")]),e._v(" 堆积在内存里，然后就 "),t("code",[e._v("Out of memory")]),e._v(" 了。这个问题的解决方案是数据淘汰机制。")]),e._v(" "),t("h2",{attrs:{id:"有哪些更新-淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有哪些更新-淘汰策略"}},[e._v("#")]),e._v(" 有哪些更新/淘汰策略？")]),e._v(" "),t("p",[e._v("在 Redis 中可以设置最大使用量，当内存使用量超出时，会根据数据淘汰策略对数据进行淘汰。Redis 有 6 种淘汰策略：")]),e._v(" "),t("ul",[t("li",[e._v("volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰")]),e._v(" "),t("li",[e._v("volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰")]),e._v(" "),t("li",[e._v("volatile-random：从已设置过期时间的数据集中任意选择数据淘汰")]),e._v(" "),t("li",[e._v("allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰")]),e._v(" "),t("li",[e._v("allkeys-random：从所有数据集中任意选择数据进行淘汰")]),e._v(" "),t("li",[e._v("noeviction：禁止驱逐数据")])]),e._v(" "),t("p",[e._v("作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 "),t("code",[e._v("key")]),e._v("，而是抽样一小部分并且从中选出被淘汰的 "),t("code",[e._v("key")]),e._v("。使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。")]),e._v(" "),t("p",[e._v("Redis 4.0 中引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对（最近一次被访问次数最少的数据）淘汰。")])])}),[],!1,null,null,null);s.default=_.exports}}]);