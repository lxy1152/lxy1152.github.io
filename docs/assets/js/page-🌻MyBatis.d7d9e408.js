(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{714:function(e,v,_){"use strict";_.r(v);var t=_(1),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"xml-配置文件中常用的标签有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#xml-配置文件中常用的标签有哪些"}},[e._v("#")]),e._v(" XML 配置文件中常用的标签有哪些？")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("select")]),e._v("/"),_("code",[e._v("insert")]),e._v("/"),_("code",[e._v("update")]),e._v("/"),_("code",[e._v("delete")]),e._v("：对应这四种 SQL 语句")]),e._v(" "),_("li",[_("code",[e._v("sql")]),e._v("：可被其他语句引用的可重用语句块，比如表字段")]),e._v(" "),_("li",[_("code",[e._v("include")]),e._v("：引用代码片段")]),e._v(" "),_("li",[_("code",[e._v("parameterType")]),e._v("：限定参数类型")]),e._v(" "),_("li",[_("code",[e._v("resultType")]),e._v("：限定返回结果类型")]),e._v(" "),_("li",[_("code",[e._v("resultMap")]),e._v("：结果集映射")])]),e._v(" "),_("p",[e._v("另外还有动态 sql 标签："),_("code",[e._v("trim")]),e._v("、"),_("code",[e._v("where")]),e._v("、"),_("code",[e._v("set")]),e._v("、"),_("code",[e._v("foreach")]),e._v("、"),_("code",[e._v("if")]),e._v("、"),_("code",[e._v("choose")]),e._v("、"),_("code",[e._v("when")]),e._v("、"),_("code",[e._v("otherwise")]),e._v("、"),_("code",[e._v("bind")]),e._v("。")]),e._v(" "),_("h2",{attrs:{id:"mybatis-的动态-sql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-的动态-sql"}},[e._v("#")]),e._v(" MyBatis 的动态 SQL？")]),e._v(" "),_("p",[e._v("Mybatis 动态 SQL 可以让开发人员在 XML 配置文件中，以标签的形式编写动态 SQL，完成逻辑判断和动态拼接 SQL 的功能，Mybatis 提供了 9 种动态 sql 标签："),_("code",[e._v("trim")]),e._v("，"),_("code",[e._v("where")]),e._v("，"),_("code",[e._v("set")]),e._v("，"),_("code",[e._v("foreach")]),e._v("，"),_("code",[e._v("if")]),e._v("，"),_("code",[e._v("choose")]),e._v("，"),_("code",[e._v("when")]),e._v("，"),_("code",[e._v("otherwise")]),e._v("，"),_("code",[e._v("bind")]),e._v("。")]),e._v(" "),_("p",[e._v("执行原理为，使用 OGNL 从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL。")]),e._v(" "),_("h2",{attrs:{id:"和-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别"}},[e._v("#")]),e._v(" #{} 和 ${} 的区别？"),_("Badge",{attrs:{text:"重点",type:"error"}})],1),e._v(" "),_("ul",[_("li",[_("code",[e._v("${}")]),e._v(" 是 Properties 文件中的变量占位符，它可以用于标签属性值和 SQL 内部，属于静态文本替换，比如 "),_("code",[e._v("${driver}")]),e._v(" 会被静态替换为 "),_("code",[e._v("com.mysql.jdbc.Drive")])]),e._v(" "),_("li",[_("code",[e._v("#{}")]),e._v(" 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 "),_("code",[e._v("#{}")]),e._v(" 替换为 "),_("code",[e._v("?")]),e._v("，在 sql 执行前会使用 "),_("code",[e._v("PreparedStatement")]),e._v(" 的参数设置方法，按序给 SQL 中的 "),_("code",[e._v("?")]),e._v(" 设置参数值，比如 "),_("code",[e._v("ps.setInt(0, parameterValue)")]),e._v("，可以解决 SQL 注入攻击问题")])]),e._v(" "),_("h2",{attrs:{id:"mybatis-是如何将结果封装为对象的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-是如何将结果封装为对象的"}},[e._v("#")]),e._v(" MyBatis 是如何将结果封装为对象的？")]),e._v(" "),_("ol",[_("li",[e._v("通过 "),_("code",[e._v("<resultMap>")]),e._v(" 标签，逐一定义列名和对象属性名之间的映射关系")]),e._v(" "),_("li",[e._v("使用 SQL 列的别名功能，将列别名书写为对象属性名，比如 "),_("code",[e._v("T_NAME AS NAME")]),e._v("。尽管对象属性名一般是小写，但是 Mybatis 会忽略列名的大小写，智能找到与之对应对象属性名，甚至可以写成 "),_("code",[e._v("T_NAME AS NaMe")]),e._v("，Mybatis 一样可以正常工作")])]),e._v(" "),_("p",[e._v("有了列名与属性名的映射关系后，Mybatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。")]),e._v(" "),_("h2",{attrs:{id:"介绍一下-mapper-接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下-mapper-接口"}},[e._v("#")]),e._v(" 介绍一下 Mapper 接口？")]),e._v(" "),_("p",[e._v("Mapper 接口会对应一个配置文件，这个配置文件中 "),_("code",[e._v("namespace")]),e._v(" 的值，就是接口的全限定名。接口中的方法名，就是配置文件中 "),_("code",[e._v("MappedStatement")]),e._v(" 的 id 值，接口方法内的参数，就是传递给 SQL 的参数。")]),e._v(" "),_("p",[e._v("Mapper 接口是不需要给出实现类的，当调用接口方法时，接口全限定名 + 方法名拼接字符串作为 "),_("code",[e._v("key")]),e._v(" 值，可唯一定位一个 "),_("code",[e._v("MappedStatement")]),e._v("，比如根据 "),_("code",[e._v("mypackage.dao.findUserById")]),e._v("，可以唯一找到 "),_("code",[e._v("namespace")]),e._v(" 为 "),_("code",[e._v("mypackage.dao")]),e._v(" 下面 "),_("code",[e._v("id = findUserById")]),e._v(" 的 "),_("code",[e._v("MappedStatement")]),e._v("。")]),e._v(" "),_("p",[e._v("在运行时，MyBatis 利用 JDK 动态代理，为接口生成代理对象，代理对象会拦截接口方法，转而执行 "),_("code",[e._v("MappedStatement")]),e._v(" 所代表的 SQL，然后将 SQL 执行结果返回。")]),e._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[e._v("MappedStatement")]),e._v(" "),_("p",[e._v("在 Mybatis 中，每一个 "),_("code",[e._v("<select>")]),e._v("、"),_("code",[e._v("<insert>")]),e._v("、"),_("code",[e._v("<update>")]),e._v("、"),_("code",[e._v("<delete>")]),e._v(" 标签，都会被解析为一个 "),_("code",[e._v("MappedStatement")]),e._v(" 对象。")])]),e._v(" "),_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[e._v("方法不能重载")]),e._v(" "),_("p",[e._v("这个接口中的方法，是不能重载的，因为是根据全限定名 + 方法名的策略来寻找的。")])]),e._v(" "),_("h2",{attrs:{id:"mybatis-插件机制的原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-插件机制的原理"}},[e._v("#")]),e._v(" MyBatis 插件机制的原理？")]),e._v(" "),_("p",[e._v("Mybatis 仅可以编写针对 "),_("code",[e._v("ParameterHandler")]),e._v("、"),_("code",[e._v("ResultSetHandler")]),e._v("、"),_("code",[e._v("StatementHandler")]),e._v("、"),_("code",[e._v("Executor")]),e._v(" 这 4 种接口的插件。Mybatis 使用 JDK 动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法。")]),e._v(" "),_("p",[e._v("实现 Mybatis 的 "),_("code",[e._v("Interceptor")]),e._v(" 接口并重写 "),_("code",[e._v("intercept()")]),e._v(" 方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法就可以实现一个插件了，不要忘了在配置文件中配置上编写的插件。")]),e._v(" "),_("h2",{attrs:{id:"mybatis-的分页机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-的分页机制"}},[e._v("#")]),e._v(" MyBatis 的分页机制？")]),e._v(" "),_("p",[e._v("Mybatis 使用 "),_("code",[e._v("RowBounds")]),e._v(" 对象进行分页，它是针对 "),_("code",[e._v("ResultSet")]),e._v(" 结果集执行的内存分页，而非物理分页，可以在 SQL 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。")]),e._v(" "),_("p",[e._v("分页插件的基本原理是使用 Mybatis 提供的插件接口实现自定义插件，在插件的拦截方法内拦截待执行的 SQL 并重写，添加对应的物理分页语句和物理分页参数。")]),e._v(" "),_("p",[e._v("举例："),_("code",[e._v("select _ from student")]),e._v("，拦截 SQL 后重写为："),_("code",[e._v("select t._ from (select * from student) t limit 0, 10")]),e._v("。")])])}),[],!1,null,null,null);v.default=a.exports}}]);