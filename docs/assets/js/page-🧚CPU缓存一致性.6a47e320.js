(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{788:function(a,t,e){"use strict";e.r(t);var s=e(1),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"cpu-缓存的结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu-缓存的结构"}},[a._v("#")]),a._v(" CPU 缓存的结构")]),a._v(" "),e("h3",{attrs:{id:"cpu-缓存的结构是怎么样的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu-缓存的结构是怎么样的"}},[a._v("#")]),a._v(" CPU 缓存的结构是怎么样的？")]),a._v(" "),e("p",[a._v("CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度越快，但是存储容量相对就会越小。在多核心的 CPU 中，每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的。")]),a._v(" "),e("div",{staticClass:"custom-block center"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/08/01/DoZ3wJXFTiG2LQe.png",alt:"cpu缓存结构.png"}})])]),a._v(" "),e("h2",{attrs:{id:"cpu-缓存的数据写入"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu-缓存的数据写入"}},[a._v("#")]),a._v(" CPU 缓存的数据写入")]),a._v(" "),e("h3",{attrs:{id:"什么是写直达策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是写直达策略"}},[a._v("#")]),a._v(" 什么是写直达策略？")]),a._v(" "),e("p",[a._v("写直达策略会把数据同时写入缓存和内存，这种方法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响（相比缓存的读写速度而言内存的读写速度是相当慢了）。")]),a._v(" "),e("h3",{attrs:{id:"什么是写回策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是写回策略"}},[a._v("#")]),a._v(" 什么是写回策略？")]),a._v(" "),e("p",[a._v("因为写直达每次都有写操作将数据写回到内存，而影响性能，为了减少数据写回内存的频率，就出现了写回（Write Back）策略。在写回策略中，当发生写操作时，新的数据仅仅被写入到缓存中，只有当修改过的缓存要被替换时才会将数据写到内存中，减少了数据写回内存的频率，这样可以提高系统的性能。")]),a._v(" "),e("div",{staticClass:"custom-block center"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/08/01/T9PcnLg3krKCEwQ.png",alt:"写回策略.jpg"}})])]),a._v(" "),e("p",[a._v("可以发现写回策略在把数据写入到缓存的时候，只有在缓存不命中同时数据对应的缓存中的缓存块为脏的情况下，才会将数据写到内存中；在缓存命中的情况下，只需把该数据对应的缓存块标记为脏，不需要写到内存里。\n这样的好处是：如果大量的操作都能够命中缓存，那么在大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。")]),a._v(" "),e("h2",{attrs:{id:"缓存一致性问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存一致性问题"}},[a._v("#")]),a._v(" 缓存一致性问题")]),a._v(" "),e("h3",{attrs:{id:"什么是缓存一致性问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存一致性问题"}},[a._v("#")]),a._v(" 什么是缓存一致性问题？")]),a._v(" "),e("p",[a._v("由于 L1/L2 Cache 是多个核心各自独有的，那么就可能引发多核心的缓存一致性（Cache Coherence）问题，即多核心下不同缓存内的数据需要保持一致。下面是一个含有两核心的 CPU，假设 A 号核心和 B 号核心同时运行两个线程，都操作内存中共同的变量 i（初始值为 0 ），写策略为写回策略。")]),a._v(" "),e("p",[a._v("如果 A 号核心执行了 i++ 语句，会把值为 1 的执行结果写入到 L1/L2 Cache 中，然后把 L1/L2 Cache 中对应的 Block 标记为脏的，这个时候数据是没有被同步到内存中的。如果这时 B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0，会导致执行结果的错误。")]),a._v(" "),e("div",{staticClass:"custom-block center"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/08/01/HMdKVBuO7CqGD6n.png",alt:"缓存一致性问题举例.png"}})])]),a._v(" "),e("h3",{attrs:{id:"如何保证数据一致"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何保证数据一致"}},[a._v("#")]),a._v(" 如何保证数据一致？")]),a._v(" "),e("ul",[e("li",[a._v("写传播（Wreite Propagation）：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的缓存")]),a._v(" "),e("li",[a._v("事务的串形化（Transaction Serialization）：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的")])]),a._v(" "),e("h3",{attrs:{id:"什么是总线嗅探机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是总线嗅探机制"}},[a._v("#")]),a._v(" 什么是总线嗅探机制？")]),a._v(" "),e("p",[a._v("一种比较简单的实现写传播原则的方式是使用总线嗅探，CPU 需要每时每刻监听总线上的一切活动，只要有某个核心修改了值就会通知其他所有的核心进行更新。不管别的核心的 Cache 是否缓存相同的数据，都会发出一个广播事件，这无疑会加重总线的负载。")]),a._v(" "),e("p",[a._v("另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。于是，有一个协议基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。")]),a._v(" "),e("h3",{attrs:{id:"什么是-mesi-协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-mesi-协议"}},[a._v("#")]),a._v(" 什么是 MESI 协议？")]),a._v(" "),e("p",[a._v("MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：")]),a._v(" "),e("h4",{attrs:{id:"modified"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#modified"}},[a._v("#")]),a._v(" Modified")]),a._v(" "),e("p",[a._v("已修改状态，就是前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。")]),a._v(" "),e("h4",{attrs:{id:"exclusive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#exclusive"}},[a._v("#")]),a._v(" Exclusive")]),a._v(" "),e("p",[a._v("独占状态，此时数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。同时这个状态代表这个缓存中的数据是干净的。如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候独占状态下的数据就会变成共享状态。")]),a._v(" "),e("h4",{attrs:{id:"shared"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#shared"}},[a._v("#")]),a._v(" Shared")]),a._v(" "),e("p",[a._v("共享状态，代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当需要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为无效状态，然后再更新当前 Cache 里面的数据。")]),a._v(" "),e("h4",{attrs:{id:"invalidated"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#invalidated"}},[a._v("#")]),a._v(" Invalidated")]),a._v(" "),e("p",[a._v("已失效状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。")]),a._v(" "),e("p",[a._v("MESI 状态转移图：")]),a._v(" "),e("div",{staticClass:"custom-block center"},[e("p",[e("img",{attrs:{src:"https://i.loli.net/2021/08/01/Yf2Imakg91WQ84L.png",alt:"MESI.png"}})])])])}),[],!1,null,null,null);t.default=r.exports}}]);