(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{773:function(t,s,a){"use strict";a.r(s);var i=a(1),v=Object(i.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"已经有了流量控制-为什么还需要拥塞控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#已经有了流量控制-为什么还需要拥塞控制"}},[t._v("#")]),t._v(" 已经有了流量控制，为什么还需要拥塞控制？")]),t._v(" "),a("p",[t._v("流量控制是避免发送方的数据填满接收方的缓存，但是并不知道网络的中发生了什么。有可能会因为其他主机之间的通信使得网络拥堵。")]),t._v(" "),a("p",[t._v("在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大。所以当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量，即拥塞控制机制，控制的目的是避免发送方的数据填满整个网络。")]),t._v(" "),a("p",[t._v("为了在发送方调节所要发送数据的量，需要引入拥塞窗口的概念。")]),t._v(" "),a("h2",{attrs:{id:"什么是拥塞窗口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是拥塞窗口"}},[t._v("#")]),t._v(" 什么是拥塞窗口？")]),t._v(" "),a("p",[t._v("拥塞窗口 cwnd 是发送方维护的一个的状态变量，它会根据网络的拥塞程度动态变化的。在前面提到过发送窗口 swnd 和接收窗口 rwnd 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是 "),a("code",[t._v("swnd = min(cwnd, rwnd)")]),t._v("，也就是拥塞窗口和接收窗口中的最小值。")]),t._v(" "),a("p",[t._v("拥塞窗口 cwnd 变化的规则：")]),t._v(" "),a("ul",[a("li",[t._v("只要网络中没有出现拥塞，cwnd 就会增大")]),t._v(" "),a("li",[t._v("如果网络中出现了拥塞，cwnd 就减少")])]),t._v(" "),a("h2",{attrs:{id:"怎么判断是否出现了拥塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么判断是否出现了拥塞"}},[t._v("#")]),t._v(" 怎么判断是否出现了拥塞？")]),t._v(" "),a("p",[t._v("只要发送方没有在规定时间内接收到 ACK 应答报文，也就是发生了超时重传，就会认为网络出现了拥塞。")]),t._v(" "),a("h2",{attrs:{id:"tcp-拥塞控制机制有哪几种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-拥塞控制机制有哪几种"}},[t._v("#")]),t._v(" TCP 拥塞控制机制有哪几种？")]),t._v(" "),a("ul",[a("li",[t._v("慢启动")]),t._v(" "),a("li",[t._v("拥塞避免")]),t._v(" "),a("li",[t._v("拥塞发生")]),t._v(" "),a("li",[t._v("快速恢复")])]),t._v(" "),a("h2",{attrs:{id:"介绍一下慢启动机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下慢启动机制"}},[t._v("#")]),t._v(" 介绍一下慢启动机制？")]),t._v(" "),a("p",[t._v("TCP 在刚建立连接完成后，首先有一个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，不要一上来就发大量的数据。")]),t._v(" "),a("p",[t._v("对于慢启动机制，记住一个规则：发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。")]),t._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/08/01/RmCbFT1xfqMiAU8.png",alt:"慢启动.png"}})])]),t._v(" "),a("h2",{attrs:{id:"慢启动机制的拥塞窗口难道会无限增长"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#慢启动机制的拥塞窗口难道会无限增长"}},[t._v("#")]),t._v(" 慢启动机制的拥塞窗口难道会无限增长？")]),t._v(" "),a("p",[t._v("拥塞窗口不会无限增加，有一个叫慢启动门限 ssthresh （slow start threshold）的状态变量：")]),t._v(" "),a("ul",[a("li",[t._v("当 cwnd < ssthresh 时，使用慢启动算法")]),t._v(" "),a("li",[t._v("当 cwnd > ssthresh 时，就会使用拥塞避免算法")]),t._v(" "),a("li",[t._v("相等时，使用哪个都可以")])]),t._v(" "),a("h2",{attrs:{id:"介绍一下拥塞避免机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下拥塞避免机制"}},[t._v("#")]),t._v(" 介绍一下拥塞避免机制？")]),t._v(" "),a("p",[t._v("当拥塞窗口 cwnd 超过慢启动门限 ssthresh 后就会进入拥塞避免算法。一般来说 ssthresh 的大小是 65535 字节。当进入拥塞避免算法后，它的规则是：每收到一个 ACK 时，cwnd 增加 1/cwnd。")]),t._v(" "),a("p",[t._v("比如当前的慢启动门限是 8，每个 ACK 都会使拥塞窗口增加 "),a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mfrac",[a("mn",[t._v("1")]),a("mn",[t._v("8")])],1)],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("\\frac18")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1.190108em","vertical-align":"-0.345em"}}),a("span",{staticClass:"mord"},[a("span",{staticClass:"mopen nulldelimiter"}),a("span",{staticClass:"mfrac"},[a("span",{staticClass:"vlist-t vlist-t2"},[a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.845108em"}},[a("span",{staticStyle:{top:"-2.6550000000000002em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[a("span",{staticClass:"mord mtight"},[t._v("8")])])])]),a("span",{staticStyle:{top:"-3.23em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),a("span",{staticClass:"frac-line",staticStyle:{"border-bottom-width":"0.04em"}})]),a("span",{staticStyle:{top:"-3.394em"}},[a("span",{staticClass:"pstrut",staticStyle:{height:"3em"}}),a("span",{staticClass:"sizing reset-size6 size3 mtight"},[a("span",{staticClass:"mord mtight"},[a("span",{staticClass:"mord mtight"},[t._v("1")])])])])]),a("span",{staticClass:"vlist-s"},[t._v("​")])]),a("span",{staticClass:"vlist-r"},[a("span",{staticClass:"vlist",staticStyle:{height:"0.345em"}},[a("span")])])])]),a("span",{staticClass:"mclose nulldelimiter"})])])])]),t._v("，所以这种机制会使拥塞窗口的增长趋势变为线性增长。")]),t._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/08/01/A82vHapIMZ9gTtd.png",alt:"拥塞避免.png"}})])]),t._v(" "),a("p",[t._v("就一直按照这么趋势增长后，网络就会慢慢进入拥塞的状况，可能就会出现丢包现象，这时就需要对丢失的数据包进行重传。")]),t._v(" "),a("p",[t._v("当触发了重传机制，也就进入了拥塞发生算法。")]),t._v(" "),a("h2",{attrs:{id:"介绍一下拥塞发生机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下拥塞发生机制"}},[t._v("#")]),t._v(" 介绍一下拥塞发生机制？")]),t._v(" "),a("p",[t._v("当发生拥塞时，会触发数据重传，重传机制主要有：")]),t._v(" "),a("ul",[a("li",[t._v("超时重传机制")]),t._v(" "),a("li",[t._v("快速重传机制")])]),t._v(" "),a("p",[t._v("对于这两种不同的重传机制，拥塞发生机制的处理方式也不一样。")]),t._v(" "),a("h2",{attrs:{id:"介绍一下超时重传机制的拥塞发生机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下超时重传机制的拥塞发生机制"}},[t._v("#")]),t._v(" 介绍一下超时重传机制的拥塞发生机制？")]),t._v(" "),a("p",[t._v("当发生了超时重传时，ssthresh 和 cwnd 的值会发生变化：")]),t._v(" "),a("ul",[a("li",[t._v("ssthresh 会设为 cwnd/2")]),t._v(" "),a("li",[t._v("cwnd 会重置为 1")])]),t._v(" "),a("p",[t._v("由于 cwnd 被重置为 1，所以会以慢启动方式重新开始。所以这种方式非常激进，反应也很强烈，会造成网络卡顿。")]),t._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/08/01/PsFLbC17al34Nd5.png",alt:"超时重传拥塞发生.png"}})])]),t._v(" "),a("h2",{attrs:{id:"介绍一下快速重传机制的拥塞发生机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下快速重传机制的拥塞发生机制"}},[t._v("#")]),t._v(" 介绍一下快速重传机制的拥塞发生机制？")]),t._v(" "),a("p",[t._v("快速重传机制是：当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分包没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下，同时进入快速恢复算法：")]),t._v(" "),a("ul",[a("li",[t._v("cwnd = cwnd/2 ，也就是设置为原来的一半")]),t._v(" "),a("li",[t._v("ssthresh = cwnd")])]),t._v(" "),a("h2",{attrs:{id:"介绍一下快速恢复机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下快速恢复机制"}},[t._v("#")]),t._v(" 介绍一下快速恢复机制？")]),t._v(" "),a("p",[t._v("快速恢复算法认为，既然还能收到 3 个重复 ACK 说明网络也不是那么坏，所以没有必要像超时重传一样反应的那么激烈。此时 ssthresh 和 cwnd 变化如下：")]),t._v(" "),a("ul",[a("li",[t._v("cwnd = cwnd/2 ，也就是设置为原来的一半")]),t._v(" "),a("li",[t._v("ssthresh = cwnd")])]),t._v(" "),a("p",[t._v("快速恢复机制的操作如下：")]),t._v(" "),a("ul",[a("li",[t._v("拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）")]),t._v(" "),a("li",[t._v("重传丢失的数据包")]),t._v(" "),a("li",[t._v("如果再收到重复的 ACK，那么 cwnd 增加 1")]),t._v(" "),a("li",[t._v("如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从重复 ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态")])]),t._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/08/01/u7NqgSlxc91Pbyn.png",alt:"快速恢复.png"}})])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/08/01/zQwsiRLWn9r7ZgH.png",alt:"拥塞控制总结.png"}})])])])}),[],!1,null,null,null);s.default=v.exports}}]);