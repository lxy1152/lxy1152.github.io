(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{731:function(t,r,v){"use strict";v.r(r);var _=v(1),i=Object(_.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"为什么-string-对象是不可变的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么-string-对象是不可变的"}},[t._v("#")]),t._v(" 为什么 String 对象是不可变的？")]),t._v(" "),v("p",[t._v("不可变是指一个 "),v("code",[t._v("String")]),t._v(" 对象被创建后，这个对象就不允许再被修改。实现不可变性的关键在于：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("String")]),t._v(" 类被声明为 "),v("code",[t._v("final")]),t._v("，因此它不可被继承")]),t._v(" "),v("li",[v("code",[t._v("String")]),t._v(" 类内部通过一个 "),v("code",[t._v("char")]),t._v(" 型数组来保存数据，这个数组同样被声明为 "),v("code",[t._v("final")]),t._v("，因此不能直接修改保存的数据")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("String 类设计为不可变的原因")]),t._v(" "),v("ol",[v("li",[t._v("因为不可变，所以哈希值是不变的，这样就可以缓存哈希值")]),t._v(" "),v("li",[t._v("可以在 String Pool 中缓存")]),t._v(" "),v("li",[t._v("不可变性使得它一定是线程安全的")])])]),t._v(" "),v("h2",{attrs:{id:"了解字符串池-string-pool-吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#了解字符串池-string-pool-吗"}},[t._v("#")]),t._v(" 了解字符串池（String pool）吗？"),v("Badge",{attrs:{text:"重点",type:"error"}})],1),t._v(" "),v("p",[t._v("JVM 为了提升性能和减少内存开销，避免字符串的重复创建，维护了一块特殊的内存空间，叫做字符串池（String Pool）。")]),t._v(" "),v("h3",{attrs:{id:"采用字面值赋值"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#采用字面值赋值"}},[t._v("#")]),t._v(" 采用字面值赋值")]),t._v(" "),v("p",[t._v("如果通过 "),v("code",[t._v('String a = "abc"')]),t._v(" 的方式来获得一个新的字符串，那么会自动的将 "),v("code",[t._v("abc")]),t._v(" 保存到字符串池中。")]),t._v(" "),v("h3",{attrs:{id:"通过-new-关键字新建对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#通过-new-关键字新建对象"}},[t._v("#")]),t._v(" 通过 new 关键字新建对象")]),t._v(" "),v("p",[t._v("如果通过 "),v("code",[t._v("new")]),t._v(" 来获取新的字符串，那么程序总是会在堆上创建一个新的对象（同时如果字符串池中没有这个字符串，那么还要在字符串池中创建一个字符串对象），所以这个步骤会创建两个对象。如果通过 "),v("code",[t._v("==")]),t._v(" 进行比较，那么它们一定是不等的。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("String.intern()")]),t._v(" "),v("p",[t._v("除了上述两种方式，还可以调用 "),v("code",[t._v("String")]),t._v(" 类中的 "),v("code",[t._v("intern()")]),t._v(" 方法从字符串池中获取一个字符串的引用，如果字符串池中不存在这个字符串，那么首先会把它保存起来再返回。")])]),t._v(" "),v("h2",{attrs:{id:"讲一下-string-stringbuilder-和-stringbuffer-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#讲一下-string-stringbuilder-和-stringbuffer-的区别"}},[t._v("#")]),t._v(" 讲一下 String，StringBuilder 和 StringBuffer 的区别？")]),t._v(" "),v("h3",{attrs:{id:"可变性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#可变性"}},[t._v("#")]),t._v(" 可变性")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("String")]),t._v(" 不可变")]),t._v(" "),v("li",[v("code",[t._v("StringBuilder")]),t._v(" 和 "),v("code",[t._v("StringBuffer")]),t._v(" 均可变")])]),t._v(" "),v("h3",{attrs:{id:"线程安全"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[t._v("#")]),t._v(" 线程安全")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("String")]),t._v(" 因为不可变，所以是线程安全的")]),t._v(" "),v("li",[v("code",[t._v("StringBuilder")]),t._v(" 不是线程安全的")]),t._v(" "),v("li",[v("code",[t._v("StringBuffer")]),t._v(" 是线程安全的，因为使用了 synchronized 关键字（在方法上加锁）")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("StringBuilder 和 StringBuffer 的区别和联系")]),t._v(" "),v("p",[v("code",[t._v("StringBuilder")]),t._v(" 和 "),v("code",[t._v("StringBuffer")]),t._v(" 都继承自 "),v("code",[t._v("AbstractStringBuilder")]),t._v("，区别在于是否使用了 "),v("code",[t._v("synchronized")]),t._v("。")]),t._v(" "),v("p",[t._v("另外它们重写的 "),v("code",[t._v("toString()")]),t._v(" 方法都是通过 "),v("code",[t._v("new String()")]),t._v(" 的方式来返回一个新的字符串，所以在比较时是不相等的。")])])])}),[],!1,null,null,null);r.default=i.exports}}]);