(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{787:function(t,v,_){"use strict";_.r(v);var a=_(1),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"什么是滑动窗口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是滑动窗口"}},[t._v("#")]),t._v(" 什么是滑动窗口？")]),t._v(" "),_("p",[t._v("TCP 是每发送一个数据，都要进行一次确认应答，当上一个数据包返回了应答，再发送下一个。所以一个显而易见的缺点是：数据包的往返时间越长，通信的效率就越低。")]),t._v(" "),_("p",[t._v("为了解决这个问题，TCP 引入了窗口的概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。有了窗口，就可以指定窗口大小，窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。")]),t._v(" "),_("p",[t._v("假设窗口大小为 3 个 TCP 段，那么发送方就可以连续发送 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过下一个确认应答进行确认。这个模式就叫累计确认或者累计应答。如下图：")]),t._v(" "),_("div",{staticClass:"custom-block center"},[_("p",[_("img",{attrs:{src:"https://i.loli.net/2021/08/01/pQjCfX4LJiUlsqy.png",alt:"tcp滑动窗口.png"}})])]),t._v(" "),_("h2",{attrs:{id:"窗口大小由哪一方决定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#窗口大小由哪一方决定"}},[t._v("#")]),t._v(" 窗口大小由哪一方决定？")]),t._v(" "),_("p",[t._v("TCP 头里有一个字段叫 Window，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。所以，通常窗口的大小是由接收方的窗口大小来决定的，发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。")]),t._v(" "),_("h2",{attrs:{id:"接收窗口和发送窗口的大小是相等的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接收窗口和发送窗口的大小是相等的吗"}},[t._v("#")]),t._v(" 接收窗口和发送窗口的大小是相等的吗？")]),t._v(" "),_("p",[t._v("并不是完全相等，接收窗口的大小是约等于发送窗口的大小的。因为滑动窗口并不是一成不变的。比如，当接收方的应用进程读取数据的速度非常快的话，这样的话接收窗口可以很快的就空缺出来。那么新的接收窗口大小，是通过 TCP 报文中的 Window 字段来告诉发送方的，这个传输过程是存在时延的，所以接收窗口和发送窗口是约等于的关系。")]),t._v(" "),_("h2",{attrs:{id:"tcp-是如何进行流量控制的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-是如何进行流量控制的"}},[t._v("#")]),t._v(" TCP 是如何进行流量控制的？")]),t._v(" "),_("p",[t._v("发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP 提供一种机制可以让发送方根据接收方的实际接收能力控制发送的数据量，这就是所谓的流量控制。")]),t._v(" "),_("p",[t._v("通过限制发送窗口的大小可以起到限制发送方流量的作用，如果窗口大小为 0 时，就会阻止发送方给接收方传递数据。")]),t._v(" "),_("h2",{attrs:{id:"介绍一下滑动窗口的窗口关闭-tcp-是如何解决潜在的死锁问题的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下滑动窗口的窗口关闭-tcp-是如何解决潜在的死锁问题的"}},[t._v("#")]),t._v(" 介绍一下滑动窗口的窗口关闭，TCP 是如何解决潜在的死锁问题的？")]),t._v(" "),_("p",[t._v("通过上一点可以知道，通过限制发送窗口的大小可以起到限制发送方流量的作用，如果窗口大小为 0 时，就会阻止发送方给接收方传递数据。如果处于窗口关闭状态并且接收方处理完数据后，会向发送方发送一个窗口非 0 的 ACK 报文，如果这个报文丢失了，那么发送方、接收方就会一直等待，形成死锁。")]),t._v(" "),_("p",[t._v("为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在收到这个探测报文时，会给出自己现在的接收窗口大小。")]),t._v(" "),_("ul",[_("li",[t._v("如果接收窗口仍然是 0，那么接收方会重新启动持续定时器")]),t._v(" "),_("li",[t._v("如果接收窗口不是 0，那么就会打破死锁，正常传输数据")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("窗口探测次数")]),t._v(" "),_("p",[t._v("窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。")])]),t._v(" "),_("h2",{attrs:{id:"糊涂窗口综合症"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#糊涂窗口综合症"}},[t._v("#")]),t._v(" 糊涂窗口综合症")]),t._v(" "),_("p",[t._v("如果发送端应用进程产生数据很慢或接收端应用进程处理接收缓冲区数据很慢，就会使应用进程间传送的报文段很小，特别是有效载荷很小。 极端情况下，有效载荷可能只有 1 个字节，传输开销有 40 字节(20 字节的 IP 头 + 20 字节的 TCP 头) 。")]),t._v(" "),_("p",[t._v("只有在下面两种情况任意一种/全部成立时，才会发生糊涂窗口综合症的情况：")]),t._v(" "),_("ul",[_("li",[t._v("发送方可以发送小数据")]),t._v(" "),_("li",[t._v("接收方可以通告一个小窗口")])]),t._v(" "),_("p",[t._v("解决方案：")]),t._v(" "),_("ul",[_("li",[t._v("发送方避免发送小数据")])]),t._v(" "),_("p",[t._v("使用 Nagle 算法，该算法的思路是延时处理，它满足以下两个条件中的一条才可以发送数据，\n只要没满足上面条件中的一条，发送方就会一直囤积数据，直到满足上面的发送条件。：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("窗口大小 >= MSS 或者数据大小 >= MSS")])]),t._v(" "),_("li",[_("p",[t._v("收到之前发送数据的 ack 回包\nNagle 算法默认是打开的，如果对于一些需要小数据包交互的场景的程序，比如 telnet 或 ssh 这样的交互性比较强的程序，则需要关闭 Nagle 算法（通过在 Socket 中设置 TCP_NODELAY 选项来关闭这个算法）。")])]),t._v(" "),_("li",[_("p",[t._v("接收方避免通告小窗口")])])]),t._v(" "),_("p",[t._v("当窗口大小小于 min(MSS，缓存空间/2 ) 时，就会向发送方通告窗口为 0，也就阻止了发送方再发数据过来。等到接收方处理了一些数据后，窗口大小 >= MSS 或者接收方缓存空间有一半可以使用，就可以把窗口打开让发送方发送数据过来。")])])}),[],!1,null,null,null);v.default=s.exports}}]);