(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{746:function(v,_,a){"use strict";a.r(_);var e=a(1),t=Object(e.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h2",{attrs:{id:"什么是-java-内存模型-jmm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-java-内存模型-jmm"}},[v._v("#")]),v._v(" 什么是 Java 内存模型（JMM）？"),a("Badge",{attrs:{text:"重点",type:"error"}})],1),v._v(" "),a("p",[v._v("JVM 规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。它主要规定了：一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。")]),v._v(" "),a("h2",{attrs:{id:"什么是主内存和工作内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是主内存和工作内存"}},[v._v("#")]),v._v(" 什么是主内存和工作内存？"),a("Badge",{attrs:{text:"重点",type:"error"}})],1),v._v(" "),a("p",[v._v("所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。")]),v._v(" "),a("div",{staticClass:"custom-block center"},[a("p",[a("img",{attrs:{src:"https://i.loli.net/2021/07/30/Qh7z2FIY5jasHUk.png",alt:"JMM.jpg"}})])]),v._v(" "),a("h2",{attrs:{id:"内存间交互的命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存间交互的命令"}},[v._v("#")]),v._v(" 内存间交互的命令？")]),v._v(" "),a("p",[v._v("线程间如果需要通讯，那么首先会将工作内存刷新到主内存中，另一个线程再从主内存读取最新的变量值。Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("read")]),v._v("：把一个变量的值从主内存传输到工作内存中")]),v._v(" "),a("li",[a("code",[v._v("load")]),v._v("：在 "),a("code",[v._v("read")]),v._v(" 之后执行，把 "),a("code",[v._v("read")]),v._v(" 得到的值放入工作内存的变量副本中")]),v._v(" "),a("li",[a("code",[v._v("use")]),v._v("：把工作内存中一个变量的值传递给执行引擎")]),v._v(" "),a("li",[a("code",[v._v("assign")]),v._v("：把一个从执行引擎接收到的值赋给工作内存的变量")]),v._v(" "),a("li",[a("code",[v._v("store")]),v._v("：把工作内存的一个变量的值传送到主内存中")]),v._v(" "),a("li",[a("code",[v._v("write")]),v._v("：在 "),a("code",[v._v("store")]),v._v(" 之后执行，把 "),a("code",[v._v("store")]),v._v(" 得到的值放入主内存的变量中")]),v._v(" "),a("li",[a("code",[v._v("lock")]),v._v("：作用于主内存的变量，把一个变量标识为一条线程独占状态")]),v._v(" "),a("li",[a("code",[v._v("unlock")]),v._v("：作用于主存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定")])]),v._v(" "),a("h2",{attrs:{id:"内存模型的三大特性是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存模型的三大特性是什么"}},[v._v("#")]),v._v(" 内存模型的三大特性是什么？")]),v._v(" "),a("h3",{attrs:{id:"原子性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[v._v("#")]),v._v(" 原子性")]),v._v(" "),a("p",[v._v("Java 内存模型保证了这些操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。")]),v._v(" "),a("h3",{attrs:{id:"可见性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可见性"}},[v._v("#")]),v._v(" 可见性")]),v._v(" "),a("p",[v._v("可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有三种实现方式实现可见性：")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("volatile")]),v._v("（再次强调 "),a("code",[v._v("volatile")]),v._v(" 只保证可见性不保证原子性）")]),v._v(" "),a("li",[a("code",[v._v("synchronized")]),v._v("，对一个变量执行 "),a("code",[v._v("unlock")]),v._v(" 操作之前，必须把变量值同步回主内存")]),v._v(" "),a("li",[a("code",[v._v("final")]),v._v("，被 "),a("code",[v._v("final")]),v._v(" 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 "),a("code",[v._v("this")]),v._v(" 逃逸（其它线程通过 "),a("code",[v._v("this")]),v._v(" 引用访问到初始化了一半的对象），那么其它线程就能看见 "),a("code",[v._v("final")]),v._v(" 字段的值")])]),v._v(" "),a("h3",{attrs:{id:"有序性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有序性"}},[v._v("#")]),v._v(" 有序性")]),v._v(" "),a("p",[v._v("有序性是指在本线程内观察，所有操作都是有序的（指本线程内是串行操作）。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序（或者是主内存和工作内存之间的延迟）。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。")]),v._v(" "),a("p",[a("code",[v._v("volatile")]),v._v(" 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。也可以通过 "),a("code",[v._v("synchronized")]),v._v(" 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。")]),v._v(" "),a("h2",{attrs:{id:"什么是先行发生原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是先行发生原则"}},[v._v("#")]),v._v(" 什么是先行发生原则？")]),v._v(" "),a("p",[v._v("除了上面提到的可以用 "),a("code",[v._v("volatile")]),v._v(" 和 "),a("code",[v._v("synchronized")]),v._v(" 来保证有序性，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。对于以下提到的内容，JVM 可以保证它的执行顺序，初次之外的内容 JVM 就可以随意的进行重排：")]),v._v(" "),a("ul",[a("li",[v._v("单一线程原则：在一个线程内，在前面的操作先行发生于后面的操作")]),v._v(" "),a("li",[v._v("管程锁定规则：一个 "),a("code",[v._v("unlock")]),v._v(" 操作先行发生于后面对同一个锁的 "),a("code",[v._v("lock")]),v._v(" 操作")]),v._v(" "),a("li",[a("code",[v._v("volatile")]),v._v(" 变量规则：对一个 "),a("code",[v._v("volatile")]),v._v(" 变量的写操作先行发生于后面对这个变量的读操作")]),v._v(" "),a("li",[v._v("线程启动规则："),a("code",[v._v("Thread")]),v._v(" 对象的 "),a("code",[v._v("start()")]),v._v(" 方法调用先行发生于此线程的每一个动作")]),v._v(" "),a("li",[v._v("线程加入规则：线程中的所有操作都先行发生于对此线程的终止检测")]),v._v(" "),a("li",[v._v("线程中断规则：对线程 "),a("code",[v._v("interrupt()")]),v._v(" 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 "),a("code",[v._v("interrupted()")]),v._v(" 方法检测到是否有中断发生")]),v._v(" "),a("li",[v._v("对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 "),a("code",[v._v("finalize()")]),v._v(" 方法的开始")]),v._v(" "),a("li",[v._v("传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C")])])])}),[],!1,null,null,null);_.default=t.exports}}]);