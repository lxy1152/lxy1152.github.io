---
title: 🌙 垃圾回收机制
---

## 对象引用与回收

垃圾收集主要是针对堆和方法区进行的，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

### 有哪几种引用类型？

无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 提供了四种强度不同的引用类型，按照顺序引用强度逐渐降低。

#### **强引用**

被强引用关联的对象不会被回收，使用 `new` 关键字创建一个新对象时，就是创建了强引用。

#### **软引用**

被软引用关联的对象只有在内存不够的情况下才会被回收，使用 `SoftReference` 类来创建软引用。
   
#### **弱引用**

被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前，使用 `WeakReference` 类来创建弱引用。

#### **虚引用**

又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知，需要和引用队列搭配起来使用，使用 `PhantomReference` 来创建虚引用。

### 如何判断对象是否可被回收？

可以使用引用计数法或者可达性分析算法来判断对象是否可被回收。

### 什么是引用计数算法？

为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1，引用计数为 0 的对象表示可被回收。在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。示例代码如下：

```java
public class Test {
    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();
        Test b = new Test();
        a.instance = b;
        b.instance = a;
        a = null;
        b = null;
        doSomething();
    }
}
```

### 什么是可达性分析算法？

以 GC Roots 为起始点进行搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。GC Roots 一般是以下内容：

- 虚拟机栈中局部变量表中引用的对象
- 本地方法栈中 JNI 中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

:::center
![GC Root.jpg](https://i.loli.net/2021/07/30/GpvU2nIrS4CjtD1.png)
:::

:::danger 不要使用 finalize() 方法
对象在被回收时，会调用 `Object` 类中的 `finalize()` 方法，如果调用该方法的时候能够重新使对象重新被引用，就可以实现自救，但自救的机会只有一次。

**如无特殊情况不用使用这个方法。**
:::

### 如何判断一个类是否是无用的类？

类需要同时满足下面 3 个条件才能算是无用的类：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例
- 加载该类的 `ClassLoader` 已经被回收
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是**可以**，而并不是和对象一样不使用了就会必然被回收。

## 内存分配与回收策略

### 什么是 Minor GC 和 Full GC？

#### **Minor GC**

回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。当 Eden 空间满时就会触发 Minor GC。

#### **Full GC**

回收新生代和老年代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

Full GC 的触发条件：

1. 调用 `System.gc()`

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

2. 老年代空间不足

老年代空间不足的常见场景为大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 `-Xmn` 参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 `-XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

3. 空间分配担保失败

使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。

4. JDK1.7 及以前的永久代空间不足

在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 `java.lang.OutOfMemoryError`。为避免以上原因引起的 Full GC，可采用的方法为：增大永久代空间大小或转为使用 CMS GC。

5. Concurrent Mode Failure

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

### JVM 的内存分配策略是什么？

#### **对象优先在 Eden 上分配**

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

#### **大对象直接进入老年代**

大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。`-XX:PretenureSizeThreshold` 大于此参数值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

#### **长期存活的对象进入老年代**

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。参数 `-XX:MaxTenuringThreshold` 用来定义年龄的阈值。

#### **动态对象年龄判定**
  
虚拟机并不是永远要求对象的年龄必须达到 `MaxTenuringThreshold` 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 `MaxTenuringThreshold` 中要求的年龄。

#### **空间分配担保**

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 `HandlePromotionFailure` 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将会尝试着进行一次 Minor GC；如果小于或者 `HandlePromotionFailure` 的值不允许冒险，那么就要进行一次 Full GC。

## 垃圾回收算法<Badge text="重点" type="error"/>

### 什么是标记-清除算法？

该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是针对它的不足进行改进得到的。这种垃圾收集算法会带来两个明显的问题：

- 效率问题
- 空间问题（标记清除后会产生大量不连续的碎片）

:::center
![标记-清理.jpg](https://i.loli.net/2021/07/30/SPvYVlhOpmgKwnJ.png)
:::

### 什么是标记-整理算法？

让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。相比较标记-清除算法而言，它不会产生内存碎片，但是需要移动大量对象，处理效率低。

:::center
![标记-整理.jpg](https://i.loli.net/2021/07/30/rK5dXPjukpSx4Hc.png)
:::

### 什么是复制算法？

将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。

现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。

:::center
![复制.jpg](https://i.loli.net/2021/07/30/PGaUAmF2Txfq5Ss.png)
:::

### 什么是分代收集？

现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法，一般将堆分为新生代和老年代：

- 新生代使用复制算法
- 老年代使用标记-清除或者标记-整理算法

## 垃圾回收器

### JVM 有哪些垃圾回收器？

:::center
![垃圾回收器.jpg](https://i.loli.net/2021/07/30/zQd3n6VFievBKtY.png)
:::

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

#### **单线程与多线程**

单线程指的是垃圾收集器只使用一个线程进行回收，多线程指的是垃圾收集器使用多个线程进行回收。

#### **串行与并行**

串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行，除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。

### 什么是 Serial 收集器？

Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。看名字就知道这个收集器是一个单线程收集器，它的单线程的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（"Stop The World"），直到它收集结束。

Serial 收集器在新生代采用复制算法，在老年代采用标记-整理算法。

:::center
![Serial收集器.jpg](https://i.loli.net/2021/07/30/fmjrMaopxuhbAIQ.png)
:::

### 什么是 ParNew 收集器？

ParNew 是 Serial 的多线程版本，除了使用多线程以外，与 Serial 收集器完全一致。

:::center
![ParNew收集器.jpg](https://i.loli.net/2021/07/30/Tzb4P7dEcjXQuGO.png)
:::

### 什么是 Parallel Scavenge 收集器？

Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。

所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成就可以了。

新生代采用复制算法，老年代采用标记-整理算法，是一个多线程的收集器。同时它是 JDK8 的默认收集器。

:::center
![ParallelScavenge收集器.jpg](https://i.loli.net/2021/07/30/Tzb4P7dEcjXQuGO.png)
:::

### 什么是 CMS 收集器？<Badge text="重点" type="error"/>

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它非常适合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的 Mark Sweep 这两个词可以看出，CMS 收集器是使用“标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整体分为四个步骤：

#### **初始标记**

暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。

#### **并发标记**

同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

#### **重新标记**

重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。

#### **并发清除**

开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

:::center
![CMS收集器.jpg](https://i.loli.net/2021/07/30/cIWHRtZV2boTdL7.png)
:::

CMS 收集器的缺点是：

#### **吞吐量低**

低停顿时间是以牺牲吞吐量为代价的。

#### **无法处理浮动垃圾**

可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

#### **标记 - 清除算法导致的空间碎片**

“标记-清除”算法会导致收集结束时会有大量空间碎片产生。

### 什么是 Serial Old 收集器？

Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：

- 在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用
- 作为 CMS 收集器的后备方案，在并发收集发生 Concurrent Mode Failure 时使用

### 什么是 Parallel Old 收集器？

Parallel Scavenge 收集器的老年代版本，在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### 什么是 G1 收集器？<Badge text="重点" type="error"/>

G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。G1 把堆划分成多个大小相等的独立区域（Region），使新生代和老年代不再物理隔离。

:::center
![G1Region.jpg](https://i.loli.net/2021/07/30/JvebfMrtipYwz8P.png)
:::

通过引入 Region 的概念，将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

1. 初始标记

2. 并发标记

3. 最终标记

为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。

4. 筛选回收

首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。

G1 收集器的流程图如下：

:::center
![G1垃圾回收器.jpg](https://i.loli.net/2021/07/30/atSL548mrYAlR1T.png)
:::

总结一下 G1 收集器的特点：
- 并行与并发

G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 的停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- 分代收集

虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- 空间整合

与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器，从局部上来看是基于“复制”算法实现的。
- 可预测的停顿

这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。
