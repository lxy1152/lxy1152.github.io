---
title: 🚥 ZooKeeper
---

## 介绍一下 CAP 理论？

CAP理论作为分布式系统的基础理论，它描述的是一个分布式系统在以下三个特性中最多同时满足其中两个。分布式系统要么满足 CA，要么满足 CP，要么满足 AP，无法同时满足 CAP。

### 一致性（Consistency）

在分布式系统完成某写操作后，对于任意的读操作都应该获取到该写操作写入的那个最新的值，相当于要求分布式系统中的各节点时时刻刻保持数据的一致性。

### 可用性（Availability）

可用性指可以进行正常的做读写操作，简单而言就是客户端一直可以正常访问并得到系统的正常响应，从用户角度来看就是不会出现系统操作失败或者访问超时等问题。

### 分区容错性（Partition tolerance）

分区容错性指分布式系统中的某个节点或者网络分区出现了故障的时候，整个系统仍然能对外提供满足一致性和可用性的服务，也就是说部分故障不影响整体使用。

::: tip CAP 的两两组合
- CA：优先保证一致性和可用性，放弃分区容错。这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。
- CP：优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合（比如 ZooKeeper、Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。
- AP：优先保证可用性和分区容错性，放弃一致性。NoSQL 中的 Cassandra 就是这种架构。跟 CP 一样，放弃一致性不是说一致性就不保证了，而是逐渐的变得一致。
:::

## 什么是 ZooKeeper？

ZooKeeper是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终将简单易用的接口和性能高效、功能稳定的系统提供给用户。

分布式应用程序可以基于 ZooKeeper 实现：数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

Zookeeper保证了如下的分布式一致性特性：

- 顺序一致性
- 原子性
- 单一视图
- 可靠性
- 实时性（最终一致性）

客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上注册了监听器，这个监听器也是由所连接的 ZooKeeper 机器来处理。对于写请求，这些请求会同时发给其他 ZooKeeper 机器并且达成一致后，请求才会返回成功。因此随着 ZooKeeper 的集群机器增多，读请求的吞吐会提高但是写请求的吞吐会下降。

有序性是 ZooKeeper 中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为 `zxid`（Zookeeper Transaction Id）。而读请求只会相对于更新有序，也就是读请求的返回结果中会带有这个 ZooKeeper 最新的 `zxid`。

## 介绍一下 ZooKeeper 的文件系统？

ZooKeeper 提供一个多层级的节点命名空间（节点称为 Znode），与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。ZooKeeper 为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 ZooKeeper 不能用于存放大量的数据，每个节点的存放数据上限为 1M。

## ZNode 有哪四种类型？

### PERSISTENT-持久节点

除非手动删除，否则节点一直存在于 ZooKeeper 上。

### EPHEMERAL-临时节点

临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与 ZooKeeper 连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。

### PERSISTENT_SEQUENTIAL-持久顺序节点

基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

### EPHEMERAL_SEQUENTIAL-临时顺序节点

基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。

## 什么是 ZAB 协议？

ZAB 协议一种支持崩溃恢复的原子广播协议，它包括两种基本的模式：崩溃恢复和消息广播。在 ZooKeeper 集群刚刚启动或者 leader 服务器宕机、重启或者网络故障导致不存在过半的服务器与 leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式：

首先选举产生新的 leader 服务器，然后集群中 follower 服务器开始与新的 leader 服务器进行数据同步，当集群中超过半数机器与该 leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，leader 服务器开始接收客户端的事务请求生成事务提案来进行事务请求处理。

## 什么是 ZooKeeper Watcher 机制？

ZooKeeper 允许客户端向服务端的某个 Znode 注册一个 Watcher 监听，当服务端的一些指定事件触发了这个 Watcher，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据 Watcher 通知状态和事件类型做出业务上的改变。

工作机制：

- 客户端注册 Watcher
- 服务端处理 Watcher
- 客户端回调 Watcher

## Watcher 机制的特性有哪些？

### 一次性

无论是服务端还是客户端，一旦一个 Watcher 被触发，ZooKeeper 都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，对于网络以及服务端的压力都非常大。

### 客户端串行执行

客户端 Watcher 回调的过程是一个串行同步的过程。

### 轻量
- Watcher 通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容
- 客户端向服务端注册 Watcher 的时候，并不会把客户端真实的 Watcher 对象实体传递到服务端，仅仅是在客户端请求中使用 boolean 类型属性进行了标记

### Watcher Event 异步发送 Watcher 的通知事件

ZooKeeper 不能保证监控到节点每次的变化，Zookeeper只能保证最终的一致性，而无法保证强一致性。

### 注册 Watcher 的方式

调用 `getData()`、`exists()`、`getChildren()` 这三个方法传入 Watcher 对象。

### 触发 Watcher 的方式

`create()`、`delete()`、`setData()`。

## Server 的状态的有哪些？

- LOOKING：当服务器处于该状态时，它会认为当前集群中没有 leader，因此需要进入 leader 选举状态
- FOLLOWING：跟随者状态，表明当前服务器角色是 follower
- LEADING：领导者状态，表明当前服务器角色是 leader
- OBSERVING：观察者状态，表明当前服务器角色是 observer。

::: tip 观察者
观察者是 ZooKeeper 3.3.0 版本后引入的一种角色，旨在不影响集群事务处理能力的基础上提升集群的非事务处理能力：

- 处理客户端的非事务请求，转发事务请求 leader 服务器
- 不参与任何形式的投票
:::

## 介绍一下 ZooKeeper 的选举机制？

1. 每个 Server 发出一个投票，投票信息包括：id 和 ZXID，使用（id，ZXID）来表示
2. 接受来自各个服务器的投票，首先判断检查投票的合法性（是否是本轮的投票、是否来自 LOOKING 状态的服务器）
3. 每个服务器都会处理投票：
    - 优先检查 ZXID，ZXID 较大的会作为 leader
    - 当 ZXID 相同时，id 较大的会作为 leader
4. 服务器会统计投票信息，判断当前是否已经有过半的服务器接收到相同的投票信息就认为已经选出了 leader
5. 一旦确定了 leader，每个服务器就会更新自己的状态为 LEADING/FOLLOWING

上述步骤中第二步至第四步会反复执行直到选出 leader。

## 数据同步的流程是什么？
集群在完成 leader 选举之后，learner（follower 和 observer 的统称）会向 leader 服务器进行注册。当 learner 服务器向 leader 服务器完成注册后，进入数据同步环节。

数据同步流程：（均以消息传递的方式进行）

- learner 向 leader 注册
- 数据同步
- 同步确认

数据同步的方式通常分为以下四类：

- 直接差异化同步（DIFF 同步）
- 先回滚再差异化同步（TRUNC + DIFF 同步）
- 仅回滚同步（TRUNC 同步）
- 全量同步（SNAP 同步）

## ZooKeeper 如何保证事务的顺序一致性？

ZooKeeper 采用了全局递增的事务 Id 来标识，所有的 Proposal（提议）都在被提出的时候加上了 ZXID。ZXID 实际上是一个 64 位的数字，高 32 位是 epoch 用来标识 leader 的周期，如果有新的 leader 产生出来，epoch 会自增；低 32 位用来递增计数。当新产生 Proposal 的时候，会向其他的 Server 发出事务执行请求，如果超过半数的机器都能执行并且能够成功，那么就会开始执行。

## ZooKeeper 节点宕机怎么处理？

ZooKeeper 集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在 ZooKeeper 节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。

## 为什么集群数量是奇数？

### 防止由脑裂造成的集群不可用

集群的脑裂通常是发生在节点之间通信不可达的情况下，这时集群会分裂成不同的小集群，小集群各自选出自己的 master 节点，导致原有的集群出现多个 master 节点，这就是脑裂。假如 ZooKeeper 集群有 4 个节点，脑裂成了 A、B 两个小集群：

1. A：1个节点， B：3个节点
2. A：2个节点， B：2个节点

情况 1 是满足选举条件的，但是情况 2 就不同了，因为 A 和 B 都是 2 个节点，都不满足可用节点数量 > 总节点数量一半的选举条件，所以此时 ZooKeeper 就彻底不能提供服务了。

### 在容错能力相同的情况下，奇数台更节省资源

有 3 个节点的集群，至少需要 2 个节点是正常的。有 4 个节点的集群，至少需要 3 个节点是正常的。这两个集群都只允许一个节点宕机，但后一个集群所需要的节点数量还更多。所以使用奇数个更好。
