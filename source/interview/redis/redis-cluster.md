---
title: 🧏‍♂️ Redis 集群
---

## Redis 集群有哪些方式？

### 主从模式

只需要在配置文件加上 `slaveof 192.169.x.x 6379`，指明主服务器的 IP 和端口号就会启动主从模式，主从模式下从服务器会自动模仿主服务器的操作并写入。

### 哨兵模式

给几台哨兵服务添加不同的端口，配置主服务器的 IP 和端口，并且加上权值，使用 Redis 命令：`redis-server.exe redis-xx.conf --sentinel` 启动哨兵。配置文件：

```text
sentinel monitor master 127.0.0.1 28380 2 # 主服务器的IP和端口，后面的数字表示有多少个哨兵认为master失效，master才真正失效
sentinel down-after-milliseconds master 5000 # 超过这个时间认为主服务器挂了
sentinel failover-timeout master 30000 # 投票选举超时时间
```

### 集群模式

修改配置文件：

```text
port 7000 # 不同节点配置不同的端口
logfile "./redis.log" # 输出的日志
daemonize yes # 是否以守护进程的方式启动，如果是的话除非手动kill，否则不会关闭进程

cluster-enable yes # 是否启用集群
cluster-config-file nodes-7000.conf # 指定配置文件，每个节点需要指定不同的配置文件
cluster-node-timeout 15000 # 集群超时时间
cluster-require-full-coverage no # 集群不完整是否依然可以提供服务
```

## 介绍一下一致性哈希？

假设 Redis 集群中有三个节点，那么数据应该保存在哪个节点通常是由 `key % 3` 计算得到的。如果希望新增一个节点，由于数量已经固定为 3，那么数据将永远不会落在第四个节点上。另外如果某个节点挂了，那么将不能写入、获取数据。所以需要通过一致性哈希算法来解决这个问题。

首先容量肯定不能固定，可以将容量设置为一个很大的数，比如：$2^{31} - 1$。数据在存储时对它求余，然后选取离结果最近的节点进行保存。在下面的图中，四个对象（ObjectA ~ ObjectD）就根据计算得到哈希值就近选择了要保存的节点：

:::center
![一致性哈希.png](https://i.loli.net/2021/07/31/96VTDlqONSGjaHp.png)
:::

但是在 Redis 中并没有使用这种方式，而是引入了哈希槽（slot）的概念。集群总共包含了 16384 个哈希槽，每个 `key` 通过计算后都会落在一个具体的槽位上，而这个槽位具体属于哪个存储节点则由用户自己分配。比如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。通过哈希槽这种概念很好地解决了一致性哈希的弊端。

在容错性和扩展性上，哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。

## Redis 的分布式锁？<Badge text="重点" type="error"/>

### SETNX

使用 `SET`、`SETNX` （SETifNot eXists）等命令插入一条记录，其他客户端通过获取 `key` 来判断是否可以获取锁。为了避免死锁，需要设置超时时间。

#### **优点**

- Redis 性能很好
- Redis 对命令的支持较好，实现起来比较方便

#### **缺点**

- Redis 分布式锁，需要自己不断尝试去获取锁，比较消耗性能
- Redis 获取锁的那个客户端如果挂了，只能等待超时时间后才能释放锁

### RedLock

假设现在有 5 个 Redis 节点，通过 RedLock 途径获取锁的过程如下：

1. 获取当前 Unix 时间，以毫秒为单位
2. 依次尝试从 5 个实例，使用相同的 `key` 和具有唯一性的 value（例如 UUID）获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间（避免服务端已经挂了，客户端还在等待）
3. 客户端使用当前时间减去开始获取锁时间（步骤 1 记录的时间）就得到获取锁使用的时间，当且仅当从大多数（$\frac N 2 +1$，这里是 3 个节点）的 Redis 节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功
4. 如果取到了锁，`key` 的真正有效时间等于有效时间减去获取锁所使用的时间（步骤 3 的时间）
5. 如果因为某些原因，获取锁失败（超时或者达不到大多数节点的要求），那么就需要在所有的 Redis 节点上进行解锁
