---
title: 🙅‍♂️ Redis 淘汰策略
---

## Redis 的删除策略有哪些？

Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。对于散列表这种容器，只能为整个散列表设置过期时间，而不能为键里面的某个元素设置过期时间。

```text
127.0.0.1:6379> exp key  60 # 数据在 60s 后过期
(integer) 1
127.0.0.1:6379> setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire)
OK
127.0.0.1:6379> ttl key # 查看数据还有多久过期
(integer) 56
```

:::tip 过期命令
Redis 中除了字符串类型有自己独有设置过期时间的命令 `setex` （set + ex）外，其他方法都需要依靠 `expire` 命令来设置过期时间，使用 `persist` 命令可以移除一个键的过期时间。
:::

当时间到时，Redis 将如何删除这些值呢？常用的过期数据的删除策略就两个：

- 惰性删除：只会在取出 `key` 的时候才对数据进行过期检查，这样对 CPU 最友好，但是可能会造成太多过期 `key` 没有被删除
- 定期删除：每隔一段时间抽取一批 `key` 执行删除过期 `key` 的操作，并且 Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响

定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有优劣，所以 Redis 采用的是定期删除 + 惰性删除。但是仅仅通过给 `key` 设置过期时间还是有问题的，因为还是可能存在漏掉很多过期 `key` 的情况。这样就导致大量过期 `key` 堆积在内存里，然后就 `Out of memory` 了。这个问题的解决方案是数据淘汰机制。

## 有哪些更新/淘汰策略？

在 Redis 中可以设置最大使用量，当内存使用量超出时，会根据数据淘汰策略对数据进行淘汰。Redis 有 6 种淘汰策略：

- volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
- allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰
- allkeys-random：从所有数据集中任意选择数据进行淘汰
- noeviction：禁止驱逐数据

作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 `key`，而是抽样一小部分并且从中选出被淘汰的 `key`。使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。

Redis 4.0 中引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对（最近一次被访问次数最少的数据）淘汰。
