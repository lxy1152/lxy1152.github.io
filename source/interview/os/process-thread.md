---
title: 🧝‍♂️ 进程与线程
---

## 进程

### 并发和并行的区别？

- 并发：能够处理多个任务，但不一定同时
- 并行：能够处理多个任务，并且能够同时执行（只要速度足够快，看起来就像是在同时执行）

### 进程有哪几个状态？

:::center
![进程状态1.png](https://i.loli.net/2021/08/01/Sdlb9XfRaGqYLUm.png)
:::

如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，非常浪费空间。所以在使用虚拟内存管理的操作系统中，通常会把处于阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候再从硬盘换入到物理内存。通过挂起状态来描述这种行为。

挂起状态又分为：

- 阻塞挂起：进程在外存（硬盘）并等待某个事件的出现
- 就绪挂起：进程在外存（硬盘），但只要进入内存，那么立刻就会运行（比如通过 Ctrl+Z 挂起进程）

:::center
![进程状态2.png](https://i.loli.net/2021/08/01/RPVBXA2zmdyJptn.png)
:::

### 什么是进程控制块？

进程控制块（process control block，PCB）是操作系统用来描述进程的一种数据结构。一个进程必然会对应一个 PCB，如果进程结束了，那么 PCB 也会随之消失。一个 PCB 中会包含以下信息：

- 进程描述信息
    - 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符
    - 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务
- 进程控制和管理信息
    - 进程当前状态：如 new、ready、running、waiting 或 blocked 等
    - 进程优先级：进程抢占 CPU 时的优先级
- 资源分配清单
    - 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息
- CPU 相关信息
    - CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行

### 什么是进程的上下文切换？

进程是由内核管理和调度的，所以进程的切换只能发生在内核态。进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。通常，会把交换的信息保存在进程的 PCB，当要运行另外一个进程的时候，我们需要从这个进程的 PCB 取出上下文，然后恢复到 CPU 中，这使得这个进程可以继续执行，如下图所示：

:::center
![进程上下文切换.png](https://i.loli.net/2021/08/01/sVzGlWwXuTQtIJB.png)
:::

### 哪些情况会引发线程上下文切换？
- 时间片用完
- 所需资源（比如内存）不足
- 调用 `sleep` 主动挂起
- 有更高优先级的进程需要先执行
- 发生硬件中断

## 线程

### 什么是线程？

线程是进程当中的一条执行流程。同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程都有独立一套的寄存器和栈，这样可以确保线程的控制流是相对独立的。

### 线程与进程的比较？

线程与进程的区别如下：

- 进程是资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
- 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系
- 线程能减少并发执行的时间和空间开销

线程相比进程能减少开销，体现在：

- 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们
- 线程的终止时间比进程快，因为线程释放的资源相比进程少很多
- 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的
- 由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了

### 什么是线程的上下文切换？

- 当两个线程不是属于同一个进程时，切换的过程就跟进程上下文切换一样
- 当两个线程是属于同一个进程时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据

## 调度

### 什么情况下会发生调度？

- 从就绪态转变为运行态
- 从运行态转变为阻塞态
- 从运行态转变为结束态

以上三种情况，操作系统都需要重新选择一个进程来执行，所以需要调度。调度算法大体上分为两类：

- 非抢占式调度算法：挑选一个进程，然后让该进程运行直到被阻塞，或者直到该进程退出，才会调用另外一个进程，也就是说不会理时钟中断这个事情
- 抢占式调度算法：挑选一个进程，然后让该进程只运行某段时间，如果在该时段结束时，该进程仍然在运行时，则会把它挂起，接着调度程序从就绪队列挑选另外一个进程，这种抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把 CPU 控制返回给调度程序进行调度，也就是常说的时间片机制

### CPU 调度的基本原则？

- CPU 利用率：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率
- 系统吞吐量：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量
- 周转时间：周转时间是进程运行和阻塞时间总和，一个进程的周转时间越小越好
- 等待时间：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意
- 响应时间：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准

### 有哪些调度算法？

#### 先来先服务算法

先来先服务（First Come First Severd, FCFS）算法是指每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。这似乎很公平，但是当一个长作业先运行了，那么后面的短作业等待的时间就会很长，这将不利于短作业。

#### 最短作业优先调度算法

最短作业优先（Shortest Job First, SJF）调度算法会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。但这种算法很明显对长作业不友好。

#### 高响应比优先调度算法

高响应比优先 （Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算响应比优先级，然后把响应比优先级最高的进程投入运行，响应比优先级的计算公式：

:::center
$$优先权 = \frac{等待时间+要求服务时间}{要求服务时间}$$
:::

#### 时间片轮转调度算法

时间片轮转（Round Robin, RR）调度算法是给每个进程分配一个时间段，称为时间片（Quantum）。
- 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外一个进程
- 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换

#### 最高优先级调度算法

时间片轮转算法做了个假设，即让所有的进程同等重要，大家的运行时间都一样。但是对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。

进程的优先级可以分为，静态优先级或动态优先级：
- 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化
- 动态优先级：根据进程的动态变化调整优先级，比如进程运的行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级

#### 多级反馈队列调度算法

多级反馈队列（Multilevel Feedback Queue）调度算法是时间片轮转算法和最高优先级算法的综合和发展。

- 多级表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短
- 反馈表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列

## 进程间的通信方式

### 为什么要进行进程间通信？

程序中经常需要多个进程同时工作，这些进程需要互相通信，这就需要进程间通信。进程间的通信方式包括：

- 管道
- 消息队列
- 共享内存
- 信号量
- 信号
- Socket

### 如何通过管道实现进程间通信？

在 Linux 中使用符号 `|` 就是使用了管道的功能。这种方式实际上是创建了一个匿名管道，它将前一个命令的的输出作为后一个命令的输入，比如：`ps auxf | grep mysql`。

还有一种方式可以创建一个命名管道，它通过 `mkfifo` 命令创建，比如：`mkfifo myPipeline`。管道这种通信方式效率低，不适合进程间频繁通信。

### 如何通过消息队列实现进程间通信？

对于管道存在的问题，可以使用消息队列进行解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。

但这种方式有两个问题：
- 通信不及时
- 传送的消息大小有限制

由于进程是写入数据到内核的消息队列，所以发生从用户态到内核态的过程，读取数据同理，所以还存在状态切换的开销。

### 如何通过共享内存实现进程间通信？

共享内存就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，不需要再传来传去，大大提高了进程间通信的速度。

:::center
![共享内存.png](https://i.loli.net/2021/08/01/Qa3BSfYgqyCoLMj.png)
:::

### 如何通过信号量实现进程间通信？

通过共享内存进行通信的方式会带来新的问题：如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。为了防止多进程竞争共享资源，而造成的数据错乱，需要一种保护机制，使得共享的资源，在任意时刻只能被一个进程访问。信号量就实现了这样一种保护机制。

信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。信号量表示资源的数量，控制信号量的方式有两种原子操作：

- P 操作：这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待，如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行
- V 操作：这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行，如果信号量 > 0，则表明当前没有阻塞中的进程

P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。在下面的例子中信号量被初始化为 1：

:::center
![pv操作举例.png](https://i.loli.net/2021/08/01/sMUOdwgqEIDbPiN.png)
:::

### 如何通过信号实现进程间通信？

上面说的几种方式都是常规状态下的工作模式。对于异常情况下的工作模式，需要用信号的方式来通知进程。

在 Linux 中为了响应各种各样的事件，提供了几十种信号，分别代表不同的意义，通过 `kill -l` 命令可以查看所有的信号。

在终端中，通过键盘组合键也可以发送信号：

- `Ctrl + C`：产生 `SIGINT` 信号，表示终止进程
- `Ctrl + Z`：产生 `SIGTSTP` 信号，表示挂起进程

### 如何通过 Socket 实现进程间通信？

前面所说的的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。针对 TCP 协议的 Socket 编程模型：

:::center
![TCP编程模型.png](https://i.loli.net/2021/08/01/KDGJEiz2WpLjhcN.png)
:::

针对 UDP 协议的 Socket 编程：

:::center
![udp编程模型.png](https://i.loli.net/2021/08/01/wT5Y1NzIUK92Xnt.png)
:::

实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。
