---
title: 🧟 锁
---

## 互斥锁与自旋锁

### 什么是互斥锁？

互斥锁是一种独占锁，比如线程 A 获取了互斥锁，那么只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，那么线程 B 加锁的代码就会被阻塞。互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的。当加锁失败时，内核会将线程置为睡眠状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，就可以继续执行。

互斥锁的开销主要在于上下文切换（时间大概在几十纳秒到几微秒之间），如果锁住的代码执行时间比较短，那可能上下文切换的时间都比锁住的代码执行时间还要长。所以，如果能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁。

### 什么是自旋锁？

自旋锁是通过 CPU 提供的 CAS 函数（Compare And Swap），在用户态完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。自旋锁在锁不可用时会一直自旋，一直占据 CPU，直到锁可用。比较适合于异步、协程等在用户态切换请求的编程方式。但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成正比的关系的。

## 读写锁

### 什么是读写锁？

读写锁由读锁和写锁两部分构成，如果只读取共享资源用读锁加锁，如果要修改共享资源则用写锁加锁：

- 当写锁没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为读锁是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据
- 一旦写锁被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞

所以读写锁在读多写少的场景，能发挥出比较大的优势。根据使用场景的不同，读写锁可细分为读优先锁和写优先锁：

- 读优先锁：优先进行读操作，写操作会被阻塞，如果一直在读，写操作会一直无法运行
- 写优先锁：优先进行写操作，读操作会被阻塞，如果一直在写，读操作会一直无法运行

为了解决这个问题，可以实现一个公平读写锁：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁，这样读线程仍然可以并发，也不会出现饥饿的现象。

## 乐观锁与悲观锁

### 什么是悲观锁？

悲观锁做事比较悲观，它认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前必须要上锁。比如：互斥锁、自旋锁、读写锁。

### 什么是悲观锁？

乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。比如：CAS。

## 死锁

### 什么是死锁？

当两个线程为了保护两个不同的共享资源而使用了两个互斥锁，如果这两个互斥锁应用不当的时候，可能会造成两个线程都在等待对方释放锁，在没有外力的作用下，这些线程会一直相互等待，就没办法继续运行，这种情况就是发生了死锁。

只有同时满足以下四个条件死锁才会发生：

- 互斥条件：多个线程不能同时使用同一个资源
- 持有并等待条件：当线程 A 已经持有了资源一，又想申请资源 二，而资源二已经被线程 C 持有了，那么线程 A 就会处于等待状态，但是线程 A 在等待资源二的同时并不会释放自己已经持有的资源二
- 不可剥夺条件：当线程已经持有了资源，在自己使用完之前不能被其他线程获取，线程 B 如果也想使用此资源，则只能在线程 A 使用完并释放后才能获取
- 环路等待条件：在死锁发生的时候，两个线程获取资源的顺序构成了环形链。比如线程 A 已经持有资源 2，而想请求资源 1， 线程 B 已经获取了资源 1，而想请求资源 2
