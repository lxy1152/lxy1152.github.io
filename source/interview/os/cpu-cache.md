---
title: 🧚 CPU 缓存一致性
---

## CPU 缓存的结构

### CPU 缓存的结构是怎么样的？

CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度越快，但是存储容量相对就会越小。在多核心的 CPU 中，每个核心都有各自的 L1/L2 Cache，而 L3 Cache 是所有核心共享使用的。

:::center
![cpu缓存结构.png](https://i.loli.net/2021/08/01/DoZ3wJXFTiG2LQe.png)
:::

## CPU 缓存的数据写入

### 什么是写直达策略？

写直达策略会把数据同时写入缓存和内存，这种方法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响（相比缓存的读写速度而言内存的读写速度是相当慢了）。

### 什么是写回策略？

因为写直达每次都有写操作将数据写回到内存，而影响性能，为了减少数据写回内存的频率，就出现了写回（Write Back）策略。在写回策略中，当发生写操作时，新的数据仅仅被写入到缓存中，只有当修改过的缓存要被替换时才会将数据写到内存中，减少了数据写回内存的频率，这样可以提高系统的性能。

:::center
![写回策略.jpg](https://i.loli.net/2021/08/01/T9PcnLg3krKCEwQ.png)
:::

可以发现写回策略在把数据写入到缓存的时候，只有在缓存不命中同时数据对应的缓存中的缓存块为脏的情况下，才会将数据写到内存中；在缓存命中的情况下，只需把该数据对应的缓存块标记为脏，不需要写到内存里。
这样的好处是：如果大量的操作都能够命中缓存，那么在大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。

## 缓存一致性问题

### 什么是缓存一致性问题？

由于 L1/L2 Cache 是多个核心各自独有的，那么就可能引发多核心的缓存一致性（Cache Coherence）问题，即多核心下不同缓存内的数据需要保持一致。下面是一个含有两核心的 CPU，假设 A 号核心和 B 号核心同时运行两个线程，都操作内存中共同的变量 i（初始值为 0 ），写策略为写回策略。

如果 A 号核心执行了 i++ 语句，会把值为 1 的执行结果写入到 L1/L2 Cache 中，然后把 L1/L2 Cache 中对应的 Block 标记为脏的，这个时候数据是没有被同步到内存中的。如果这时 B 号核心尝试从内存读取 i 变量的值，则读到的将会是错误的值，因为刚才 A 号核心更新 i 值还没写入到内存中，内存中的值还依然是 0，会导致执行结果的错误。

:::center
![缓存一致性问题举例.png](https://i.loli.net/2021/08/01/HMdKVBuO7CqGD6n.png)
:::

### 如何保证数据一致？

- 写传播（Wreite Propagation）：某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的缓存
- 事务的串形化（Transaction Serialization）：某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的

### 什么是总线嗅探机制？

一种比较简单的实现写传播原则的方式是使用总线嗅探，CPU 需要每时每刻监听总线上的一切活动，只要有某个核心修改了值就会通知其他所有的核心进行更新。不管别的核心的 Cache 是否缓存相同的数据，都会发出一个广播事件，这无疑会加重总线的负载。

另外，总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。于是，有一个协议基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。

### 什么是 MESI 协议？

MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：

#### Modified

已修改状态，就是前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。

#### Exclusive

独占状态，此时数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。同时这个状态代表这个缓存中的数据是干净的。如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候独占状态下的数据就会变成共享状态。

#### Shared

共享状态，代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当需要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为无效状态，然后再更新当前 Cache 里面的数据。

#### Invalidated

已失效状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。

MESI 状态转移图：

:::center
![MESI.png](https://i.loli.net/2021/08/01/Yf2Imakg91WQ84L.png)
:::
