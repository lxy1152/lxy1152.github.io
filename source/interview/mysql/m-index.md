---
title: ✌️ 索引
---

## 为什么使用数据库索引可以提高效率？

默认执行 SQL 语句时是进行全表扫描的，遇到匹配条件的就加入结果集。如果有索引，就会先去索引表中一次定位到特定值的行数，减少遍历匹配的行数。索引把无序的数据变成了相对有序的数据结构。

## 索引的底层数据结构是什么？<Badge text="重点" type="error"/>

B+ 树。

## 什么是 B+ 树？<Badge text="重点" type="error"/>

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现的，它具有 B Tree 的平衡性，并且可以通过顺序访问指针来提高区间查询的性能。在 B+ Tree 中，一个节点中的 `key` 从左到右非递减排列，如果某个指针的左右相邻 `key` 分别是 $key_i$ 和 $key_{i+1}$，且不为 `null`，则该指针指向节点的所有 $key$ 大于等于 $key_i$ 且小于等于 $key_{i+1}$。

:::center
![B+_树.jpg](https://i.loli.net/2021/07/30/xu6AGHYJw5NvXC9.png)
:::

## 为什么采用 B+ 树而不是 B 树？<Badge text="重点" type="error"/>

B+ 树和 B 树的区别：

- B+ 树非叶子节点只存储关键字和指向子节点的指针，而 B 树还存储了数据，在同样大小的情况下，B+ 树可以存储更多的关键字
- B+ 树叶子节点存储了所有关键字和数据，并且多个节点用链表连接，可以快速进行范围查找
- B+ 树非叶子节点不存储数据，所以查询时间复杂度固定为 $O(\log N)$，B 树查询时间复杂度不固定，最好是 $O(1)$

## 为什么采用 B+ 树而不是红黑树？<Badge text="重点" type="error"/>

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ 树作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。

### B+ 树有更低的树高

平衡树的树高 $O(h)\ =\ O(\log_dN)$，其中 `d` 为每个节点的出度。红黑树的出度为 `2`，而 B+ 树的出度一般都非常大，所以红黑树的树高 `h` 很明显比 B+ 树大非常多。

### 磁盘访问原理

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。

### 磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。

## 什么是聚簇和非聚簇索引？<Badge text="重点" type="error"/>

- 聚簇索引，又叫主键索引，每个表只有一个主键索引，即每张表按照主键构造一颗 B+ 树，叶子节点中存放的就是整张表的记录数据
- 非聚簇索引，又叫辅助索引，叶子节点保存相应行数据的主键索引值

## 什么是前缀索引？

如果列的值较长，比如 `blob`、`text`、`varchar` 就必须建立前缀索引，即将值的前一部分（或后一部分）作为索引。这样既可以节约空间，又可以提高查询效率。但无法使用前缀索引做 `order by` 和 `group by`，也无法使用前缀索引做覆盖扫描。

## 什么是覆盖索引？<Badge text="重点" type="error"/>

覆盖索引是指 `select` 语句所查找的数据列从索引中就能获得，不必再从数据表中读取。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。当发起一个被索引覆盖的查询（也叫作索引覆盖查询）时，在解释方案的 Extra 列会提示 Using index。

:::tip 回表查询
如果通过一个索引树不能拿到所有的数据，那么就会根据辅助索引中叶子节点所对应的主键去主键索引树种查询需要的信息，这种方式叫做回表查询。由于需要查多棵树，所以效率肯定会降低。举个例子：

假设用户表（user）需要保存用户 id，用户姓名（name），用户性别（sex）。主键是 id，在 name 列上建了一个索引。如果使用下面的 sql 进行查询就使用到了覆盖索引，因为通过 name 索引树可以获得 name 和对应的 id（name 索引树的叶子节点保存会保存主键）：

```sql
select id, name from user where name = ?;
```

相反如果使用下面的 sql 进行查询，将导致回表查询，因为 name 索引树种不包含 sex 的信息，这个信息必须通过主键索引树进行获取：

```sql
select id, name, sex from user where name = ?;
```
:::

## 什么情况会导致索引失效？<Badge text="重点" type="error"/>

对于以下情况，索引会失效：

- `like` 以 % 开头
- `or` 查询，必须左右字段都是索引，否则索引失效
- 联合索引，遵从最左匹配原则，如果不是使用第一列索引，索引失效
- 数据出现隐形转换，如 `varchar` 字段没加单引号，自动转为 `int` 类型，会使索引失效
- 索引字段使用 `not`、`<>`、`!=` 会使索引失效
- 索引字段使用函数，索引无效

## 什么是最左匹配原则？<Badge text="重点" type="error"/>

对于联合索引，这些值在 B+ 树中存储时，是按照第一个值升序、第二个值升序...第 n 个值升序的方式来排列的（如果某个值相同，那么会比较下一个值）。举个例子：假设索引列是 a、b、c，那么索引中保存的结构可能是：

（1，1，1），（1，1，2），（1，2，1），（1，2，2），（2，1，1）......

因此，如果查询时未指定最左侧的列，那么将不能快速定位数据的范围，导致 MySQL 需要进行全表（或范围）扫描。 还是以上面的内容举例，比如我用使用这个语句来搜索：

```sql
select * from tableName where b = 2;
```

由于没有指定 a 的值，那么只能挨个访问记录，看一下 b 是不是等于 2。相反，如果我用这个语句来搜索：

```sql
select * from tableName where a = 1 and b = 2;
```

由于指定了 a = 1，那么只需要在有限的集合中进行查找就可以了。通过 `explain` 也可以看到上述两条语句的区别。

## 什么是 Mysql 索引重建，为什么需要索引重建？

数据库在删除数据时只是将原始数据标记为已删除，实际上并没有释放空间，这会造成页面中有很多空洞，所以需要重建索引提高页面页面利用率。索引重建的过程会创建一个新的索引，把数据按顺序插入，使索引更紧凑、更省空间。重建索引的方式包括：

- `mysqldump` 导出然后重新导入
- `alter table tableName ENGINE = InnoDB`
- `alter table tableName drop/add index k`
- `alter table tableName drop/add primary key`

## 解释方案中关键的字段有哪些？<Badge text="重点" type="error"/>

在一个语句的前面添加 `explain` 就可以获得这个语句的执行方案。在执行方案中有几个比较关键的字段（以下内容只列举了一部分，实际上内容很多）：

<table>
   <tr>
      <th>字段</th>
      <th>字段含义</th>
      <th>可能的取值</th>
      <th>这个取值的含义</th>
   </tr>
   <tr>
      <th rowspan="3">type</th>
      <td rowspan="3">查找类型</td>
      <td>all</td>
      <td>表示此次查询进行了全表扫描</td>
   </tr>
   <tr>
      <td>const</td>
      <td>表示表中有多条记录，但只从表中查询一条记录</td>
   </tr>
   <tr>
      <td>index</td>
      <td>表示对表中的索引进行了完整的扫描</td>
   </tr>
   <tr>
      <th>possible_keys</th>
      <td>查询可能使用到的索引都会在这里列出来，如果为空说明没有可用的索引</td>
      <td></td>
      <td></td>
   </tr>
   <tr>
      <th>key</th>
      <td>实际使用的索引</td>
      <td></td>
      <td></td>
   </tr>
   <tr>
      <th>rows</th>
      <td>表示查询的行数，这个值是一个估计值</td>
      <td></td>
      <td></td>
   </tr>
   <tr>
      <th>extra</th>
      <td>额外的信息说明</td>
      <td>using_index</td>
      <td>表示此次查询利用了覆盖索引</td>
   </tr>
</table>
